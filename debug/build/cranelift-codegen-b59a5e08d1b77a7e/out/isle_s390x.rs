// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src\prelude.isle
// - src\prelude_lower.isle
// - src\isa\s390x\inst.isle
// - src\isa\s390x\lower.isle
// - <OUT_DIR>\numerics.isle
// - <OUT_DIR>\clif_lower.isle

use super::*;  // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self, ) -> Unit;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> i32;
    fn checked_add_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> Option<u64>;
    fn add_overflows_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> bool;
    fn imm64_sdiv(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_srem(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn i64_sextend_u64(&mut self, arg0: Type, arg1: u64) -> i64;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn imm64_clz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn imm64_ctz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn u128_replicated_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_replicated_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u32_replicated_u16(&mut self, arg0: u64) -> Option<u64>;
    fn u16_replicated_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u128_low_bits(&mut self, arg0: u128) -> u64;
    fn u128_high_bits(&mut self, arg0: u128) -> u64;
    fn f16_min(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_max(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_neg(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_abs(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_copysign(&mut self, arg0: Ieee16, arg1: Ieee16) -> Ieee16;
    fn f32_add(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sub(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_mul(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_div(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sqrt(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_ceil(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_floor(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_trunc(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_nearest(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_min(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_max(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_neg(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_abs(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_copysign(&mut self, arg0: Ieee32, arg1: Ieee32) -> Ieee32;
    fn f64_add(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sub(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_mul(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_div(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sqrt(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_ceil(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_floor(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_trunc(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_nearest(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_min(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_max(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_neg(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_abs(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_copysign(&mut self, arg0: Ieee64, arg1: Ieee64) -> Ieee64;
    fn f128_min(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_max(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_neg(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_abs(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_copysign(&mut self, arg0: Ieee128, arg1: Ieee128) -> Ieee128;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_count(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn ty_half_lanes(&mut self, arg0: Type) -> Option<Type>;
    fn ty_half_width(&mut self, arg0: Type) -> Option<Type>;
    fn ty_equal(&mut self, arg0: Type, arg1: Type) -> bool;
    fn mem_flags_trusted(&mut self, ) -> MemFlags;
    fn little_or_native_endian(&mut self, arg0: MemFlags) -> Option<MemFlags>;
    fn intcc_swap_args(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_complement(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_without_eq(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_swap_args(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_complement(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16_or_32(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u16_from_ieee16(&mut self, arg0: Ieee16) -> u16;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_i32(&mut self, arg0: Offset32) -> i32;
    fn i32_to_offset32(&mut self, arg0: i32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self, ) -> TrapCode;
    fn trap_code_integer_overflow(&mut self, ) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self, ) -> TrapCode;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn writable_value_reg(&mut self, arg0: WritableReg) -> WritableValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn writable_value_regs(&mut self, arg0: WritableReg, arg1: WritableReg) -> WritableValueRegs;
    fn value_regs_invalid(&mut self, ) -> ValueRegs;
    fn output_none(&mut self, ) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_vec(&mut self, arg0: &ValueRegsVec) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn is_valid_reg(&mut self, arg0: Reg) -> bool;
    fn invalid_reg(&mut self, ) -> Reg;
    fn mark_value_used(&mut self, arg0: Value) -> Unit;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn put_in_regs_vec(&mut self, arg0: ValueSlice) -> ValueRegsVec;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn value_regs_len(&mut self, arg0: ValueRegs) -> usize;
    fn preg_to_reg(&mut self, arg0: PReg) -> Reg;
    fn add_range_fact(&mut self, arg0: Reg, arg1: u16, arg2: u64, arg3: u64) -> Reg;
    fn single_target(&mut self, arg0: &MachLabelSlice) -> Option<MachLabel>;
    fn two_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, MachLabel)>;
    fn jump_table_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, BoxVecMachLabel)>;
    fn jump_table_size(&mut self, arg0: &BoxVecMachLabel) -> u32;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn value_is_unused(&mut self, arg0: Value) -> bool;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data_value(&mut self, arg0: Inst) -> InstructionData;
    fn i64_from_iconst(&mut self, arg0: Value) -> Option<i64>;
    fn zero_value(&mut self, arg0: Value) -> Option<Value>;
    fn is_sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn maybe_uextend(&mut self, arg0: Value) -> Option<Value>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn block_exn_successor_label(&mut self, arg0: &Block, arg1: u64) -> MachLabel;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn sink_inst(&mut self, arg0: Inst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u64_be_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u128_le_const(&mut self, arg0: u128) -> VCodeConstant;
    fn emit_u128_be_const(&mut self, arg0: u128) -> VCodeConstant;
    fn const_to_vconst(&mut self, arg0: Constant) -> VCodeConstant;
    fn tls_model(&mut self, arg0: Type) -> TlsModel;
    fn tls_model_is_elf_gd(&mut self, ) -> Option<Unit>;
    fn tls_model_is_macho(&mut self, ) -> Option<Unit>;
    fn tls_model_is_coff(&mut self, ) -> Option<Unit>;
    fn preserve_frame_pointers(&mut self, ) -> Option<Unit>;
    fn stack_switch_model(&mut self, ) -> Option<StackSwitchModel>;
    fn box_external_name(&mut self, arg0: ExternalName) -> BoxExternalName;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn exception_sig(&mut self, arg0: ExceptionTable) -> SigRef;
    fn symbol_value_data(&mut self, arg0: GlobalValue) -> Option<(ExternalName, RelocDistance, i64)>;
    fn vec_mask_from_immediate(&mut self, arg0: Immediate) -> Option<VecMask>;
    fn u128_from_immediate(&mut self, arg0: Immediate) -> Option<u128>;
    fn vconst_from_immediate(&mut self, arg0: Immediate) -> Option<VCodeConstant>;
    fn u128_from_constant(&mut self, arg0: Constant) -> Option<u128>;
    fn u64_from_constant(&mut self, arg0: Constant) -> Option<u64>;
    fn shuffle64_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8)>;
    fn shuffle32_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8)>;
    fn shuffle16_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8, u8, u8, u8, u8)>;
    fn only_writable_reg(&mut self, arg0: WritableValueRegs) -> Option<WritableReg>;
    fn writable_regs_get(&mut self, arg0: WritableValueRegs, arg1: usize) -> WritableReg;
    fn abi_sig(&mut self, arg0: SigRef) -> Sig;
    fn abi_num_args(&mut self, arg0: Sig) -> usize;
    fn abi_get_arg(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_num_rets(&mut self, arg0: Sig) -> usize;
    fn abi_get_ret(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_ret_arg(&mut self, arg0: Sig) -> Option<ABIArg>;
    fn abi_no_ret_arg(&mut self, arg0: Sig) -> Option<()>;
    fn abi_unwrap_ret_area_ptr(&mut self, ) -> Reg;
    fn abi_stackslot_addr(&mut self, arg0: WritableReg, arg1: StackSlot, arg2: Offset32) -> MInst;
    fn abi_stackslot_offset_into_slot_region(&mut self, arg0: StackSlot, arg1: Offset32, arg2: Offset32) -> i32;
    fn abi_dynamic_stackslot_addr(&mut self, arg0: WritableReg, arg1: DynamicStackSlot) -> MInst;
    fn abi_arg_only_slot(&mut self, arg0: &ABIArg) -> Option<ABIArgSlot>;
    fn abi_arg_implicit_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, Type)>;
    fn real_reg_to_reg(&mut self, arg0: RealReg) -> Reg;
    fn real_reg_to_writable_reg(&mut self, arg0: RealReg) -> WritableReg;
    fn gen_move(&mut self, arg0: Type, arg1: WritableReg, arg2: Reg) -> MInst;
    fn gen_return(&mut self, arg0: &ValueRegsVec) -> Unit;
    fn gen_call_output(&mut self, arg0: SigRef) -> ValueRegsVec;
    fn gen_call_args(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallArgList;
    fn gen_return_call_args(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallArgList;
    fn gen_call_rets(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallRetList;
    fn gen_try_call_rets(&mut self, arg0: Sig) -> CallRetList;
    fn gen_patchable_call_rets(&mut self, ) -> CallRetList;
    fn try_call_info(&mut self, arg0: ExceptionTable, arg1: &MachLabelSlice) -> OptionTryCallInfo;
    fn try_call_none(&mut self, ) -> OptionTryCallInfo;
    fn safe_divisor_from_imm64(&mut self, arg0: Type, arg1: Imm64) -> Option<u64>;
    fn call_inst_dest_direct(&mut self, arg0: ExternalName) -> CallInstDest;
    fn call_inst_dest_indirect(&mut self, arg0: Reg) -> CallInstDest;
    fn box_symbol_reloc(&mut self, arg0: &SymbolReloc) -> BoxSymbolReloc;
    fn mie3_enabled(&mut self, arg0: Type) -> Option<()>;
    fn mie3_disabled(&mut self, arg0: Type) -> Option<()>;
    fn vxrs_ext2_enabled(&mut self, arg0: Type) -> Option<()>;
    fn vxrs_ext2_disabled(&mut self, arg0: Type) -> Option<()>;
    fn lane_order(&mut self, ) -> LaneOrder;
    fn be_lane_idx(&mut self, arg0: Type, arg1: u8) -> u8;
    fn be_vec_const(&mut self, arg0: Type, arg1: u128) -> u128;
    fn writable_gpr(&mut self, arg0: u8) -> WritableReg;
    fn zero_reg(&mut self, ) -> Reg;
    fn gpr32_ty(&mut self, arg0: Type) -> Option<Type>;
    fn gpr64_ty(&mut self, arg0: Type) -> Option<Type>;
    fn vr128_ty(&mut self, arg0: Type) -> Option<Type>;
    fn uimm32shifted(&mut self, arg0: u32, arg1: u8) -> UImm32Shifted;
    fn uimm16shifted(&mut self, arg0: u16, arg1: u8) -> UImm16Shifted;
    fn i64_nonequal(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn u64_pair_split(&mut self, arg0: u128) -> (u64, u64);
    fn u64_pair_concat(&mut self, arg0: u64, arg1: u64) -> u128;
    fn u32_pair_split(&mut self, arg0: u64) -> (u32, u32);
    fn u32_pair_concat(&mut self, arg0: u32, arg1: u32) -> u64;
    fn u16_pair_split(&mut self, arg0: u32) -> (u16, u16);
    fn u16_pair_concat(&mut self, arg0: u16, arg1: u16) -> u32;
    fn u8_pair_split(&mut self, arg0: u16) -> (u8, u8);
    fn u8_pair_concat(&mut self, arg0: u8, arg1: u8) -> u16;
    fn lane_byte_mask(&mut self, arg0: Type, arg1: u8) -> u16;
    fn shuffle_mask_from_u128(&mut self, arg0: u128) -> (u128, u16);
    fn u64_nonzero_hipart(&mut self, arg0: u64) -> Option<u64>;
    fn u64_nonzero_lopart(&mut self, arg0: u64) -> Option<u64>;
    fn uimm32shifted_from_u64(&mut self, arg0: u64) -> Option<UImm32Shifted>;
    fn uimm16shifted_from_u64(&mut self, arg0: u64) -> Option<UImm16Shifted>;
    fn u64_from_value(&mut self, arg0: Value) -> Option<u64>;
    fn u32_from_value(&mut self, arg0: Value) -> Option<u32>;
    fn u8_from_value(&mut self, arg0: Value) -> Option<u8>;
    fn u64_from_signed_value(&mut self, arg0: Value) -> Option<u64>;
    fn u64_from_inverted_value(&mut self, arg0: Value) -> Option<u64>;
    fn i64_from_value(&mut self, arg0: Value) -> Option<i64>;
    fn i32_from_value(&mut self, arg0: Value) -> Option<i32>;
    fn i16_from_value(&mut self, arg0: Value) -> Option<i16>;
    fn i16_from_swapped_value(&mut self, arg0: Value) -> Option<i16>;
    fn i64_from_negated_value(&mut self, arg0: Value) -> Option<i64>;
    fn i32_from_negated_value(&mut self, arg0: Value) -> Option<i32>;
    fn i16_from_negated_value(&mut self, arg0: Value) -> Option<i16>;
    fn uimm16shifted_from_value(&mut self, arg0: Value) -> Option<UImm16Shifted>;
    fn uimm32shifted_from_value(&mut self, arg0: Value) -> Option<UImm32Shifted>;
    fn uimm16shifted_from_inverted_value(&mut self, arg0: Value) -> Option<UImm16Shifted>;
    fn uimm32shifted_from_inverted_value(&mut self, arg0: Value) -> Option<UImm32Shifted>;
    fn len_minus_one(&mut self, arg0: u64) -> Option<u8>;
    fn mask_amt_imm(&mut self, arg0: Type, arg1: i64) -> u8;
    fn mask_as_cond(&mut self, arg0: u8) -> Cond;
    fn intcc_as_cond(&mut self, arg0: &IntCC) -> Cond;
    fn floatcc_as_cond(&mut self, arg0: &FloatCC) -> Cond;
    fn invert_cond(&mut self, arg0: &Cond) -> Cond;
    fn signed(&mut self, arg0: &IntCC) -> Option<()>;
    fn unsigned(&mut self, arg0: &IntCC) -> Option<()>;
    fn zero_offset(&mut self, ) -> Offset32;
    fn i64_from_offset(&mut self, arg0: Offset32) -> i64;
    fn littleendian(&mut self, arg0: MemFlags) -> Option<()>;
    fn bigendian(&mut self, arg0: MemFlags) -> Option<()>;
    fn memflags_trusted(&mut self, ) -> MemFlags;
    fn memarg_reg_plus_reg(&mut self, arg0: Reg, arg1: Reg, arg2: u8, arg3: MemFlags) -> MemArg;
    fn memarg_reg_plus_off(&mut self, arg0: Reg, arg1: i64, arg2: u8, arg3: MemFlags) -> MemArg;
    fn memarg_symbol(&mut self, arg0: ExternalName, arg1: i32, arg2: MemFlags) -> MemArg;
    fn memarg_got(&mut self, ) -> MemArg;
    fn memarg_const(&mut self, arg0: VCodeConstant) -> MemArg;
    fn memarg_symbol_offset_sum(&mut self, arg0: i64, arg1: i64) -> Option<i32>;
    fn memarg_frame_pointer_offset(&mut self, ) -> MemArg;
    fn memarg_return_address_offset(&mut self, ) -> MemArg;
    fn sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn writable_regpair(&mut self, arg0: WritableReg, arg1: WritableReg) -> WritableRegPair;
    fn writable_regpair_hi(&mut self, arg0: WritableRegPair) -> WritableReg;
    fn writable_regpair_lo(&mut self, arg0: WritableRegPair) -> WritableReg;
    fn regpair(&mut self, arg0: Reg, arg1: Reg) -> RegPair;
    fn regpair_hi(&mut self, arg0: RegPair) -> Reg;
    fn regpair_lo(&mut self, arg0: RegPair) -> Reg;
    fn inst_builder_new(&mut self, ) -> VecMInstBuilder;
    fn inst_builder_push(&mut self, arg0: &VecMInstBuilder, arg1: &MInst) -> Unit;
    fn inst_builder_finish(&mut self, arg0: &VecMInstBuilder) -> VecMInst;
    fn real_reg(&mut self, arg0: WritableReg) -> Option<WritableReg>;
    fn same_reg(&mut self, arg0: WritableReg, arg1: Reg) -> Option<Reg>;
    fn preg_stack(&mut self, ) -> PReg;
    fn preg_gpr_0(&mut self, ) -> PReg;
    fn gen_call_info(&mut self, arg0: Sig, arg1: CallInstDest, arg2: CallArgList, arg3: CallRetList, arg4: OptionTryCallInfo) -> BoxCallInfo;
    fn gen_return_call_info(&mut self, arg0: Sig, arg1: CallInstDest, arg2: CallArgList) -> BoxReturnCallInfo;
    fn abi_emit_call_adjust_stack(&mut self, arg0: Sig) -> Unit;
    fn abi_emit_return_call_adjust_stack(&mut self, arg0: Sig) -> Unit;
    fn abi_prepare_args(&mut self, arg0: Sig, arg1: ValueSlice) -> ValueRegsVec;
    fn fcvt_to_uint_ub32(&mut self, arg0: u8) -> u64;
    fn fcvt_to_uint_lb32(&mut self, ) -> u64;
    fn fcvt_to_uint_ub64(&mut self, arg0: u8) -> u64;
    fn fcvt_to_uint_lb64(&mut self, ) -> u64;
    fn fcvt_to_uint_ub128(&mut self, arg0: u8) -> u128;
    fn fcvt_to_uint_lb128(&mut self, ) -> u128;
    fn fcvt_to_sint_ub32(&mut self, arg0: u8) -> u64;
    fn fcvt_to_sint_lb32(&mut self, arg0: u8) -> u64;
    fn fcvt_to_sint_ub64(&mut self, arg0: u8) -> u64;
    fn fcvt_to_sint_lb64(&mut self, arg0: u8) -> u64;
    fn fcvt_to_sint_ub128(&mut self, arg0: u8) -> u128;
    fn fcvt_to_sint_lb128(&mut self, arg0: u8) -> u128;
    fn abi_for_elf_tls_get_offset(&mut self, ) -> Unit;
    fn i8_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_ne(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_checked_add(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_sub(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_mul(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_div(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_rem(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_rem(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_and(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_or(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_xor(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_not(&mut self, arg0: i8) -> i8;
    fn i8_checked_shl(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_checked_shr(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_is_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_non_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_non_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_odd(&mut self, arg0: i8) -> bool;
    fn i8_matches_odd(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_even(&mut self, arg0: i8) -> bool;
    fn i8_matches_even(&mut self, arg0: i8) -> Option<bool>;
    fn i8_checked_ilog2(&mut self, arg0: i8) -> Option<u32>;
    fn i8_ilog2(&mut self, arg0: i8) -> u32;
    fn i8_trailing_zeros(&mut self, arg0: i8) -> u32;
    fn i8_trailing_ones(&mut self, arg0: i8) -> u32;
    fn i8_leading_zeros(&mut self, arg0: i8) -> u32;
    fn i8_leading_ones(&mut self, arg0: i8) -> u32;
    fn i8_checked_neg(&mut self, arg0: i8) -> Option<i8>;
    fn i8_wrapping_neg(&mut self, arg0: i8) -> i8;
    fn i8_neg(&mut self, arg0: i8) -> i8;
    fn u8_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_ne(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_checked_add(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_sub(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_mul(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_div(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_rem(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_rem(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_or(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_xor(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_not(&mut self, arg0: u8) -> u8;
    fn u8_checked_shl(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_checked_shr(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_is_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_non_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_non_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_odd(&mut self, arg0: u8) -> bool;
    fn u8_matches_odd(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_even(&mut self, arg0: u8) -> bool;
    fn u8_matches_even(&mut self, arg0: u8) -> Option<bool>;
    fn u8_checked_ilog2(&mut self, arg0: u8) -> Option<u32>;
    fn u8_ilog2(&mut self, arg0: u8) -> u32;
    fn u8_trailing_zeros(&mut self, arg0: u8) -> u32;
    fn u8_trailing_ones(&mut self, arg0: u8) -> u32;
    fn u8_leading_zeros(&mut self, arg0: u8) -> u32;
    fn u8_leading_ones(&mut self, arg0: u8) -> u32;
    fn u8_is_power_of_two(&mut self, arg0: u8) -> bool;
    fn u8_matches_power_of_two(&mut self, arg0: u8) -> Option<bool>;
    fn i16_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_ne(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_checked_add(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_sub(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_mul(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_div(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_rem(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_rem(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_and(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_or(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_xor(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_not(&mut self, arg0: i16) -> i16;
    fn i16_checked_shl(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_checked_shr(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_is_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_non_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_non_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_odd(&mut self, arg0: i16) -> bool;
    fn i16_matches_odd(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_even(&mut self, arg0: i16) -> bool;
    fn i16_matches_even(&mut self, arg0: i16) -> Option<bool>;
    fn i16_checked_ilog2(&mut self, arg0: i16) -> Option<u32>;
    fn i16_ilog2(&mut self, arg0: i16) -> u32;
    fn i16_trailing_zeros(&mut self, arg0: i16) -> u32;
    fn i16_trailing_ones(&mut self, arg0: i16) -> u32;
    fn i16_leading_zeros(&mut self, arg0: i16) -> u32;
    fn i16_leading_ones(&mut self, arg0: i16) -> u32;
    fn i16_checked_neg(&mut self, arg0: i16) -> Option<i16>;
    fn i16_wrapping_neg(&mut self, arg0: i16) -> i16;
    fn i16_neg(&mut self, arg0: i16) -> i16;
    fn u16_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_ne(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_checked_add(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_sub(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_mul(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_div(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_rem(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_rem(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_and(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_or(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_xor(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_not(&mut self, arg0: u16) -> u16;
    fn u16_checked_shl(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_checked_shr(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_is_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_non_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_non_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_odd(&mut self, arg0: u16) -> bool;
    fn u16_matches_odd(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_even(&mut self, arg0: u16) -> bool;
    fn u16_matches_even(&mut self, arg0: u16) -> Option<bool>;
    fn u16_checked_ilog2(&mut self, arg0: u16) -> Option<u32>;
    fn u16_ilog2(&mut self, arg0: u16) -> u32;
    fn u16_trailing_zeros(&mut self, arg0: u16) -> u32;
    fn u16_trailing_ones(&mut self, arg0: u16) -> u32;
    fn u16_leading_zeros(&mut self, arg0: u16) -> u32;
    fn u16_leading_ones(&mut self, arg0: u16) -> u32;
    fn u16_is_power_of_two(&mut self, arg0: u16) -> bool;
    fn u16_matches_power_of_two(&mut self, arg0: u16) -> Option<bool>;
    fn i32_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_ne(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_checked_add(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_sub(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_mul(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_div(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_rem(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_rem(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_and(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_or(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_xor(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_not(&mut self, arg0: i32) -> i32;
    fn i32_checked_shl(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_checked_shr(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_is_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_non_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_non_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_odd(&mut self, arg0: i32) -> bool;
    fn i32_matches_odd(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_even(&mut self, arg0: i32) -> bool;
    fn i32_matches_even(&mut self, arg0: i32) -> Option<bool>;
    fn i32_checked_ilog2(&mut self, arg0: i32) -> Option<u32>;
    fn i32_ilog2(&mut self, arg0: i32) -> u32;
    fn i32_trailing_zeros(&mut self, arg0: i32) -> u32;
    fn i32_trailing_ones(&mut self, arg0: i32) -> u32;
    fn i32_leading_zeros(&mut self, arg0: i32) -> u32;
    fn i32_leading_ones(&mut self, arg0: i32) -> u32;
    fn i32_checked_neg(&mut self, arg0: i32) -> Option<i32>;
    fn i32_wrapping_neg(&mut self, arg0: i32) -> i32;
    fn i32_neg(&mut self, arg0: i32) -> i32;
    fn u32_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_ne(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_checked_add(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_sub(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_mul(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_div(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_rem(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_rem(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_or(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_xor(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_not(&mut self, arg0: u32) -> u32;
    fn u32_checked_shl(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_shr(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_is_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_non_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_non_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_odd(&mut self, arg0: u32) -> bool;
    fn u32_matches_odd(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_even(&mut self, arg0: u32) -> bool;
    fn u32_matches_even(&mut self, arg0: u32) -> Option<bool>;
    fn u32_checked_ilog2(&mut self, arg0: u32) -> Option<u32>;
    fn u32_ilog2(&mut self, arg0: u32) -> u32;
    fn u32_trailing_zeros(&mut self, arg0: u32) -> u32;
    fn u32_trailing_ones(&mut self, arg0: u32) -> u32;
    fn u32_leading_zeros(&mut self, arg0: u32) -> u32;
    fn u32_leading_ones(&mut self, arg0: u32) -> u32;
    fn u32_is_power_of_two(&mut self, arg0: u32) -> bool;
    fn u32_matches_power_of_two(&mut self, arg0: u32) -> Option<bool>;
    fn i64_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_ne(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_checked_add(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_sub(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_mul(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_div(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_rem(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_rem(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_and(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_or(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_xor(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_not(&mut self, arg0: i64) -> i64;
    fn i64_checked_shl(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_checked_shr(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_is_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_non_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_non_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_odd(&mut self, arg0: i64) -> bool;
    fn i64_matches_odd(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_even(&mut self, arg0: i64) -> bool;
    fn i64_matches_even(&mut self, arg0: i64) -> Option<bool>;
    fn i64_checked_ilog2(&mut self, arg0: i64) -> Option<u32>;
    fn i64_ilog2(&mut self, arg0: i64) -> u32;
    fn i64_trailing_zeros(&mut self, arg0: i64) -> u32;
    fn i64_trailing_ones(&mut self, arg0: i64) -> u32;
    fn i64_leading_zeros(&mut self, arg0: i64) -> u32;
    fn i64_leading_ones(&mut self, arg0: i64) -> u32;
    fn i64_checked_neg(&mut self, arg0: i64) -> Option<i64>;
    fn i64_wrapping_neg(&mut self, arg0: i64) -> i64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_ne(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_checked_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_mul(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_div(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_rem(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_rem(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_checked_shl(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_checked_shr(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_non_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_non_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn u64_matches_odd(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_even(&mut self, arg0: u64) -> bool;
    fn u64_matches_even(&mut self, arg0: u64) -> Option<bool>;
    fn u64_checked_ilog2(&mut self, arg0: u64) -> Option<u32>;
    fn u64_ilog2(&mut self, arg0: u64) -> u32;
    fn u64_trailing_zeros(&mut self, arg0: u64) -> u32;
    fn u64_trailing_ones(&mut self, arg0: u64) -> u32;
    fn u64_leading_zeros(&mut self, arg0: u64) -> u32;
    fn u64_leading_ones(&mut self, arg0: u64) -> u32;
    fn u64_is_power_of_two(&mut self, arg0: u64) -> bool;
    fn u64_matches_power_of_two(&mut self, arg0: u64) -> Option<bool>;
    fn i128_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_ne(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_checked_add(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_sub(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_mul(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_div(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_rem(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_rem(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_and(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_or(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_xor(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_not(&mut self, arg0: i128) -> i128;
    fn i128_checked_shl(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_checked_shr(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_is_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_non_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_non_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_odd(&mut self, arg0: i128) -> bool;
    fn i128_matches_odd(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_even(&mut self, arg0: i128) -> bool;
    fn i128_matches_even(&mut self, arg0: i128) -> Option<bool>;
    fn i128_checked_ilog2(&mut self, arg0: i128) -> Option<u32>;
    fn i128_ilog2(&mut self, arg0: i128) -> u32;
    fn i128_trailing_zeros(&mut self, arg0: i128) -> u32;
    fn i128_trailing_ones(&mut self, arg0: i128) -> u32;
    fn i128_leading_zeros(&mut self, arg0: i128) -> u32;
    fn i128_leading_ones(&mut self, arg0: i128) -> u32;
    fn i128_checked_neg(&mut self, arg0: i128) -> Option<i128>;
    fn i128_wrapping_neg(&mut self, arg0: i128) -> i128;
    fn i128_neg(&mut self, arg0: i128) -> i128;
    fn u128_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_ne(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_checked_add(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_sub(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_mul(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_div(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_rem(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_rem(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_and(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_or(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_xor(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_not(&mut self, arg0: u128) -> u128;
    fn u128_checked_shl(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_checked_shr(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_is_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_non_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_non_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_odd(&mut self, arg0: u128) -> bool;
    fn u128_matches_odd(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_even(&mut self, arg0: u128) -> bool;
    fn u128_matches_even(&mut self, arg0: u128) -> Option<bool>;
    fn u128_checked_ilog2(&mut self, arg0: u128) -> Option<u32>;
    fn u128_ilog2(&mut self, arg0: u128) -> u32;
    fn u128_trailing_zeros(&mut self, arg0: u128) -> u32;
    fn u128_trailing_ones(&mut self, arg0: u128) -> u32;
    fn u128_leading_zeros(&mut self, arg0: u128) -> u32;
    fn u128_leading_ones(&mut self, arg0: u128) -> u32;
    fn u128_is_power_of_two(&mut self, arg0: u128) -> bool;
    fn u128_matches_power_of_two(&mut self, arg0: u128) -> Option<bool>;
    fn i8_try_into_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_unwrap_into_u8(&mut self, arg0: i8) -> u8;
    fn i8_cast_unsigned(&mut self, arg0: i8) -> u8;
    fn i8_from_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_into_i16(&mut self, arg0: i8) -> i16;
    fn i8_from_i16(&mut self, arg0: i8) -> Option<i16>;
    fn i8_try_into_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_unwrap_into_u16(&mut self, arg0: i8) -> u16;
    fn i8_from_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_into_i32(&mut self, arg0: i8) -> i32;
    fn i8_from_i32(&mut self, arg0: i8) -> Option<i32>;
    fn i8_try_into_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_unwrap_into_u32(&mut self, arg0: i8) -> u32;
    fn i8_from_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_into_i64(&mut self, arg0: i8) -> i64;
    fn i8_from_i64(&mut self, arg0: i8) -> Option<i64>;
    fn i8_try_into_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_unwrap_into_u64(&mut self, arg0: i8) -> u64;
    fn i8_from_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_into_i128(&mut self, arg0: i8) -> i128;
    fn i8_from_i128(&mut self, arg0: i8) -> Option<i128>;
    fn i8_try_into_u128(&mut self, arg0: i8) -> Option<u128>;
    fn i8_unwrap_into_u128(&mut self, arg0: i8) -> u128;
    fn i8_from_u128(&mut self, arg0: i8) -> Option<u128>;
    fn u8_try_into_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_unwrap_into_i8(&mut self, arg0: u8) -> i8;
    fn u8_cast_signed(&mut self, arg0: u8) -> i8;
    fn u8_from_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_into_i16(&mut self, arg0: u8) -> i16;
    fn u8_from_i16(&mut self, arg0: u8) -> Option<i16>;
    fn u8_into_u16(&mut self, arg0: u8) -> u16;
    fn u8_from_u16(&mut self, arg0: u8) -> Option<u16>;
    fn u8_into_i32(&mut self, arg0: u8) -> i32;
    fn u8_from_i32(&mut self, arg0: u8) -> Option<i32>;
    fn u8_into_u32(&mut self, arg0: u8) -> u32;
    fn u8_from_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_into_i64(&mut self, arg0: u8) -> i64;
    fn u8_from_i64(&mut self, arg0: u8) -> Option<i64>;
    fn u8_into_u64(&mut self, arg0: u8) -> u64;
    fn u8_from_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u8_into_i128(&mut self, arg0: u8) -> i128;
    fn u8_from_i128(&mut self, arg0: u8) -> Option<i128>;
    fn u8_into_u128(&mut self, arg0: u8) -> u128;
    fn u8_from_u128(&mut self, arg0: u8) -> Option<u128>;
    fn i16_try_into_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_unwrap_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_truncate_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_from_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_try_into_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_unwrap_into_u8(&mut self, arg0: i16) -> u8;
    fn i16_from_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_try_into_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_unwrap_into_u16(&mut self, arg0: i16) -> u16;
    fn i16_cast_unsigned(&mut self, arg0: i16) -> u16;
    fn i16_from_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_into_i32(&mut self, arg0: i16) -> i32;
    fn i16_from_i32(&mut self, arg0: i16) -> Option<i32>;
    fn i16_try_into_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_unwrap_into_u32(&mut self, arg0: i16) -> u32;
    fn i16_from_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_into_i64(&mut self, arg0: i16) -> i64;
    fn i16_from_i64(&mut self, arg0: i16) -> Option<i64>;
    fn i16_try_into_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_unwrap_into_u64(&mut self, arg0: i16) -> u64;
    fn i16_from_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_into_i128(&mut self, arg0: i16) -> i128;
    fn i16_from_i128(&mut self, arg0: i16) -> Option<i128>;
    fn i16_try_into_u128(&mut self, arg0: i16) -> Option<u128>;
    fn i16_unwrap_into_u128(&mut self, arg0: i16) -> u128;
    fn i16_from_u128(&mut self, arg0: i16) -> Option<u128>;
    fn u16_try_into_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_unwrap_into_i8(&mut self, arg0: u16) -> i8;
    fn u16_from_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_try_into_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_unwrap_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_truncate_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_from_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_try_into_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_unwrap_into_i16(&mut self, arg0: u16) -> i16;
    fn u16_cast_signed(&mut self, arg0: u16) -> i16;
    fn u16_from_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_into_i32(&mut self, arg0: u16) -> i32;
    fn u16_from_i32(&mut self, arg0: u16) -> Option<i32>;
    fn u16_into_u32(&mut self, arg0: u16) -> u32;
    fn u16_from_u32(&mut self, arg0: u16) -> Option<u32>;
    fn u16_into_i64(&mut self, arg0: u16) -> i64;
    fn u16_from_i64(&mut self, arg0: u16) -> Option<i64>;
    fn u16_into_u64(&mut self, arg0: u16) -> u64;
    fn u16_from_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u16_into_i128(&mut self, arg0: u16) -> i128;
    fn u16_from_i128(&mut self, arg0: u16) -> Option<i128>;
    fn u16_into_u128(&mut self, arg0: u16) -> u128;
    fn u16_from_u128(&mut self, arg0: u16) -> Option<u128>;
    fn i32_try_into_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_unwrap_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_truncate_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_from_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_try_into_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_unwrap_into_u8(&mut self, arg0: i32) -> u8;
    fn i32_from_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_try_into_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_unwrap_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_truncate_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_from_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_try_into_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_unwrap_into_u16(&mut self, arg0: i32) -> u16;
    fn i32_from_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_try_into_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_unwrap_into_u32(&mut self, arg0: i32) -> u32;
    fn i32_cast_unsigned(&mut self, arg0: i32) -> u32;
    fn i32_from_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_into_i64(&mut self, arg0: i32) -> i64;
    fn i32_from_i64(&mut self, arg0: i32) -> Option<i64>;
    fn i32_try_into_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_unwrap_into_u64(&mut self, arg0: i32) -> u64;
    fn i32_from_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_into_i128(&mut self, arg0: i32) -> i128;
    fn i32_from_i128(&mut self, arg0: i32) -> Option<i128>;
    fn i32_try_into_u128(&mut self, arg0: i32) -> Option<u128>;
    fn i32_unwrap_into_u128(&mut self, arg0: i32) -> u128;
    fn i32_from_u128(&mut self, arg0: i32) -> Option<u128>;
    fn u32_try_into_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_unwrap_into_i8(&mut self, arg0: u32) -> i8;
    fn u32_from_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_try_into_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_unwrap_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_truncate_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_from_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_try_into_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_unwrap_into_i16(&mut self, arg0: u32) -> i16;
    fn u32_from_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_try_into_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_unwrap_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_truncate_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_from_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_try_into_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_unwrap_into_i32(&mut self, arg0: u32) -> i32;
    fn u32_cast_signed(&mut self, arg0: u32) -> i32;
    fn u32_from_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_into_i64(&mut self, arg0: u32) -> i64;
    fn u32_from_i64(&mut self, arg0: u32) -> Option<i64>;
    fn u32_into_u64(&mut self, arg0: u32) -> u64;
    fn u32_from_u64(&mut self, arg0: u32) -> Option<u64>;
    fn u32_into_i128(&mut self, arg0: u32) -> i128;
    fn u32_from_i128(&mut self, arg0: u32) -> Option<i128>;
    fn u32_into_u128(&mut self, arg0: u32) -> u128;
    fn u32_from_u128(&mut self, arg0: u32) -> Option<u128>;
    fn i64_try_into_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_unwrap_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_truncate_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_from_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_try_into_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_unwrap_into_u8(&mut self, arg0: i64) -> u8;
    fn i64_from_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_try_into_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_unwrap_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_truncate_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_from_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_try_into_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_unwrap_into_u16(&mut self, arg0: i64) -> u16;
    fn i64_from_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_try_into_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_unwrap_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_truncate_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_from_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_try_into_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_unwrap_into_u32(&mut self, arg0: i64) -> u32;
    fn i64_from_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_try_into_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_unwrap_into_u64(&mut self, arg0: i64) -> u64;
    fn i64_cast_unsigned(&mut self, arg0: i64) -> u64;
    fn i64_from_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_into_i128(&mut self, arg0: i64) -> i128;
    fn i64_from_i128(&mut self, arg0: i64) -> Option<i128>;
    fn i64_try_into_u128(&mut self, arg0: i64) -> Option<u128>;
    fn i64_unwrap_into_u128(&mut self, arg0: i64) -> u128;
    fn i64_from_u128(&mut self, arg0: i64) -> Option<u128>;
    fn u64_try_into_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_unwrap_into_i8(&mut self, arg0: u64) -> i8;
    fn u64_from_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_try_into_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_unwrap_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_truncate_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_from_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_try_into_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_unwrap_into_i16(&mut self, arg0: u64) -> i16;
    fn u64_from_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_try_into_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_unwrap_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_truncate_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_from_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_try_into_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_unwrap_into_i32(&mut self, arg0: u64) -> i32;
    fn u64_from_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_try_into_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_unwrap_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_truncate_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_from_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_try_into_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_unwrap_into_i64(&mut self, arg0: u64) -> i64;
    fn u64_cast_signed(&mut self, arg0: u64) -> i64;
    fn u64_from_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_into_i128(&mut self, arg0: u64) -> i128;
    fn u64_from_i128(&mut self, arg0: u64) -> Option<i128>;
    fn u64_into_u128(&mut self, arg0: u64) -> u128;
    fn u64_from_u128(&mut self, arg0: u64) -> Option<u128>;
    fn i128_try_into_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_unwrap_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_truncate_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_from_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_try_into_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_unwrap_into_u8(&mut self, arg0: i128) -> u8;
    fn i128_from_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_try_into_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_unwrap_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_truncate_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_from_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_try_into_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_unwrap_into_u16(&mut self, arg0: i128) -> u16;
    fn i128_from_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_try_into_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_unwrap_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_truncate_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_from_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_try_into_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_unwrap_into_u32(&mut self, arg0: i128) -> u32;
    fn i128_from_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_try_into_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_unwrap_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_truncate_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_from_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_try_into_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_unwrap_into_u64(&mut self, arg0: i128) -> u64;
    fn i128_from_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_try_into_u128(&mut self, arg0: i128) -> Option<u128>;
    fn i128_unwrap_into_u128(&mut self, arg0: i128) -> u128;
    fn i128_cast_unsigned(&mut self, arg0: i128) -> u128;
    fn i128_from_u128(&mut self, arg0: i128) -> Option<u128>;
    fn u128_try_into_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_unwrap_into_i8(&mut self, arg0: u128) -> i8;
    fn u128_from_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_try_into_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_unwrap_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_truncate_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_from_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_try_into_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_unwrap_into_i16(&mut self, arg0: u128) -> i16;
    fn u128_from_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_try_into_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_unwrap_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_truncate_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_from_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_try_into_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_unwrap_into_i32(&mut self, arg0: u128) -> i32;
    fn u128_from_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_try_into_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_unwrap_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_truncate_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_from_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_try_into_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_unwrap_into_i64(&mut self, arg0: u128) -> i64;
    fn u128_from_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_try_into_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_unwrap_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_truncate_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_from_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_try_into_i128(&mut self, arg0: u128) -> Option<i128>;
    fn u128_unwrap_into_i128(&mut self, arg0: u128) -> i128;
    fn u128_cast_signed(&mut self, arg0: u128) -> i128;
    fn u128_from_i128(&mut self, arg0: u128) -> Option<i128>;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
}

pub trait IntoContextIter {
    type Context;
    type Output;
    type IntoIter: ContextIter<Context = Self::Context, Output = Self::Output>;
    fn into_context_iter(self) -> Self::IntoIter;
}

pub trait Length {
    fn len(&self) -> usize;
}

impl<T> Length for std::vec::Vec<T> {
    fn len(&self) -> usize {
        std::vec::Vec::len(self)
    }
}

pub struct ContextIterWrapper<I, C> {
    iter: I,
    _ctx: std::marker::PhantomData<C>,
}
impl<I: Default, C> Default for ContextIterWrapper<I, C> {
    fn default() -> Self {
        ContextIterWrapper {
            iter: I::default(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<I, C> std::ops::Deref for ContextIterWrapper<I, C> {
    type Target = I;
    fn deref(&self) -> &I {
        &self.iter
    }
}
impl<I, C> std::ops::DerefMut for ContextIterWrapper<I, C> {
    fn deref_mut(&mut self) -> &mut I {
        &mut self.iter
    }
}
impl<I: Iterator, C: Context> From<I> for ContextIterWrapper<I, C> {
    fn from(iter: I) -> Self {
        Self { iter, _ctx: std::marker::PhantomData }
    }
}
impl<I: Iterator, C: Context> ContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}
impl<I: IntoIterator, C: Context> IntoContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    type IntoIter = ContextIterWrapper<I::IntoIter, C>;
    fn into_context_iter(self) -> Self::IntoIter {
        ContextIterWrapper {
            iter: self.iter.into_iter(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<T, E: Extend<T>, C> Extend<T> for ContextIterWrapper<E, C> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        self.iter.extend(iter);
    }
}
impl<L: Length, C> Length for ContextIterWrapper<L, C> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}
           

/// Internal type MultiReg: defined at src\prelude_lower.isle line 16.
#[derive(Clone, Debug)]
pub enum MultiReg {
    Empty,
    One {
        a: Reg,
    },
    Two {
        a: Reg,
        b: Reg,
    },
    Three {
        a: Reg,
        b: Reg,
        c: Reg,
    },
    Four {
        a: Reg,
        b: Reg,
        c: Reg,
        d: Reg,
    },
}

/// Internal type SideEffectNoResult: defined at src\prelude_lower.isle line 439.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst {
        inst: MInst,
    },
    Inst2 {
        inst1: MInst,
        inst2: MInst,
    },
    Inst3 {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
    },
}

/// Internal type ProducesFlags: defined at src\prelude_lower.isle line 492.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    AlreadyExistingFlags,
    ProducesFlagsSideEffect {
        inst: MInst,
    },
    ProducesFlagsTwiceSideEffect {
        inst1: MInst,
        inst2: MInst,
    },
    ProducesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ProducesFlagsReturnsResultWithConsumer {
        inst: MInst,
        result: Reg,
    },
}

/// Internal type ConsumesAndProducesFlags: defined at src\prelude_lower.isle line 511.
#[derive(Clone, Debug)]
pub enum ConsumesAndProducesFlags {
    SideEffect {
        inst: MInst,
    },
    ReturnsReg {
        inst: MInst,
        result: Reg,
    },
}

/// Internal type ConsumesFlags: defined at src\prelude_lower.isle line 519.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsSideEffect {
        inst: MInst,
    },
    ConsumesFlagsSideEffect2 {
        inst1: MInst,
        inst2: MInst,
    },
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src\isa\s390x\inst.isle line 1.
#[derive(Clone, Debug)]
pub enum MInst {
    Nop0,
    Nop2,
    AluRRR {
        alu_op: ALUOp,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    AluRRSImm16 {
        alu_op: ALUOp,
        rd: WritableReg,
        rn: Reg,
        imm: i16,
    },
    AluRR {
        alu_op: ALUOp,
        rd: WritableReg,
        ri: Reg,
        rm: Reg,
    },
    AluRX {
        alu_op: ALUOp,
        rd: WritableReg,
        ri: Reg,
        mem: MemArg,
    },
    AluRSImm16 {
        alu_op: ALUOp,
        rd: WritableReg,
        ri: Reg,
        imm: i16,
    },
    AluRSImm32 {
        alu_op: ALUOp,
        rd: WritableReg,
        ri: Reg,
        imm: i32,
    },
    AluRUImm32 {
        alu_op: ALUOp,
        rd: WritableReg,
        ri: Reg,
        imm: u32,
    },
    AluRUImm16Shifted {
        alu_op: ALUOp,
        rd: WritableReg,
        ri: Reg,
        imm: UImm16Shifted,
    },
    AluRUImm32Shifted {
        alu_op: ALUOp,
        rd: WritableReg,
        ri: Reg,
        imm: UImm32Shifted,
    },
    SMulWide {
        rd: WritableRegPair,
        rn: Reg,
        rm: Reg,
    },
    UMulWide {
        rd: WritableRegPair,
        ri: Reg,
        rn: Reg,
    },
    SDivMod32 {
        rd: WritableRegPair,
        ri: Reg,
        rn: Reg,
    },
    SDivMod64 {
        rd: WritableRegPair,
        ri: Reg,
        rn: Reg,
    },
    UDivMod32 {
        rd: WritableRegPair,
        ri: RegPair,
        rn: Reg,
    },
    UDivMod64 {
        rd: WritableRegPair,
        ri: RegPair,
        rn: Reg,
    },
    Flogr {
        rd: WritableRegPair,
        rn: Reg,
    },
    ShiftRR {
        shift_op: ShiftOp,
        rd: WritableReg,
        rn: Reg,
        shift_imm: u8,
        shift_reg: Reg,
    },
    RxSBG {
        op: RxSBGOp,
        rd: WritableReg,
        ri: Reg,
        rn: Reg,
        start_bit: u8,
        end_bit: u8,
        rotate_amt: i8,
    },
    RxSBGTest {
        op: RxSBGOp,
        rd: Reg,
        rn: Reg,
        start_bit: u8,
        end_bit: u8,
        rotate_amt: i8,
    },
    UnaryRR {
        op: UnaryOp,
        rd: WritableReg,
        rn: Reg,
    },
    CmpRR {
        op: CmpOp,
        rn: Reg,
        rm: Reg,
    },
    CmpRX {
        op: CmpOp,
        rn: Reg,
        mem: MemArg,
    },
    CmpRSImm16 {
        op: CmpOp,
        rn: Reg,
        imm: i16,
    },
    CmpRSImm32 {
        op: CmpOp,
        rn: Reg,
        imm: i32,
    },
    CmpRUImm32 {
        op: CmpOp,
        rn: Reg,
        imm: u32,
    },
    CmpTrapRR {
        op: CmpOp,
        rn: Reg,
        rm: Reg,
        cond: Cond,
        trap_code: TrapCode,
    },
    CmpTrapRSImm16 {
        op: CmpOp,
        rn: Reg,
        imm: i16,
        cond: Cond,
        trap_code: TrapCode,
    },
    CmpTrapRUImm16 {
        op: CmpOp,
        rn: Reg,
        imm: u16,
        cond: Cond,
        trap_code: TrapCode,
    },
    AtomicRmw {
        alu_op: ALUOp,
        rd: WritableReg,
        rn: Reg,
        mem: MemArg,
    },
    AtomicCas32 {
        rd: WritableReg,
        ri: Reg,
        rn: Reg,
        mem: MemArg,
    },
    AtomicCas64 {
        rd: WritableReg,
        ri: Reg,
        rn: Reg,
        mem: MemArg,
    },
    Fence,
    Load32 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load32ZExt8 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load32SExt8 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load32ZExt16 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load32SExt16 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load64 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load64ZExt8 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load64SExt8 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load64ZExt16 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load64SExt16 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load64ZExt32 {
        rd: WritableReg,
        mem: MemArg,
    },
    Load64SExt32 {
        rd: WritableReg,
        mem: MemArg,
    },
    LoadRev16 {
        rd: WritableReg,
        mem: MemArg,
    },
    LoadRev32 {
        rd: WritableReg,
        mem: MemArg,
    },
    LoadRev64 {
        rd: WritableReg,
        mem: MemArg,
    },
    Store8 {
        rd: Reg,
        mem: MemArg,
    },
    Store16 {
        rd: Reg,
        mem: MemArg,
    },
    Store32 {
        rd: Reg,
        mem: MemArg,
    },
    Store64 {
        rd: Reg,
        mem: MemArg,
    },
    StoreImm8 {
        imm: u8,
        mem: MemArg,
    },
    StoreImm16 {
        imm: i16,
        mem: MemArg,
    },
    StoreImm32SExt16 {
        imm: i16,
        mem: MemArg,
    },
    StoreImm64SExt16 {
        imm: i16,
        mem: MemArg,
    },
    StoreRev16 {
        rd: Reg,
        mem: MemArg,
    },
    StoreRev32 {
        rd: Reg,
        mem: MemArg,
    },
    StoreRev64 {
        rd: Reg,
        mem: MemArg,
    },
    LoadMultiple64 {
        rt: WritableReg,
        rt2: WritableReg,
        mem: MemArg,
    },
    StoreMultiple64 {
        rt: Reg,
        rt2: Reg,
        mem: MemArg,
    },
    Mov32 {
        rd: WritableReg,
        rm: Reg,
    },
    Mov64 {
        rd: WritableReg,
        rm: Reg,
    },
    MovPReg {
        rd: WritableReg,
        rm: PReg,
    },
    Mov32Imm {
        rd: WritableReg,
        imm: u32,
    },
    Mov32SImm16 {
        rd: WritableReg,
        imm: i16,
    },
    Mov64SImm16 {
        rd: WritableReg,
        imm: i16,
    },
    Mov64SImm32 {
        rd: WritableReg,
        imm: i32,
    },
    Mov64UImm16Shifted {
        rd: WritableReg,
        imm: UImm16Shifted,
    },
    Mov64UImm32Shifted {
        rd: WritableReg,
        imm: UImm32Shifted,
    },
    Insert64UImm16Shifted {
        rd: WritableReg,
        ri: Reg,
        imm: UImm16Shifted,
    },
    Insert64UImm32Shifted {
        rd: WritableReg,
        ri: Reg,
        imm: UImm32Shifted,
    },
    LoadAR {
        rd: WritableReg,
        ar: u8,
    },
    InsertAR {
        rd: WritableReg,
        ri: Reg,
        ar: u8,
    },
    Extend {
        rd: WritableReg,
        rn: Reg,
        signed: bool,
        from_bits: u8,
        to_bits: u8,
    },
    CMov32 {
        rd: WritableReg,
        cond: Cond,
        ri: Reg,
        rm: Reg,
    },
    CMov64 {
        rd: WritableReg,
        cond: Cond,
        ri: Reg,
        rm: Reg,
    },
    CMov32SImm16 {
        rd: WritableReg,
        cond: Cond,
        ri: Reg,
        imm: i16,
    },
    CMov64SImm16 {
        rd: WritableReg,
        cond: Cond,
        ri: Reg,
        imm: i16,
    },
    FpuMove32 {
        rd: WritableReg,
        rn: Reg,
    },
    FpuMove64 {
        rd: WritableReg,
        rn: Reg,
    },
    FpuCMov32 {
        rd: WritableReg,
        cond: Cond,
        ri: Reg,
        rm: Reg,
    },
    FpuCMov64 {
        rd: WritableReg,
        cond: Cond,
        ri: Reg,
        rm: Reg,
    },
    FpuRR {
        fpu_op: FPUOp1,
        rd: WritableReg,
        rn: Reg,
    },
    FpuRRR {
        fpu_op: FPUOp2,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    FpuRRRR {
        fpu_op: FPUOp3,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
        ra: Reg,
    },
    FpuRound {
        op: FpuRoundOp,
        mode: FpuRoundMode,
        rd: WritableReg,
        rn: Reg,
    },
    FpuCmp32 {
        rn: Reg,
        rm: Reg,
    },
    FpuCmp64 {
        rn: Reg,
        rm: Reg,
    },
    FpuCmp128 {
        rn: Reg,
        rm: Reg,
    },
    FpuConv128FromInt {
        op: FpuConv128Op,
        mode: FpuRoundMode,
        rd: WritableRegPair,
        rn: Reg,
    },
    FpuConv128ToInt {
        op: FpuConv128Op,
        mode: FpuRoundMode,
        rd: WritableReg,
        rn: RegPair,
    },
    VecRRR {
        op: VecBinaryOp,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecRR {
        op: VecUnaryOp,
        rd: WritableReg,
        rn: Reg,
    },
    VecShiftRR {
        shift_op: VecShiftOp,
        rd: WritableReg,
        rn: Reg,
        shift_imm: u8,
        shift_reg: Reg,
    },
    VecSelect {
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
        ra: Reg,
    },
    VecPermute {
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
        ra: Reg,
    },
    VecPermuteDWImm {
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
        idx1: u8,
        idx2: u8,
    },
    VecIntCmp {
        op: VecIntCmpOp,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecIntCmpS {
        op: VecIntCmpOp,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecFloatCmp {
        op: VecFloatCmpOp,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecFloatCmpS {
        op: VecFloatCmpOp,
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecInt128SCmpHi {
        tmp: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecInt128UCmpHi {
        tmp: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecLoad {
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadRev {
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadByte16Rev {
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadByte32Rev {
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadByte64Rev {
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadElt16Rev {
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadElt32Rev {
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadElt64Rev {
        rd: WritableReg,
        mem: MemArg,
    },
    VecStore {
        rd: Reg,
        mem: MemArg,
    },
    VecStoreRev {
        rd: Reg,
        mem: MemArg,
    },
    VecStoreByte16Rev {
        rd: Reg,
        mem: MemArg,
    },
    VecStoreByte32Rev {
        rd: Reg,
        mem: MemArg,
    },
    VecStoreByte64Rev {
        rd: Reg,
        mem: MemArg,
    },
    VecStoreElt16Rev {
        rd: Reg,
        mem: MemArg,
    },
    VecStoreElt32Rev {
        rd: Reg,
        mem: MemArg,
    },
    VecStoreElt64Rev {
        rd: Reg,
        mem: MemArg,
    },
    VecLoadReplicate {
        size: u32,
        rd: WritableReg,
        mem: MemArg,
    },
    VecLoadReplicateRev {
        size: u32,
        rd: WritableReg,
        mem: MemArg,
    },
    VecMov {
        rd: WritableReg,
        rn: Reg,
    },
    VecCMov {
        rd: WritableReg,
        cond: Cond,
        ri: Reg,
        rm: Reg,
    },
    MovToVec128 {
        rd: WritableReg,
        rn: Reg,
        rm: Reg,
    },
    VecImmByteMask {
        rd: WritableReg,
        mask: u16,
    },
    VecImmBitMask {
        size: u32,
        rd: WritableReg,
        start_bit: u8,
        end_bit: u8,
    },
    VecImmReplicate {
        size: u32,
        rd: WritableReg,
        imm: i16,
    },
    VecLoadLane {
        size: u32,
        rd: WritableReg,
        ri: Reg,
        mem: MemArg,
        lane_imm: u8,
    },
    VecLoadLaneUndef {
        size: u32,
        rd: WritableReg,
        mem: MemArg,
        lane_imm: u8,
    },
    VecLoadLaneRev {
        size: u32,
        rd: WritableReg,
        ri: Reg,
        mem: MemArg,
        lane_imm: u8,
    },
    VecLoadLaneRevUndef {
        size: u32,
        rd: WritableReg,
        mem: MemArg,
        lane_imm: u8,
    },
    VecStoreLane {
        size: u32,
        rd: Reg,
        mem: MemArg,
        lane_imm: u8,
    },
    VecStoreLaneRev {
        size: u32,
        rd: Reg,
        mem: MemArg,
        lane_imm: u8,
    },
    VecInsertLane {
        size: u32,
        rd: WritableReg,
        ri: Reg,
        rn: Reg,
        lane_imm: u8,
        lane_reg: Reg,
    },
    VecInsertLaneUndef {
        size: u32,
        rd: WritableReg,
        rn: Reg,
        lane_imm: u8,
        lane_reg: Reg,
    },
    VecExtractLane {
        size: u32,
        rd: WritableReg,
        rn: Reg,
        lane_imm: u8,
        lane_reg: Reg,
    },
    VecInsertLaneImm {
        size: u32,
        rd: WritableReg,
        ri: Reg,
        imm: i16,
        lane_imm: u8,
    },
    VecInsertLaneImmUndef {
        size: u32,
        rd: WritableReg,
        imm: i16,
        lane_imm: u8,
    },
    VecReplicateLane {
        size: u32,
        rd: WritableReg,
        rn: Reg,
        lane_imm: u8,
    },
    VecEltRev {
        lane_count: u32,
        rd: WritableReg,
        rn: Reg,
    },
    AllocateArgs {
        size: u32,
    },
    Call {
        link: WritableReg,
        info: BoxCallInfo,
    },
    PatchableCall {
        link: WritableReg,
        info: BoxCallInfo,
    },
    ReturnCall {
        info: BoxReturnCallInfo,
    },
    Args {
        args: VecArgPair,
    },
    Rets {
        rets: VecRetPair,
    },
    Ret {
        link: Reg,
    },
    Jump {
        dest: MachLabel,
    },
    CondBr {
        taken: MachLabel,
        not_taken: MachLabel,
        cond: Cond,
    },
    TrapIf {
        cond: Cond,
        trap_code: TrapCode,
    },
    IndirectBr {
        rn: Reg,
        targets: VecMachLabel,
    },
    Debugtrap,
    Trap {
        trap_code: TrapCode,
    },
    JTSequence {
        ridx: Reg,
        default: MachLabel,
        default_cond: Cond,
        targets: BoxVecMachLabel,
    },
    StackProbeLoop {
        probe_count: WritableReg,
        guard_size: i16,
    },
    LoadSymbolReloc {
        rd: WritableReg,
        symbol_reloc: BoxSymbolReloc,
    },
    LoadAddr {
        rd: WritableReg,
        mem: MemArg,
    },
    Loop {
        body: VecMInst,
        cond: Cond,
    },
    CondBreak {
        cond: Cond,
    },
    DummyUse {
        reg: Reg,
    },
    Unwind {
        inst: UnwindInst,
    },
    ElfTlsGetOffset {
        tls_offset: WritableReg,
        got: Reg,
        got_offset: Reg,
        symbol: BoxSymbolReloc,
    },
    LabelAddress {
        dst: WritableReg,
        label: MachLabel,
    },
    SequencePoint,
}

/// Internal type SymbolReloc: defined at src\isa\s390x\inst.isle line 1048.
#[derive(Clone, Debug)]
pub enum SymbolReloc {
    Absolute {
        name: ExternalName,
        offset: i64,
    },
    TlsGd {
        name: ExternalName,
    },
}

/// Internal type ALUOp: defined at src\isa\s390x\inst.isle line 1065.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ALUOp {
    Add32,
    Add32Ext16,
    Add64,
    Add64Ext16,
    Add64Ext32,
    AddLogical32,
    AddLogical64,
    AddLogical64Ext32,
    Sub32,
    Sub32Ext16,
    Sub64,
    Sub64Ext16,
    Sub64Ext32,
    SubLogical32,
    SubLogical64,
    SubLogical64Ext32,
    Mul32,
    Mul32Ext16,
    Mul64,
    Mul64Ext16,
    Mul64Ext32,
    And32,
    And64,
    Orr32,
    Orr64,
    Xor32,
    Xor64,
    NotAnd32,
    NotAnd64,
    NotOrr32,
    NotOrr64,
    NotXor32,
    NotXor64,
    AndNot32,
    AndNot64,
    OrrNot32,
    OrrNot64,
}

/// Internal type UnaryOp: defined at src\isa\s390x\inst.isle line 1112.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum UnaryOp {
    Abs32,
    Abs64,
    Abs64Ext32,
    Neg32,
    Neg64,
    Neg64Ext32,
    PopcntByte,
    PopcntReg,
    BSwap32,
    BSwap64,
}

/// Internal type ShiftOp: defined at src\isa\s390x\inst.isle line 1127.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ShiftOp {
    RotL32,
    RotL64,
    LShL32,
    LShL64,
    LShR32,
    LShR64,
    AShR32,
    AShR64,
}

/// Internal type RxSBGOp: defined at src\isa\s390x\inst.isle line 1140.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum RxSBGOp {
    Insert,
    And,
    Or,
    Xor,
}

/// Internal type CmpOp: defined at src\isa\s390x\inst.isle line 1149.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum CmpOp {
    CmpS32,
    CmpS32Ext16,
    CmpS64,
    CmpS64Ext16,
    CmpS64Ext32,
    CmpL32,
    CmpL32Ext16,
    CmpL64,
    CmpL64Ext16,
    CmpL64Ext32,
}

/// Internal type VecBinaryOp: defined at src\isa\s390x\inst.isle line 1164.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum VecBinaryOp {
    Add8x16,
    Add16x8,
    Add32x4,
    Add64x2,
    Add128,
    Sub8x16,
    Sub16x8,
    Sub32x4,
    Sub64x2,
    Sub128,
    Mul8x16,
    Mul16x8,
    Mul32x4,
    UMulHi8x16,
    UMulHi16x8,
    UMulHi32x4,
    SMulHi8x16,
    SMulHi16x8,
    SMulHi32x4,
    UMulEven8x16,
    UMulEven16x8,
    UMulEven32x4,
    SMulEven8x16,
    SMulEven16x8,
    SMulEven32x4,
    UMulOdd8x16,
    UMulOdd16x8,
    UMulOdd32x4,
    SMulOdd8x16,
    SMulOdd16x8,
    SMulOdd32x4,
    UMax8x16,
    UMax16x8,
    UMax32x4,
    UMax64x2,
    SMax8x16,
    SMax16x8,
    SMax32x4,
    SMax64x2,
    UMin8x16,
    UMin16x8,
    UMin32x4,
    UMin64x2,
    SMin8x16,
    SMin16x8,
    SMin32x4,
    SMin64x2,
    UAvg8x16,
    UAvg16x8,
    UAvg32x4,
    UAvg64x2,
    SAvg8x16,
    SAvg16x8,
    SAvg32x4,
    SAvg64x2,
    And128,
    Orr128,
    Xor128,
    NotAnd128,
    NotOrr128,
    NotXor128,
    AndNot128,
    OrrNot128,
    BitPermute128,
    LShLByByte128,
    LShRByByte128,
    AShRByByte128,
    LShLByBit128,
    LShRByBit128,
    AShRByBit128,
    Pack16x8,
    Pack32x4,
    Pack64x2,
    PackUSat16x8,
    PackUSat32x4,
    PackUSat64x2,
    PackSSat16x8,
    PackSSat32x4,
    PackSSat64x2,
    MergeLow8x16,
    MergeLow16x8,
    MergeLow32x4,
    MergeLow64x2,
    MergeHigh8x16,
    MergeHigh16x8,
    MergeHigh32x4,
    MergeHigh64x2,
}

/// Internal type VecUnaryOp: defined at src\isa\s390x\inst.isle line 1266.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum VecUnaryOp {
    Abs8x16,
    Abs16x8,
    Abs32x4,
    Abs64x2,
    Neg8x16,
    Neg16x8,
    Neg32x4,
    Neg64x2,
    Popcnt8x16,
    Popcnt16x8,
    Popcnt32x4,
    Popcnt64x2,
    Clz8x16,
    Clz16x8,
    Clz32x4,
    Clz64x2,
    Ctz8x16,
    Ctz16x8,
    Ctz32x4,
    Ctz64x2,
    UnpackULow8x16,
    UnpackULow16x8,
    UnpackULow32x4,
    UnpackUHigh8x16,
    UnpackUHigh16x8,
    UnpackUHigh32x4,
    UnpackSLow8x16,
    UnpackSLow16x8,
    UnpackSLow32x4,
    UnpackSHigh8x16,
    UnpackSHigh16x8,
    UnpackSHigh32x4,
}

/// Internal type VecShiftOp: defined at src\isa\s390x\inst.isle line 1307.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum VecShiftOp {
    RotL8x16,
    RotL16x8,
    RotL32x4,
    RotL64x2,
    LShL8x16,
    LShL16x8,
    LShL32x4,
    LShL64x2,
    LShR8x16,
    LShR16x8,
    LShR32x4,
    LShR64x2,
    AShR8x16,
    AShR16x8,
    AShR32x4,
    AShR64x2,
}

/// Internal type VecIntCmpOp: defined at src\isa\s390x\inst.isle line 1328.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum VecIntCmpOp {
    CmpEq8x16,
    CmpEq16x8,
    CmpEq32x4,
    CmpEq64x2,
    SCmpHi8x16,
    SCmpHi16x8,
    SCmpHi32x4,
    SCmpHi64x2,
    UCmpHi8x16,
    UCmpHi16x8,
    UCmpHi32x4,
    UCmpHi64x2,
}

/// Internal type VecFloatCmpOp: defined at src\isa\s390x\inst.isle line 1345.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum VecFloatCmpOp {
    CmpEq32x4,
    CmpEq64x2,
    CmpHi32x4,
    CmpHi64x2,
    CmpHiEq32x4,
    CmpHiEq64x2,
}

/// Internal type FPUOp1: defined at src\isa\s390x\inst.isle line 1356.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FPUOp1 {
    Abs32,
    Abs64,
    Abs128,
    Abs32x4,
    Abs64x2,
    Neg32,
    Neg64,
    Neg128,
    Neg32x4,
    Neg64x2,
    NegAbs32,
    NegAbs64,
    NegAbs128,
    NegAbs32x4,
    NegAbs64x2,
    Sqrt32,
    Sqrt64,
    Sqrt128,
    Sqrt32x4,
    Sqrt64x2,
    Cvt32To64,
    Cvt32x4To64x2,
    Cvt64To128,
}

/// Internal type FPUOp2: defined at src\isa\s390x\inst.isle line 1384.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FPUOp2 {
    Add32,
    Add64,
    Add128,
    Add32x4,
    Add64x2,
    Sub32,
    Sub64,
    Sub128,
    Sub32x4,
    Sub64x2,
    Mul32,
    Mul64,
    Mul128,
    Mul32x4,
    Mul64x2,
    Div32,
    Div64,
    Div128,
    Div32x4,
    Div64x2,
    Max32,
    Max64,
    Max128,
    Max32x4,
    Max64x2,
    Min32,
    Min64,
    Min128,
    Min32x4,
    Min64x2,
    MaxPseudo32,
    MaxPseudo64,
    MaxPseudo128,
    MaxPseudo32x4,
    MaxPseudo64x2,
    MinPseudo32,
    MinPseudo64,
    MinPseudo128,
    MinPseudo32x4,
    MinPseudo64x2,
}

/// Internal type FPUOp3: defined at src\isa\s390x\inst.isle line 1429.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FPUOp3 {
    MAdd32,
    MAdd64,
    MAdd128,
    MAdd32x4,
    MAdd64x2,
    MSub32,
    MSub64,
    MSub128,
    MSub32x4,
    MSub64x2,
}

/// Internal type FpuRoundOp: defined at src\isa\s390x\inst.isle line 1444.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuRoundOp {
    Cvt64To32,
    Cvt64x2To32x4,
    Cvt128To64,
    Round32,
    Round64,
    Round128,
    Round32x4,
    Round64x2,
    ToSInt32,
    ToSInt64,
    ToUInt32,
    ToUInt64,
    ToSInt32x4,
    ToSInt64x2,
    ToUInt32x4,
    ToUInt64x2,
    FromSInt32,
    FromSInt64,
    FromUInt32,
    FromUInt64,
    FromSInt32x4,
    FromSInt64x2,
    FromUInt32x4,
    FromUInt64x2,
}

/// Internal type FpuConv128Op: defined at src\isa\s390x\inst.isle line 1473.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuConv128Op {
    SInt32,
    UInt32,
    SInt64,
    UInt64,
}

/// Internal type FpuRoundMode: defined at src\isa\s390x\inst.isle line 1482.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuRoundMode {
    Current,
    ToNearest,
    ShorterPrecision,
    ToNearestTiesToEven,
    ToZero,
    ToPosInfinity,
    ToNegInfinity,
}

/// Internal type LaneOrder: defined at src\isa\s390x\inst.isle line 1523.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum LaneOrder {
    LittleEndian,
    BigEndian,
}

/// Internal type ProducesBool: defined at src\isa\s390x\inst.isle line 3264.
#[derive(Clone, Debug)]
pub enum ProducesBool {
    ProducesBool {
        producer: ProducesFlags,
        cond: Cond,
    },
}

// Generated as internal constructor for term ty_shift_mask.
pub fn constructor_ty_shift_mask<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> u64 {
    let v1 = C::lane_type(ctx, arg0);
    let v2 = C::ty_bits(ctx, v1);
    let v3 = C::u8_into_u64(ctx, v2);
    let v5 = C::u64_sub(ctx, v3, 0x1_u64);
    // Rule at src\prelude.isle line 293.
    return v5;
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> InstOutput {
    let v1 = C::value_reg(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src\prelude_lower.isle line 81.
    return v2;
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> InstOutput {
    let v1 = C::put_in_regs(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src\prelude_lower.isle line 85.
    return v2;
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Reg {
    let v1 = C::temp_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src\prelude_lower.isle line 97.
    return v2;
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v1 = C::put_in_regs(ctx, arg0);
    let v3 = C::value_regs_get(ctx, v1, 0x0_usize);
    // Rule at src\prelude_lower.isle line 162.
    return v3;
}

// Generated as internal constructor for term multi_reg_to_pair_and_single.
pub fn constructor_multi_reg_to_pair_and_single<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::Three {
        a: v1,
        b: v2,
        c: v3,
    } = arg0 {
        let v4 = C::value_regs(ctx, v1, v2);
        let v5 = C::value_reg(ctx, v3);
        let v6 = C::output_pair(ctx, v4, v5);
        // Rule at src\prelude_lower.isle line 173.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_pair_and_single", "src\\prelude_lower.isle line 172")
}

// Generated as internal constructor for term multi_reg_to_pair.
pub fn constructor_multi_reg_to_pair<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::Two {
        a: v1,
        b: v2,
    } = arg0 {
        let v3 = C::value_regs(ctx, v1, v2);
        let v4 = C::output(ctx, v3);
        // Rule at src\prelude_lower.isle line 178.
        return v4;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_pair", "src\\prelude_lower.isle line 177")
}

// Generated as internal constructor for term multi_reg_to_single.
pub fn constructor_multi_reg_to_single<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::One {
        a: v1,
    } = arg0 {
        let v2 = C::value_reg(ctx, v1);
        let v3 = C::output(ctx, v2);
        // Rule at src\prelude_lower.isle line 183.
        return v3;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_single", "src\\prelude_lower.isle line 182")
}

// Generated as internal constructor for term emit_side_effect.
pub fn constructor_emit_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> Unit {
    match arg0 {
        &SideEffectNoResult::Inst {
            inst: ref v1,
        } => {
            let v2 = C::emit(ctx, v1);
            // Rule at src\prelude_lower.isle line 451.
            return v2;
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v3,
            inst2: ref v4,
        } => {
            let v5 = C::emit(ctx, v3);
            let v6 = C::emit(ctx, v4);
            // Rule at src\prelude_lower.isle line 453.
            return v6;
        }
        &SideEffectNoResult::Inst3 {
            inst1: ref v7,
            inst2: ref v8,
            inst3: ref v9,
        } => {
            let v10 = C::emit(ctx, v7);
            let v11 = C::emit(ctx, v8);
            let v12 = C::emit(ctx, v9);
            // Rule at src\prelude_lower.isle line 456.
            return v12;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_side_effect", "src\\prelude_lower.isle line 450")
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> InstOutput {
    let v1 = constructor_emit_side_effect(ctx, arg0);
    let v2 = C::output_none(ctx);
    // Rule at src\prelude_lower.isle line 466.
    return v2;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> SideEffectNoResult {
    match arg0 {
        &SideEffectNoResult::Inst {
            inst: ref v1,
        } => {
            match arg1 {
                &SideEffectNoResult::Inst {
                    inst: ref v3,
                } => {
                    let v4 = SideEffectNoResult::Inst2 {
                        inst1: v1.clone(),
                        inst2: v3.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 471.
                    return v4;
                }
                &SideEffectNoResult::Inst2 {
                    inst1: ref v5,
                    inst2: ref v6,
                } => {
                    let v7 = SideEffectNoResult::Inst3 {
                        inst1: v1.clone(),
                        inst2: v5.clone(),
                        inst3: v6.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 473.
                    return v7;
                }
                _ => {}
            }
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v8,
            inst2: ref v9,
        } => {
            if let &SideEffectNoResult::Inst {
                inst: ref v3,
            } = arg1 {
                let v10 = SideEffectNoResult::Inst3 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                    inst3: v3.clone(),
                };
                // Rule at src\prelude_lower.isle line 475.
                return v10;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "side_effect_concat", "src\\prelude_lower.isle line 470")
}

// Generated as internal constructor for term side_effect_as_invalid.
pub fn constructor_side_effect_as_invalid<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> InstOutput {
    let v1 = constructor_side_effect(ctx, arg0);
    let v2 = C::invalid_reg(ctx);
    let v3 = constructor_output_reg(ctx, v2);
    // Rule at src\prelude_lower.isle line 481.
    return v3;
}

// Generated as internal constructor for term produces_flags_concat.
pub fn constructor_produces_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ProducesFlags,
) -> ProducesFlags {
    if let &ProducesFlags::ProducesFlagsSideEffect {
        inst: ref v1,
    } = arg0 {
        if let &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v3,
        } = arg1 {
            let v4 = ProducesFlags::ProducesFlagsTwiceSideEffect {
                inst1: v1.clone(),
                inst2: v3.clone(),
            };
            // Rule at src\prelude_lower.isle line 507.
            return v4;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_concat", "src\\prelude_lower.isle line 506")
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Reg {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            // Rule at src\prelude_lower.isle line 537.
            return v2;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v3,
            result: v4,
        } => {
            // Rule at src\prelude_lower.isle line 538.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_get_reg", "src\\prelude_lower.isle line 536")
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> ProducesFlags {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            let v3 = ProducesFlags::ProducesFlagsSideEffect {
                inst: v1.clone(),
            };
            // Rule at src\prelude_lower.isle line 543.
            return v3;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v4,
            result: v5,
        } => {
            let v6 = ProducesFlags::ProducesFlagsSideEffect {
                inst: v4.clone(),
            };
            // Rule at src\prelude_lower.isle line 545.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_ignore", "src\\prelude_lower.isle line 542")
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> ConsumesFlags {
    match arg0 {
        &ConsumesFlags::ConsumesFlagsSideEffect {
            inst: ref v8,
        } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref v9,
            } = arg1 {
                let v10 = ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                };
                // Rule at src\prelude_lower.isle line 558.
                return v10;
            }
        }
        &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            if let &ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: ref v4,
                result: v5,
            } = arg1 {
                let v6 = C::value_regs(ctx, v2, v5);
                let v7 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: v1.clone(),
                    inst2: v4.clone(),
                    result: v6,
                };
                // Rule at src\prelude_lower.isle line 552.
                return v7;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_concat", "src\\prelude_lower.isle line 551")
}

// Generated as internal constructor for term consumes_flags_get_reg.
pub fn constructor_consumes_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
) -> Reg {
    if let &ConsumesFlags::ConsumesFlagsReturnsReg {
        inst: ref v1,
        result: v2,
    } = arg0 {
        // Rule at src\prelude_lower.isle line 565.
        return v2;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_get_reg", "src\\prelude_lower.isle line 564")
}

// Generated as internal constructor for term consumes_flags_get_regs.
pub fn constructor_consumes_flags_get_regs<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
) -> ValueRegs {
    if let &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
        inst1: ref v1,
        inst2: ref v2,
        result: v3,
    } = arg0 {
        // Rule at src\prelude_lower.isle line 567.
        return v3;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_get_regs", "src\\prelude_lower.isle line 566")
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> ValueRegs {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v12,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v16 = C::emit(ctx, v13);
                    let v17 = C::value_reg(ctx, v14);
                    // Rule at src\prelude_lower.isle line 595.
                    return v17;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v21 = C::emit(ctx, v18);
                    let v22 = C::emit(ctx, v19);
                    // Rule at src\prelude_lower.isle line 601.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v28 = C::emit(ctx, v23);
                    let v29 = C::emit(ctx, v24);
                    let v30 = C::emit(ctx, v25);
                    let v31 = C::emit(ctx, v26);
                    // Rule at src\prelude_lower.isle line 613.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v32,
            inst2: ref v33,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v36 = C::emit(ctx, v13);
                    let v37 = C::value_reg(ctx, v14);
                    // Rule at src\prelude_lower.isle line 629.
                    return v37;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v38 = C::emit(ctx, v18);
                    let v39 = C::emit(ctx, v19);
                    // Rule at src\prelude_lower.isle line 636.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v40 = C::emit(ctx, v23);
                    let v41 = C::emit(ctx, v24);
                    let v42 = C::emit(ctx, v25);
                    let v43 = C::emit(ctx, v26);
                    // Rule at src\prelude_lower.isle line 649.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v1,
            result: v2,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v9,
                } => {
                    let v6 = C::emit(ctx, v1);
                    let v10 = C::emit(ctx, v9);
                    let v11 = C::value_reg(ctx, v2);
                    // Rule at src\prelude_lower.isle line 589.
                    return v11;
                }
                &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                    inst: ref v4,
                    result: v5,
                } => {
                    let v6 = C::emit(ctx, v1);
                    let v7 = C::emit(ctx, v4);
                    let v8 = C::value_regs(ctx, v2, v5);
                    // Rule at src\prelude_lower.isle line 581.
                    return v8;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags", "src\\prelude_lower.isle line 579")
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Reg {
    let v2 = constructor_with_flags(ctx, arg0, arg1);
    let v4 = C::value_regs_get(ctx, v2, 0x0_usize);
    // Rule at src\prelude_lower.isle line 667.
    return v4;
}

// Generated as internal constructor for term flags_to_producesflags.
pub fn constructor_flags_to_producesflags<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> ProducesFlags {
    let v1 = C::mark_value_used(ctx, arg0);
    // Rule at src\prelude_lower.isle line 674.
    return ProducesFlags::AlreadyExistingFlags;
}

// Generated as internal constructor for term with_flags_side_effect.
pub fn constructor_with_flags_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> SideEffectNoResult {
    match arg0 {
        &ProducesFlags::AlreadyExistingFlags => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v2,
                } => {
                    let v3 = SideEffectNoResult::Inst {
                        inst: v2.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 685.
                    return v3;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v6 = SideEffectNoResult::Inst2 {
                        inst1: v4.clone(),
                        inst2: v5.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 690.
                    return v6;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v7,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v2,
                } => {
                    let v8 = SideEffectNoResult::Inst2 {
                        inst1: v7.clone(),
                        inst2: v2.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 695.
                    return v8;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v9 = SideEffectNoResult::Inst3 {
                        inst1: v7.clone(),
                        inst2: v4.clone(),
                        inst3: v5.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 700.
                    return v9;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v10,
            inst2: ref v11,
        } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref v2,
            } = arg1 {
                let v12 = SideEffectNoResult::Inst3 {
                    inst1: v10.clone(),
                    inst2: v11.clone(),
                    inst3: v2.clone(),
                };
                // Rule at src\prelude_lower.isle line 705.
                return v12;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags_side_effect", "src\\prelude_lower.isle line 683")
}

// Generated as internal constructor for term with_flags_chained.
pub fn constructor_with_flags_chained<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesAndProducesFlags,
    arg2: &ConsumesFlags,
) -> MultiReg {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v1,
        } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect {
                    inst: ref v3,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            // Rule at src\prelude_lower.isle line 714.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            // Rule at src\prelude_lower.isle line 722.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v17 = MultiReg::One {
                                a: v15,
                            };
                            // Rule at src\prelude_lower.isle line 731.
                            return v17;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v27 = MultiReg::Two {
                                a: v24,
                                b: v26,
                            };
                            // Rule at src\prelude_lower.isle line 739.
                            return v27;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v39 = MultiReg::Two {
                                a: v37,
                                b: v38,
                            };
                            // Rule at src\prelude_lower.isle line 748.
                            return v39;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v50 = MultiReg::One {
                                a: v48,
                            };
                            // Rule at src\prelude_lower.isle line 808.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v50 = MultiReg::One {
                                a: v48,
                            };
                            // Rule at src\prelude_lower.isle line 816.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v51 = MultiReg::Two {
                                a: v48,
                                b: v15,
                            };
                            // Rule at src\prelude_lower.isle line 825.
                            return v51;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v52 = MultiReg::Three {
                                a: v48,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src\prelude_lower.isle line 833.
                            return v52;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v53 = MultiReg::Three {
                                a: v48,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src\prelude_lower.isle line 842.
                            return v53;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v40,
            result: v41,
        } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect {
                    inst: ref v3,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            let v43 = MultiReg::One {
                                a: v41,
                            };
                            // Rule at src\prelude_lower.isle line 761.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v43 = MultiReg::One {
                                a: v41,
                            };
                            // Rule at src\prelude_lower.isle line 769.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v44 = MultiReg::Two {
                                a: v41,
                                b: v15,
                            };
                            // Rule at src\prelude_lower.isle line 778.
                            return v44;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v45 = MultiReg::Three {
                                a: v41,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src\prelude_lower.isle line 786.
                            return v45;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v46 = MultiReg::Three {
                                a: v41,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src\prelude_lower.isle line 795.
                            return v46;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v54 = MultiReg::Two {
                                a: v41,
                                b: v48,
                            };
                            // Rule at src\prelude_lower.isle line 855.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v54 = MultiReg::Two {
                                a: v41,
                                b: v48,
                            };
                            // Rule at src\prelude_lower.isle line 863.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v55 = MultiReg::Three {
                                a: v41,
                                b: v48,
                                c: v15,
                            };
                            // Rule at src\prelude_lower.isle line 872.
                            return v55;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v56 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v24,
                                d: v26,
                            };
                            // Rule at src\prelude_lower.isle line 880.
                            return v56;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v57 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v37,
                                d: v38,
                            };
                            // Rule at src\prelude_lower.isle line 889.
                            return v57;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v58,
            result: v59,
        } => {
            if let &ConsumesAndProducesFlags::ReturnsReg {
                inst: ref v47,
                result: v48,
            } = arg1 {
                match arg2 {
                    &ConsumesFlags::ConsumesFlagsSideEffect {
                        inst: ref v5,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v8 = C::emit(ctx, v5);
                        let v61 = MultiReg::Two {
                            a: v59,
                            b: v48,
                        };
                        // Rule at src\prelude_lower.isle line 901.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsSideEffect2 {
                        inst1: ref v10,
                        inst2: ref v11,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v12 = C::emit(ctx, v10);
                        let v13 = C::emit(ctx, v11);
                        let v61 = MultiReg::Two {
                            a: v59,
                            b: v48,
                        };
                        // Rule at src\prelude_lower.isle line 909.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                        inst: ref v63,
                        result: v64,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v65 = C::emit(ctx, v63);
                        let v66 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v64,
                        };
                        // Rule at src\prelude_lower.isle line 926.
                        return v66;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsReg {
                        inst: ref v14,
                        result: v15,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v16 = C::emit(ctx, v14);
                        let v62 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v15,
                        };
                        // Rule at src\prelude_lower.isle line 918.
                        return v62;
                    }
                    &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                        inst1: ref v18,
                        inst2: ref v19,
                        result: v20,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v21 = C::emit(ctx, v18);
                        let v22 = C::emit(ctx, v19);
                        let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                        let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                        let v67 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v24,
                            d: v26,
                        };
                        // Rule at src\prelude_lower.isle line 934.
                        return v67;
                    }
                    &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                        inst1: ref v28,
                        inst2: ref v29,
                        inst3: ref v30,
                        inst4: ref v31,
                        result: v32,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v33 = C::emit(ctx, v28);
                        let v34 = C::emit(ctx, v29);
                        let v35 = C::emit(ctx, v30);
                        let v36 = C::emit(ctx, v31);
                        let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                        let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                        let v68 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v37,
                            d: v38,
                        };
                        // Rule at src\prelude_lower.isle line 943.
                        return v68;
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags_chained", "src\\prelude_lower.isle line 711")
}

// Generated as internal constructor for term lower_return.
pub fn constructor_lower_return<C: Context>(
    ctx: &mut C,
    arg0: ValueSlice,
) -> InstOutput {
    let v1 = &C::put_in_regs_vec(ctx, arg0);
    let v2 = C::gen_return(ctx, v1);
    let v3 = C::output_none(ctx);
    // Rule at src\prelude_lower.isle line 1153.
    return v3;
}

// Generated as internal constructor for term lane_order_equal.
pub fn constructor_lane_order_equal<C: Context>(
    ctx: &mut C,
    arg0: &LaneOrder,
    arg1: &LaneOrder,
) -> bool {
    match arg0 {
        &LaneOrder::LittleEndian => {
            match arg1 {
                &LaneOrder::LittleEndian => {
                    let v2 = true;
                    // Rule at src\isa\s390x\inst.isle line 1537.
                    return v2;
                }
                &LaneOrder::BigEndian => {
                    let v3 = false;
                    // Rule at src\isa\s390x\inst.isle line 1538.
                    return v3;
                }
                _ => {}
            }
        }
        &LaneOrder::BigEndian => {
            match arg1 {
                &LaneOrder::LittleEndian => {
                    let v3 = false;
                    // Rule at src\isa\s390x\inst.isle line 1539.
                    return v3;
                }
                &LaneOrder::BigEndian => {
                    let v2 = true;
                    // Rule at src\isa\s390x\inst.isle line 1540.
                    return v2;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lane_order_equal", "src\\isa\\s390x\\inst.isle line 1536")
}

// Generated as internal constructor for term lane_order_from_memflags.
pub fn constructor_lane_order_from_memflags<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
) -> LaneOrder {
    let v4 = C::bigendian(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 1545.
        return LaneOrder::BigEndian;
    }
    let v1 = C::littleendian(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 1544.
        return LaneOrder::LittleEndian;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lane_order_from_memflags", "src\\isa\\s390x\\inst.isle line 1543")
}

// Generated as internal constructor for term i64_not_neg1.
pub fn constructor_i64_not_neg1<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> Option<i64> {
    let v2 = C::i64_nonequal(ctx, arg0, -1_i64);
    if let Some(v3) = v2 {
        let v4 = Some(arg0);
        // Rule at src\isa\s390x\inst.isle line 1597.
        return v4;
    }
    None
}

// Generated as internal constructor for term imm8x16.
pub fn constructor_imm8x16<C: Context>(
    ctx: &mut C,
    arg0: u8,
    arg1: u8,
    arg2: u8,
    arg3: u8,
    arg4: u8,
    arg5: u8,
    arg6: u8,
    arg7: u8,
    arg8: u8,
    arg9: u8,
    arg10: u8,
    arg11: u8,
    arg12: u8,
    arg13: u8,
    arg14: u8,
    arg15: u8,
) -> u128 {
    let v16 = C::u8_pair_concat(ctx, arg0, arg1);
    let v17 = C::u8_pair_concat(ctx, arg2, arg3);
    let v18 = C::u16_pair_concat(ctx, v16, v17);
    let v19 = C::u8_pair_concat(ctx, arg4, arg5);
    let v20 = C::u8_pair_concat(ctx, arg6, arg7);
    let v21 = C::u16_pair_concat(ctx, v19, v20);
    let v22 = C::u32_pair_concat(ctx, v18, v21);
    let v23 = C::u8_pair_concat(ctx, arg8, arg9);
    let v24 = C::u8_pair_concat(ctx, arg10, arg11);
    let v25 = C::u16_pair_concat(ctx, v23, v24);
    let v26 = C::u8_pair_concat(ctx, arg12, arg13);
    let v27 = C::u8_pair_concat(ctx, arg14, arg15);
    let v28 = C::u16_pair_concat(ctx, v26, v27);
    let v29 = C::u32_pair_concat(ctx, v25, v28);
    let v30 = C::u64_pair_concat(ctx, v22, v29);
    // Rule at src\isa\s390x\inst.isle line 1625.
    return v30;
}

// Generated as internal constructor for term mask_amt_reg.
pub fn constructor_mask_amt_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v10 = C::gpr64_ty(ctx, arg0);
    if let Some(v11) = v10 {
        // Rule at src\isa\s390x\inst.isle line 1728.
        return arg1;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = C::mask_amt_imm(ctx, v2, -1_i64);
        let v6 = C::u8_into_u16(ctx, v5);
        let v8 = C::uimm16shifted(ctx, v6, 0x0_u8);
        let v9 = constructor_and_uimm16shifted(ctx, v2, arg1, v8);
        // Rule at src\isa\s390x\inst.isle line 1725.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "mask_amt_reg", "src\\isa\\s390x\\inst.isle line 1724")
}

// Generated as internal constructor for term amt_reg.
pub fn constructor_amt_reg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v1 = C::value_type(ctx, arg0);
    let v2 = C::fits_in_64(ctx, v1);
    if let Some(v3) = v2 {
        let v4 = C::put_in_reg(ctx, arg0);
        // Rule at src\isa\s390x\inst.isle line 1732.
        return v4;
    }
    let v5 = C::vr128_ty(ctx, v1);
    if let Some(v6) = v5 {
        let v4 = C::put_in_reg(ctx, arg0);
        let v9 = C::zero_reg(ctx);
        let v10 = constructor_vec_extract_lane(ctx, I64X2, v4, 0x1_u8, v9);
        // Rule at src\isa\s390x\inst.isle line 1733.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "amt_reg", "src\\isa\\s390x\\inst.isle line 1731")
}

// Generated as internal constructor for term amt_vr.
pub fn constructor_amt_vr<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v14 = C::u64_from_value(ctx, arg0);
    if let Some(v15) = v14 {
        let v16 = constructor_vec_imm_splat(ctx, I8X16, v15);
        // Rule at src\isa\s390x\inst.isle line 1743.
        return v16;
    }
    let v1 = C::value_type(ctx, arg0);
    let v10 = C::vr128_ty(ctx, v1);
    if let Some(v11) = v10 {
        let v5 = C::put_in_reg(ctx, arg0);
        let v13 = constructor_vec_replicate_lane(ctx, I8X16, v5, 0xf_u8);
        // Rule at src\isa\s390x\inst.isle line 1741.
        return v13;
    }
    let v2 = C::fits_in_64(ctx, v1);
    if let Some(v3) = v2 {
        let v5 = C::put_in_reg(ctx, arg0);
        let v7 = C::zero_reg(ctx);
        let v8 = constructor_vec_insert_lane_undef(ctx, I8X16, v5, 0x0_u8, v7);
        let v9 = constructor_vec_replicate_lane(ctx, I8X16, v8, 0x0_u8);
        // Rule at src\isa\s390x\inst.isle line 1738.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "amt_vr", "src\\isa\\s390x\\inst.isle line 1737")
}

// Generated as internal constructor for term memarg_symbol_offset.
pub fn constructor_memarg_symbol_offset<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> Option<i32> {
    let v2 = C::memarg_symbol_offset_sum(ctx, arg0, 0_i64);
    let v3 = v2?;
    let v4 = Some(v3);
    // Rule at src\isa\s390x\inst.isle line 1817.
    return v4;
}

// Generated as internal constructor for term lower_address.
pub fn constructor_lower_address<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Offset32,
) -> MemArg {
    let v10 = C::def_inst(ctx, arg1);
    if let Some(v11) = v10 {
        let v17 = &C::inst_data_value(ctx, v11);
        match v17 {
            &InstructionData::Binary {
                opcode: ref v18,
                args: ref v19,
            } => {
                if let &Opcode::Iadd = v18 {
                    let v6 = C::i64_from_offset(ctx, arg2);
                    if v6 == 0_i64 {
                        let v12 = C::first_result(ctx, v11);
                        if let Some(v13) = v12 {
                            let v14 = C::value_type(ctx, v13);
                            let v15 = C::ty_addr64(ctx, v14);
                            if let Some(v16) = v15 {
                                let v20 = C::unpack_value_array_2(ctx, v19);
                                let v23 = C::put_in_reg(ctx, v20.0);
                                let v24 = C::put_in_reg(ctx, v20.1);
                                let v25 = &C::memarg_reg_plus_reg(ctx, v23, v24, 0x0_u8, arg0);
                                // Rule at src\isa\s390x\inst.isle line 1835.
                                return v25.clone();
                            }
                        }
                    }
                }
            }
            &InstructionData::UnaryGlobalValue {
                opcode: ref v26,
                global_value: v27,
            } => {
                if let &Opcode::SymbolValue = v26 {
                    let v28 = C::symbol_value_data(ctx, v27);
                    if let Some(v29) = v28 {
                        if let &RelocDistance::Near = &v29.1 {
                            let v6 = C::i64_from_offset(ctx, arg2);
                            let v33 = C::memarg_symbol_offset_sum(ctx, v6, v29.2);
                            if let Some(v34) = v33 {
                                let v35 = &C::memarg_symbol(ctx, v29.0, v34, arg0);
                                // Rule at src\isa\s390x\inst.isle line 1838.
                                return v35.clone();
                            }
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let v2 = C::value_type(ctx, arg1);
    let v3 = C::ty_addr64(ctx, v2);
    if let Some(v4) = v3 {
        let v7 = C::put_in_reg(ctx, arg1);
        let v6 = C::i64_from_offset(ctx, arg2);
        let v9 = &C::memarg_reg_plus_off(ctx, v7, v6, 0x0_u8, arg0);
        // Rule at src\isa\s390x\inst.isle line 1832.
        return v9.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_address", "src\\isa\\s390x\\inst.isle line 1830")
}

// Generated as internal constructor for term lower_address_bias.
pub fn constructor_lower_address_bias<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Offset32,
    arg3: u8,
) -> MemArg {
    let v4 = C::i64_from_offset(ctx, arg2);
    if v4 == 0_i64 {
        let v8 = C::def_inst(ctx, arg1);
        if let Some(v9) = v8 {
            let v10 = C::first_result(ctx, v9);
            if let Some(v11) = v10 {
                let v12 = C::value_type(ctx, v11);
                if v12 == I64 {
                    let v13 = &C::inst_data_value(ctx, v9);
                    if let &InstructionData::Binary {
                        opcode: ref v14,
                        args: ref v15,
                    } = v13 {
                        if let &Opcode::Iadd = v14 {
                            let v16 = C::unpack_value_array_2(ctx, v15);
                            let v19 = C::put_in_reg(ctx, v16.0);
                            let v20 = C::put_in_reg(ctx, v16.1);
                            let v21 = &C::memarg_reg_plus_reg(ctx, v19, v20, arg3, arg0);
                            // Rule at src\isa\s390x\inst.isle line 1852.
                            return v21.clone();
                        }
                    }
                }
            }
        }
    }
    let v2 = C::value_type(ctx, arg1);
    if v2 == I64 {
        let v6 = C::put_in_reg(ctx, arg1);
        let v7 = &C::memarg_reg_plus_off(ctx, v6, v4, arg3, arg0);
        // Rule at src\isa\s390x\inst.isle line 1849.
        return v7.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_address_bias", "src\\isa\\s390x\\inst.isle line 1847")
}

// Generated as internal constructor for term load_sym.
pub fn constructor_load_sym<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> Option<Inst> {
    let v1 = &C::inst_data_value(ctx, arg0);
    if let &InstructionData::Load {
        opcode: ref v2,
        arg: v3,
        flags: v4,
        offset: v5,
    } = v1 {
        if let &Opcode::Load = v2 {
            let v6 = C::def_inst(ctx, v3);
            if let Some(v7) = v6 {
                let v8 = &C::inst_data_value(ctx, v7);
                if let &InstructionData::UnaryGlobalValue {
                    opcode: ref v9,
                    global_value: v10,
                } = v8 {
                    if let &Opcode::SymbolValue = v9 {
                        let v11 = C::symbol_value_data(ctx, v10);
                        if let Some(v12) = v11 {
                            if let &RelocDistance::Near = &v12.1 {
                                let v16 = C::i64_from_offset(ctx, v5);
                                let v17 = C::memarg_symbol_offset_sum(ctx, v12.2, v16);
                                if let Some(v18) = v17 {
                                    let v19 = Some(arg0);
                                    // Rule at src\isa\s390x\inst.isle line 1859.
                                    return v19;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term uload16_sym.
pub fn constructor_uload16_sym<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> Option<Inst> {
    let v1 = &C::inst_data_value(ctx, arg0);
    if let &InstructionData::Load {
        opcode: ref v2,
        arg: v3,
        flags: v4,
        offset: v5,
    } = v1 {
        if let &Opcode::Uload16 = v2 {
            let v6 = C::def_inst(ctx, v3);
            if let Some(v7) = v6 {
                let v8 = &C::inst_data_value(ctx, v7);
                if let &InstructionData::UnaryGlobalValue {
                    opcode: ref v9,
                    global_value: v10,
                } = v8 {
                    if let &Opcode::SymbolValue = v9 {
                        let v11 = C::symbol_value_data(ctx, v10);
                        if let Some(v12) = v11 {
                            if let &RelocDistance::Near = &v12.1 {
                                let v16 = C::i64_from_offset(ctx, v5);
                                let v17 = C::memarg_symbol_offset_sum(ctx, v12.2, v16);
                                if let Some(v18) = v17 {
                                    let v19 = Some(arg0);
                                    // Rule at src\isa\s390x\inst.isle line 1867.
                                    return v19;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term stack_addr_impl.
pub fn constructor_stack_addr_impl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, arg0);
    let v4 = &C::abi_stackslot_addr(ctx, v3, arg1, arg2);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 1878.
    return v6;
}

// Generated as internal constructor for term sink_load.
pub fn constructor_sink_load<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> MemArg {
    let v1 = &C::inst_data_value(ctx, arg0);
    if let &InstructionData::Load {
        opcode: ref v2,
        arg: v3,
        flags: v4,
        offset: v5,
    } = v1 {
        if let &Opcode::Load = v2 {
            let v6 = C::sink_inst(ctx, arg0);
            let v7 = &constructor_lower_address(ctx, v4, v3, v5);
            // Rule at src\isa\s390x\inst.isle line 1944.
            return v7.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sink_load", "src\\isa\\s390x\\inst.isle line 1943")
}

// Generated as internal constructor for term sink_sload16.
pub fn constructor_sink_sload16<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> MemArg {
    let v1 = &C::inst_data_value(ctx, arg0);
    if let &InstructionData::Load {
        opcode: ref v2,
        arg: v3,
        flags: v4,
        offset: v5,
    } = v1 {
        if let &Opcode::Sload16 = v2 {
            let v6 = C::sink_inst(ctx, arg0);
            let v7 = &constructor_lower_address(ctx, v4, v3, v5);
            // Rule at src\isa\s390x\inst.isle line 1951.
            return v7.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sink_sload16", "src\\isa\\s390x\\inst.isle line 1950")
}

// Generated as internal constructor for term sink_sload32.
pub fn constructor_sink_sload32<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> MemArg {
    let v1 = &C::inst_data_value(ctx, arg0);
    if let &InstructionData::Load {
        opcode: ref v2,
        arg: v3,
        flags: v4,
        offset: v5,
    } = v1 {
        if let &Opcode::Sload32 = v2 {
            let v6 = C::sink_inst(ctx, arg0);
            let v7 = &constructor_lower_address(ctx, v4, v3, v5);
            // Rule at src\isa\s390x\inst.isle line 1958.
            return v7.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sink_sload32", "src\\isa\\s390x\\inst.isle line 1957")
}

// Generated as internal constructor for term sink_uload16.
pub fn constructor_sink_uload16<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> MemArg {
    let v1 = &C::inst_data_value(ctx, arg0);
    if let &InstructionData::Load {
        opcode: ref v2,
        arg: v3,
        flags: v4,
        offset: v5,
    } = v1 {
        if let &Opcode::Uload16 = v2 {
            let v6 = C::sink_inst(ctx, arg0);
            let v7 = &constructor_lower_address(ctx, v4, v3, v5);
            // Rule at src\isa\s390x\inst.isle line 1965.
            return v7.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sink_uload16", "src\\isa\\s390x\\inst.isle line 1964")
}

// Generated as internal constructor for term sink_uload32.
pub fn constructor_sink_uload32<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> MemArg {
    let v1 = &C::inst_data_value(ctx, arg0);
    if let &InstructionData::Load {
        opcode: ref v2,
        arg: v3,
        flags: v4,
        offset: v5,
    } = v1 {
        if let &Opcode::Uload32 = v2 {
            let v6 = C::sink_inst(ctx, arg0);
            let v7 = &constructor_lower_address(ctx, v4, v3, v5);
            // Rule at src\isa\s390x\inst.isle line 1972.
            return v7.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sink_uload32", "src\\isa\\s390x\\inst.isle line 1971")
}

// Generated as internal constructor for term temp_writable_regpair.
pub fn constructor_temp_writable_regpair<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> WritableRegPair {
    let v1 = C::temp_writable_reg(ctx, arg0);
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = C::writable_regpair(ctx, v1, v2);
    // Rule at src\isa\s390x\inst.isle line 1988.
    return v3;
}

// Generated as internal constructor for term writable_regpair_to_regpair.
pub fn constructor_writable_regpair_to_regpair<C: Context>(
    ctx: &mut C,
    arg0: WritableRegPair,
) -> RegPair {
    let v1 = C::writable_regpair_hi(ctx, arg0);
    let v3 = C::writable_regpair_lo(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    let v4 = C::writable_reg_to_reg(ctx, v3);
    let v5 = C::regpair(ctx, v2, v4);
    // Rule at src\isa\s390x\inst.isle line 2004.
    return v5;
}

// Generated as internal constructor for term fp_reg_to_regpair.
pub fn constructor_fp_reg_to_regpair<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> RegPair {
    let v3 = constructor_vec_replicate_lane(ctx, I64X2, arg0, 0x1_u8);
    let v4 = C::regpair(ctx, arg0, v3);
    // Rule at src\isa\s390x\inst.isle line 2021.
    return v4;
}

// Generated as internal constructor for term fp_regpair_to_reg.
pub fn constructor_fp_regpair_to_reg<C: Context>(
    ctx: &mut C,
    arg0: RegPair,
) -> Reg {
    let v2 = C::regpair_hi(ctx, arg0);
    let v3 = C::regpair_lo(ctx, arg0);
    let v4 = constructor_vec_merge_high(ctx, I64X2, v2, v3);
    // Rule at src\isa\s390x\inst.isle line 2023.
    return v4;
}

// Generated as internal constructor for term alu_rrr.
pub fn constructor_alu_rrr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRRR {
        alu_op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2030.
    return v7;
}

// Generated as internal constructor for term alu_rrr_with_flags_paired.
pub fn constructor_alu_rrr_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: Reg,
) -> ProducesFlags {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRRR {
        alu_op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = C::writable_reg_to_reg(ctx, v4);
    let v7 = ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
        inst: v5,
        result: v6,
    };
    // Rule at src\isa\s390x\inst.isle line 2037.
    return v7;
}

// Generated as internal constructor for term alu_rrsimm16.
pub fn constructor_alu_rrsimm16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: i16,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRRSImm16 {
        alu_op: arg1.clone(),
        rd: v4,
        rn: arg2,
        imm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2044.
    return v7;
}

// Generated as internal constructor for term alu_rr.
pub fn constructor_alu_rr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRR {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        rm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2051.
    return v7;
}

// Generated as internal constructor for term alu_rr_with_flags_paired.
pub fn constructor_alu_rr_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: Reg,
) -> ProducesFlags {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRR {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        rm: arg3,
    };
    let v6 = C::writable_reg_to_reg(ctx, v4);
    let v7 = ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
        inst: v5,
        result: v6,
    };
    // Rule at src\isa\s390x\inst.isle line 2058.
    return v7;
}

// Generated as internal constructor for term alu_rx.
pub fn constructor_alu_rx<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: &MemArg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRX {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        mem: arg3.clone(),
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2065.
    return v7;
}

// Generated as internal constructor for term alu_rx_with_flags_paired.
pub fn constructor_alu_rx_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: &MemArg,
) -> ProducesFlags {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRX {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        mem: arg3.clone(),
    };
    let v6 = C::writable_reg_to_reg(ctx, v4);
    let v7 = ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
        inst: v5,
        result: v6,
    };
    // Rule at src\isa\s390x\inst.isle line 2072.
    return v7;
}

// Generated as internal constructor for term alu_rsimm16.
pub fn constructor_alu_rsimm16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: i16,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRSImm16 {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        imm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2079.
    return v7;
}

// Generated as internal constructor for term alu_rsimm32.
pub fn constructor_alu_rsimm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: i32,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRSImm32 {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        imm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2086.
    return v7;
}

// Generated as internal constructor for term alu_ruimm32.
pub fn constructor_alu_ruimm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: u32,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRUImm32 {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        imm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2093.
    return v7;
}

// Generated as internal constructor for term alu_ruimm32_with_flags_paired.
pub fn constructor_alu_ruimm32_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: u32,
) -> ProducesFlags {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRUImm32 {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        imm: arg3,
    };
    let v6 = C::writable_reg_to_reg(ctx, v4);
    let v7 = ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
        inst: v5,
        result: v6,
    };
    // Rule at src\isa\s390x\inst.isle line 2100.
    return v7;
}

// Generated as internal constructor for term alu_ruimm16shifted.
pub fn constructor_alu_ruimm16shifted<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: UImm16Shifted,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRUImm16Shifted {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        imm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2107.
    return v7;
}

// Generated as internal constructor for term alu_ruimm32shifted.
pub fn constructor_alu_ruimm32shifted<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: UImm32Shifted,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AluRUImm32Shifted {
        alu_op: arg1.clone(),
        rd: v4,
        ri: arg2,
        imm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2114.
    return v7;
}

// Generated as internal constructor for term smul_wide.
pub fn constructor_smul_wide<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> RegPair {
    let v3 = constructor_temp_writable_regpair(ctx, I64);
    let v4 = MInst::SMulWide {
        rd: v3,
        rn: arg0,
        rm: arg1,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2121.
    return v6;
}

// Generated as internal constructor for term umul_wide.
pub fn constructor_umul_wide<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> RegPair {
    let v3 = constructor_temp_writable_regpair(ctx, I64);
    let v4 = MInst::UMulWide {
        rd: v3,
        ri: arg0,
        rn: arg1,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2128.
    return v6;
}

// Generated as internal constructor for term sdivmod32.
pub fn constructor_sdivmod32<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> RegPair {
    let v3 = constructor_temp_writable_regpair(ctx, I64);
    let v4 = MInst::SDivMod32 {
        rd: v3,
        ri: arg0,
        rn: arg1,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2135.
    return v6;
}

// Generated as internal constructor for term sdivmod64.
pub fn constructor_sdivmod64<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> RegPair {
    let v3 = constructor_temp_writable_regpair(ctx, I64);
    let v4 = MInst::SDivMod64 {
        rd: v3,
        ri: arg0,
        rn: arg1,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2142.
    return v6;
}

// Generated as internal constructor for term udivmod32.
pub fn constructor_udivmod32<C: Context>(
    ctx: &mut C,
    arg0: RegPair,
    arg1: Reg,
) -> RegPair {
    let v3 = constructor_temp_writable_regpair(ctx, I64);
    let v4 = MInst::UDivMod32 {
        rd: v3,
        ri: arg0,
        rn: arg1,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2149.
    return v6;
}

// Generated as internal constructor for term udivmod64.
pub fn constructor_udivmod64<C: Context>(
    ctx: &mut C,
    arg0: RegPair,
    arg1: Reg,
) -> RegPair {
    let v3 = constructor_temp_writable_regpair(ctx, I64);
    let v4 = MInst::UDivMod64 {
        rd: v3,
        ri: arg0,
        rn: arg1,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2156.
    return v6;
}

// Generated as internal constructor for term shift_rr.
pub fn constructor_shift_rr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ShiftOp,
    arg2: Reg,
    arg3: u8,
    arg4: Reg,
) -> Reg {
    let v5 = C::temp_writable_reg(ctx, arg0);
    let v6 = MInst::ShiftRR {
        shift_op: arg1.clone(),
        rd: v5,
        rn: arg2,
        shift_imm: arg3,
        shift_reg: arg4,
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::writable_reg_to_reg(ctx, v5);
    // Rule at src\isa\s390x\inst.isle line 2163.
    return v8;
}

// Generated as internal constructor for term rxsbg_test.
pub fn constructor_rxsbg_test<C: Context>(
    ctx: &mut C,
    arg0: &RxSBGOp,
    arg1: Reg,
    arg2: Reg,
    arg3: u8,
    arg4: u8,
    arg5: i8,
) -> ProducesFlags {
    let v6 = MInst::RxSBGTest {
        op: arg0.clone(),
        rd: arg1,
        rn: arg2,
        start_bit: arg3,
        end_bit: arg4,
        rotate_amt: arg5,
    };
    let v7 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v6,
    };
    // Rule at src\isa\s390x\inst.isle line 2170.
    return v7;
}

// Generated as internal constructor for term unary_rr.
pub fn constructor_unary_rr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &UnaryOp,
    arg2: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, arg0);
    let v4 = MInst::UnaryRR {
        op: arg1.clone(),
        rd: v3,
        rn: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2176.
    return v6;
}

// Generated as internal constructor for term cmp_rr.
pub fn constructor_cmp_rr<C: Context>(
    ctx: &mut C,
    arg0: &CmpOp,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v3 = MInst::CmpRR {
        op: arg0.clone(),
        rn: arg1,
        rm: arg2,
    };
    let v4 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v3,
    };
    // Rule at src\isa\s390x\inst.isle line 2183.
    return v4;
}

// Generated as internal constructor for term cmp_rx.
pub fn constructor_cmp_rx<C: Context>(
    ctx: &mut C,
    arg0: &CmpOp,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = MInst::CmpRX {
        op: arg0.clone(),
        rn: arg1,
        mem: arg2.clone(),
    };
    let v4 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v3,
    };
    // Rule at src\isa\s390x\inst.isle line 2188.
    return v4;
}

// Generated as internal constructor for term cmp_rsimm16.
pub fn constructor_cmp_rsimm16<C: Context>(
    ctx: &mut C,
    arg0: &CmpOp,
    arg1: Reg,
    arg2: i16,
) -> ProducesFlags {
    let v3 = MInst::CmpRSImm16 {
        op: arg0.clone(),
        rn: arg1,
        imm: arg2,
    };
    let v4 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v3,
    };
    // Rule at src\isa\s390x\inst.isle line 2193.
    return v4;
}

// Generated as internal constructor for term cmp_rsimm32.
pub fn constructor_cmp_rsimm32<C: Context>(
    ctx: &mut C,
    arg0: &CmpOp,
    arg1: Reg,
    arg2: i32,
) -> ProducesFlags {
    let v3 = MInst::CmpRSImm32 {
        op: arg0.clone(),
        rn: arg1,
        imm: arg2,
    };
    let v4 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v3,
    };
    // Rule at src\isa\s390x\inst.isle line 2198.
    return v4;
}

// Generated as internal constructor for term cmp_ruimm32.
pub fn constructor_cmp_ruimm32<C: Context>(
    ctx: &mut C,
    arg0: &CmpOp,
    arg1: Reg,
    arg2: u32,
) -> ProducesFlags {
    let v3 = MInst::CmpRUImm32 {
        op: arg0.clone(),
        rn: arg1,
        imm: arg2,
    };
    let v4 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v3,
    };
    // Rule at src\isa\s390x\inst.isle line 2203.
    return v4;
}

// Generated as internal constructor for term atomic_rmw_impl.
pub fn constructor_atomic_rmw_impl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ALUOp,
    arg2: Reg,
    arg3: &MemArg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::AtomicRmw {
        alu_op: arg1.clone(),
        rd: v4,
        rn: arg2,
        mem: arg3.clone(),
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2208.
    return v7;
}

// Generated as internal constructor for term atomic_cas32.
pub fn constructor_atomic_cas32<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, I32);
    let v5 = MInst::AtomicCas32 {
        rd: v4,
        ri: arg0,
        rn: arg1,
        mem: arg2.clone(),
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2215.
    return v7;
}

// Generated as internal constructor for term atomic_cas64.
pub fn constructor_atomic_cas64<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, I64);
    let v5 = MInst::AtomicCas64 {
        rd: v4,
        ri: arg0,
        rn: arg1,
        mem: arg2.clone(),
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2222.
    return v7;
}

// Generated as internal constructor for term fence_impl.
pub fn constructor_fence_impl<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = SideEffectNoResult::Inst {
        inst: MInst::Fence,
    };
    // Rule at src\isa\s390x\inst.isle line 2229.
    return v1;
}

// Generated as internal constructor for term load32.
pub fn constructor_load32<C: Context>(
    ctx: &mut C,
    arg0: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I32);
    let v3 = MInst::Load32 {
        rd: v2,
        mem: arg0.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2234.
    return v5;
}

// Generated as internal constructor for term load64.
pub fn constructor_load64<C: Context>(
    ctx: &mut C,
    arg0: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I64);
    let v3 = MInst::Load64 {
        rd: v2,
        mem: arg0.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2241.
    return v5;
}

// Generated as internal constructor for term loadrev16.
pub fn constructor_loadrev16<C: Context>(
    ctx: &mut C,
    arg0: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I32);
    let v3 = MInst::LoadRev16 {
        rd: v2,
        mem: arg0.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2248.
    return v5;
}

// Generated as internal constructor for term loadrev32.
pub fn constructor_loadrev32<C: Context>(
    ctx: &mut C,
    arg0: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I32);
    let v3 = MInst::LoadRev32 {
        rd: v2,
        mem: arg0.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2255.
    return v5;
}

// Generated as internal constructor for term loadrev64.
pub fn constructor_loadrev64<C: Context>(
    ctx: &mut C,
    arg0: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I64);
    let v3 = MInst::LoadRev64 {
        rd: v2,
        mem: arg0.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2262.
    return v5;
}

// Generated as internal constructor for term store8.
pub fn constructor_store8<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::Store8 {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2269.
    return v3;
}

// Generated as internal constructor for term store16.
pub fn constructor_store16<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::Store16 {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2274.
    return v3;
}

// Generated as internal constructor for term store32.
pub fn constructor_store32<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::Store32 {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2279.
    return v3;
}

// Generated as internal constructor for term store64.
pub fn constructor_store64<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::Store64 {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2284.
    return v3;
}

// Generated as internal constructor for term store8_imm.
pub fn constructor_store8_imm<C: Context>(
    ctx: &mut C,
    arg0: u8,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::StoreImm8 {
        imm: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2289.
    return v3;
}

// Generated as internal constructor for term store16_imm.
pub fn constructor_store16_imm<C: Context>(
    ctx: &mut C,
    arg0: i16,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::StoreImm16 {
        imm: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2294.
    return v3;
}

// Generated as internal constructor for term store32_simm16.
pub fn constructor_store32_simm16<C: Context>(
    ctx: &mut C,
    arg0: i16,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::StoreImm32SExt16 {
        imm: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2299.
    return v3;
}

// Generated as internal constructor for term store64_simm16.
pub fn constructor_store64_simm16<C: Context>(
    ctx: &mut C,
    arg0: i16,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::StoreImm64SExt16 {
        imm: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2304.
    return v3;
}

// Generated as internal constructor for term storerev16.
pub fn constructor_storerev16<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::StoreRev16 {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2309.
    return v3;
}

// Generated as internal constructor for term storerev32.
pub fn constructor_storerev32<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::StoreRev32 {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2314.
    return v3;
}

// Generated as internal constructor for term storerev64.
pub fn constructor_storerev64<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::StoreRev64 {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2319.
    return v3;
}

// Generated as internal constructor for term load_ar.
pub fn constructor_load_ar<C: Context>(
    ctx: &mut C,
    arg0: u8,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I64);
    let v3 = MInst::LoadAR {
        rd: v2,
        ar: arg0,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2324.
    return v5;
}

// Generated as internal constructor for term insert_ar.
pub fn constructor_insert_ar<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: u8,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, I64);
    let v4 = MInst::InsertAR {
        rd: v3,
        ri: arg0,
        ar: arg1,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2331.
    return v6;
}

// Generated as internal constructor for term fpu_rr.
pub fn constructor_fpu_rr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FPUOp1,
    arg2: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, arg0);
    let v4 = MInst::FpuRR {
        fpu_op: arg1.clone(),
        rd: v3,
        rn: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2338.
    return v6;
}

// Generated as internal constructor for term fpu_rrr.
pub fn constructor_fpu_rrr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FPUOp2,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::FpuRRR {
        fpu_op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2345.
    return v7;
}

// Generated as internal constructor for term fpu_rrrr.
pub fn constructor_fpu_rrrr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FPUOp3,
    arg2: Reg,
    arg3: Reg,
    arg4: Reg,
) -> Reg {
    let v5 = C::temp_writable_reg(ctx, arg0);
    let v6 = MInst::FpuRRRR {
        fpu_op: arg1.clone(),
        rd: v5,
        rn: arg2,
        rm: arg3,
        ra: arg4,
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::writable_reg_to_reg(ctx, v5);
    // Rule at src\isa\s390x\inst.isle line 2352.
    return v8;
}

// Generated as internal constructor for term fpu_cmp32.
pub fn constructor_fpu_cmp32<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> ProducesFlags {
    let v2 = MInst::FpuCmp32 {
        rn: arg0,
        rm: arg1,
    };
    let v3 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2359.
    return v3;
}

// Generated as internal constructor for term fpu_cmp64.
pub fn constructor_fpu_cmp64<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> ProducesFlags {
    let v2 = MInst::FpuCmp64 {
        rn: arg0,
        rm: arg1,
    };
    let v3 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2364.
    return v3;
}

// Generated as internal constructor for term fpu_cmp128.
pub fn constructor_fpu_cmp128<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> ProducesFlags {
    let v2 = MInst::FpuCmp128 {
        rn: arg0,
        rm: arg1,
    };
    let v3 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2369.
    return v3;
}

// Generated as internal constructor for term fpu_round.
pub fn constructor_fpu_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FpuRoundOp,
    arg2: &FpuRoundMode,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::FpuRound {
        op: arg1.clone(),
        mode: arg2.clone(),
        rd: v4,
        rn: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2374.
    return v7;
}

// Generated as internal constructor for term fpu_conv128_from_int.
pub fn constructor_fpu_conv128_from_int<C: Context>(
    ctx: &mut C,
    arg0: &FpuConv128Op,
    arg1: &FpuRoundMode,
    arg2: Reg,
) -> RegPair {
    let v4 = constructor_temp_writable_regpair(ctx, F64);
    let v5 = MInst::FpuConv128FromInt {
        op: arg0.clone(),
        mode: arg1.clone(),
        rd: v4,
        rn: arg2,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = constructor_writable_regpair_to_regpair(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2381.
    return v7;
}

// Generated as internal constructor for term fpu_conv128_to_int.
pub fn constructor_fpu_conv128_to_int<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FpuConv128Op,
    arg2: &FpuRoundMode,
    arg3: RegPair,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::FpuConv128ToInt {
        op: arg1.clone(),
        mode: arg2.clone(),
        rd: v4,
        rn: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2388.
    return v7;
}

// Generated as internal constructor for term vec_rrr.
pub fn constructor_vec_rrr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &VecBinaryOp,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::VecRRR {
        op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2395.
    return v7;
}

// Generated as internal constructor for term vec_rr.
pub fn constructor_vec_rr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &VecUnaryOp,
    arg2: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, arg0);
    let v4 = MInst::VecRR {
        op: arg1.clone(),
        rd: v3,
        rn: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2402.
    return v6;
}

// Generated as internal constructor for term vec_shift_rr.
pub fn constructor_vec_shift_rr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &VecShiftOp,
    arg2: Reg,
    arg3: u8,
    arg4: Reg,
) -> Reg {
    let v5 = C::temp_writable_reg(ctx, arg0);
    let v6 = MInst::VecShiftRR {
        shift_op: arg1.clone(),
        rd: v5,
        rn: arg2,
        shift_imm: arg3,
        shift_reg: arg4,
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::writable_reg_to_reg(ctx, v5);
    // Rule at src\isa\s390x\inst.isle line 2409.
    return v8;
}

// Generated as internal constructor for term vec_select.
pub fn constructor_vec_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::VecSelect {
        rd: v4,
        rn: arg1,
        rm: arg2,
        ra: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2416.
    return v7;
}

// Generated as internal constructor for term vec_permute.
pub fn constructor_vec_permute<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::VecPermute {
        rd: v4,
        rn: arg1,
        rm: arg2,
        ra: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2423.
    return v7;
}

// Generated as internal constructor for term vec_permute_dw_imm.
pub fn constructor_vec_permute_dw_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
    arg3: Reg,
    arg4: u8,
) -> Reg {
    let v5 = C::temp_writable_reg(ctx, arg0);
    let v6 = MInst::VecPermuteDWImm {
        rd: v5,
        rn: arg1,
        rm: arg3,
        idx1: arg2,
        idx2: arg4,
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::writable_reg_to_reg(ctx, v5);
    // Rule at src\isa\s390x\inst.isle line 2430.
    return v8;
}

// Generated as internal constructor for term vec_int_cmp.
pub fn constructor_vec_int_cmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &VecIntCmpOp,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::VecIntCmp {
        op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2437.
    return v7;
}

// Generated as internal constructor for term vec_int_cmps.
pub fn constructor_vec_int_cmps<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &VecIntCmpOp,
    arg2: Reg,
    arg3: Reg,
) -> ProducesFlags {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::VecIntCmpS {
        op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v5,
    };
    // Rule at src\isa\s390x\inst.isle line 2444.
    return v6;
}

// Generated as internal constructor for term vec_float_cmp.
pub fn constructor_vec_float_cmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &VecFloatCmpOp,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::VecFloatCmp {
        op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = C::emit(ctx, &v5);
    let v7 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\inst.isle line 2450.
    return v7;
}

// Generated as internal constructor for term vec_float_cmps.
pub fn constructor_vec_float_cmps<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &VecFloatCmpOp,
    arg2: Reg,
    arg3: Reg,
) -> ProducesFlags {
    let v4 = C::temp_writable_reg(ctx, arg0);
    let v5 = MInst::VecFloatCmpS {
        op: arg1.clone(),
        rd: v4,
        rn: arg2,
        rm: arg3,
    };
    let v6 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v5,
    };
    // Rule at src\isa\s390x\inst.isle line 2457.
    return v6;
}

// Generated as internal constructor for term vec_int128_scmphi.
pub fn constructor_vec_int128_scmphi<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> ProducesBool {
    let v3 = C::temp_writable_reg(ctx, I128);
    let v7 = &C::mask_as_cond(ctx, 0x4_u8);
    let v4 = MInst::VecInt128SCmpHi {
        tmp: v3,
        rn: arg0,
        rm: arg1,
    };
    let v5 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v4,
    };
    let v8 = &constructor_bool(ctx, &v5, v7);
    // Rule at src\isa\s390x\inst.isle line 2463.
    return v8.clone();
}

// Generated as internal constructor for term vec_int128_ucmphi.
pub fn constructor_vec_int128_ucmphi<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> ProducesBool {
    let v3 = C::temp_writable_reg(ctx, I128);
    let v7 = &C::mask_as_cond(ctx, 0x4_u8);
    let v4 = MInst::VecInt128UCmpHi {
        tmp: v3,
        rn: arg0,
        rm: arg1,
    };
    let v5 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v4,
    };
    let v8 = &constructor_bool(ctx, &v5, v7);
    // Rule at src\isa\s390x\inst.isle line 2470.
    return v8.clone();
}

// Generated as internal constructor for term vec_load.
pub fn constructor_vec_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoad {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2477.
    return v5;
}

// Generated as internal constructor for term vec_loadrev.
pub fn constructor_vec_loadrev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoadRev {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2484.
    return v5;
}

// Generated as internal constructor for term vec_load_byte16rev.
pub fn constructor_vec_load_byte16rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoadByte16Rev {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2491.
    return v5;
}

// Generated as internal constructor for term vec_load_byte32rev.
pub fn constructor_vec_load_byte32rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoadByte32Rev {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2498.
    return v5;
}

// Generated as internal constructor for term vec_load_byte64rev.
pub fn constructor_vec_load_byte64rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoadByte64Rev {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2505.
    return v5;
}

// Generated as internal constructor for term vec_load_elt16rev.
pub fn constructor_vec_load_elt16rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoadElt16Rev {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2512.
    return v5;
}

// Generated as internal constructor for term vec_load_elt32rev.
pub fn constructor_vec_load_elt32rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoadElt32Rev {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2519.
    return v5;
}

// Generated as internal constructor for term vec_load_elt64rev.
pub fn constructor_vec_load_elt64rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, arg0);
    let v3 = MInst::VecLoadElt64Rev {
        rd: v2,
        mem: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2526.
    return v5;
}

// Generated as internal constructor for term vec_store.
pub fn constructor_vec_store<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStore {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2533.
    return v3;
}

// Generated as internal constructor for term vec_storerev.
pub fn constructor_vec_storerev<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStoreRev {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2538.
    return v3;
}

// Generated as internal constructor for term vec_store_byte16rev.
pub fn constructor_vec_store_byte16rev<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStoreByte16Rev {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2543.
    return v3;
}

// Generated as internal constructor for term vec_store_byte32rev.
pub fn constructor_vec_store_byte32rev<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStoreByte32Rev {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2548.
    return v3;
}

// Generated as internal constructor for term vec_store_byte64rev.
pub fn constructor_vec_store_byte64rev<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStoreByte64Rev {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2553.
    return v3;
}

// Generated as internal constructor for term vec_store_elt16rev.
pub fn constructor_vec_store_elt16rev<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStoreElt16Rev {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2558.
    return v3;
}

// Generated as internal constructor for term vec_store_elt32rev.
pub fn constructor_vec_store_elt32rev<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStoreElt32Rev {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2563.
    return v3;
}

// Generated as internal constructor for term vec_store_elt64rev.
pub fn constructor_vec_store_elt64rev<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: &MemArg,
) -> SideEffectNoResult {
    let v2 = MInst::VecStoreElt64Rev {
        rd: arg0,
        mem: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2568.
    return v3;
}

// Generated as internal constructor for term vec_load_replicate.
pub fn constructor_vec_load_replicate<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::multi_lane(ctx, v2);
        if let Some(v4) = v3 {
            let v8 = C::temp_writable_reg(ctx, v2);
            let v9 = MInst::VecLoadReplicate {
                size: v4.0,
                rd: v8,
                mem: arg1.clone(),
            };
            let v10 = C::emit(ctx, &v9);
            let v11 = C::writable_reg_to_reg(ctx, v8);
            // Rule at src\isa\s390x\inst.isle line 2573.
            return v11;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_replicate", "src\\isa\\s390x\\inst.isle line 2572")
}

// Generated as internal constructor for term vec_load_replicate_rev.
pub fn constructor_vec_load_replicate_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::multi_lane(ctx, v2);
        if let Some(v4) = v3 {
            let v8 = C::temp_writable_reg(ctx, v2);
            let v9 = MInst::VecLoadReplicateRev {
                size: v4.0,
                rd: v8,
                mem: arg1.clone(),
            };
            let v10 = C::emit(ctx, &v9);
            let v11 = C::writable_reg_to_reg(ctx, v8);
            // Rule at src\isa\s390x\inst.isle line 2580.
            return v11;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_replicate_rev", "src\\isa\\s390x\\inst.isle line 2579")
}

// Generated as internal constructor for term mov_to_vec128.
pub fn constructor_mov_to_vec128<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, arg0);
    let v4 = MInst::MovToVec128 {
        rd: v3,
        rn: arg1,
        rm: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 2587.
    return v6;
}

// Generated as internal constructor for term vec_imm_byte_mask.
pub fn constructor_vec_imm_byte_mask<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u16,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v4 = C::temp_writable_reg(ctx, v2);
        let v5 = MInst::VecImmByteMask {
            rd: v4,
            mask: arg1,
        };
        let v6 = C::emit(ctx, &v5);
        let v7 = C::writable_reg_to_reg(ctx, v4);
        // Rule at src\isa\s390x\inst.isle line 2594.
        return v7;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_imm_byte_mask", "src\\isa\\s390x\\inst.isle line 2593")
}

// Generated as internal constructor for term vec_imm_bit_mask.
pub fn constructor_vec_imm_bit_mask<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u8,
    arg2: u8,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::multi_lane(ctx, v2);
        if let Some(v4) = v3 {
            let v9 = C::temp_writable_reg(ctx, v2);
            let v10 = MInst::VecImmBitMask {
                size: v4.0,
                rd: v9,
                start_bit: arg1,
                end_bit: arg2,
            };
            let v11 = C::emit(ctx, &v10);
            let v12 = C::writable_reg_to_reg(ctx, v9);
            // Rule at src\isa\s390x\inst.isle line 2601.
            return v12;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_imm_bit_mask", "src\\isa\\s390x\\inst.isle line 2600")
}

// Generated as internal constructor for term vec_imm_replicate.
pub fn constructor_vec_imm_replicate<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: i16,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::multi_lane(ctx, v2);
        if let Some(v4) = v3 {
            let v8 = C::temp_writable_reg(ctx, v2);
            let v9 = MInst::VecImmReplicate {
                size: v4.0,
                rd: v8,
                imm: arg1,
            };
            let v10 = C::emit(ctx, &v9);
            let v11 = C::writable_reg_to_reg(ctx, v8);
            // Rule at src\isa\s390x\inst.isle line 2608.
            return v11;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_imm_replicate", "src\\isa\\s390x\\inst.isle line 2607")
}

// Generated as internal constructor for term vec_load_lane.
pub fn constructor_vec_load_lane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
    arg3: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v8 = C::temp_writable_reg(ctx, arg0);
        let v9 = MInst::VecLoadLane {
            size: v2.0,
            rd: v8,
            ri: arg1,
            mem: arg2.clone(),
            lane_imm: arg3,
        };
        let v10 = C::emit(ctx, &v9);
        let v11 = C::writable_reg_to_reg(ctx, v8);
        // Rule at src\isa\s390x\inst.isle line 2615.
        return v11;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_lane", "src\\isa\\s390x\\inst.isle line 2614")
}

// Generated as internal constructor for term vec_load_lane_undef.
pub fn constructor_vec_load_lane_undef<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
    arg2: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v7 = C::temp_writable_reg(ctx, arg0);
        let v8 = MInst::VecLoadLaneUndef {
            size: v2.0,
            rd: v7,
            mem: arg1.clone(),
            lane_imm: arg2,
        };
        let v9 = C::emit(ctx, &v8);
        let v10 = C::writable_reg_to_reg(ctx, v7);
        // Rule at src\isa\s390x\inst.isle line 2622.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_lane_undef", "src\\isa\\s390x\\inst.isle line 2621")
}

// Generated as internal constructor for term vec_load_lane_rev.
pub fn constructor_vec_load_lane_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
    arg3: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v8 = C::temp_writable_reg(ctx, arg0);
        let v9 = MInst::VecLoadLaneRev {
            size: v2.0,
            rd: v8,
            ri: arg1,
            mem: arg2.clone(),
            lane_imm: arg3,
        };
        let v10 = C::emit(ctx, &v9);
        let v11 = C::writable_reg_to_reg(ctx, v8);
        // Rule at src\isa\s390x\inst.isle line 2629.
        return v11;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_lane_rev", "src\\isa\\s390x\\inst.isle line 2628")
}

// Generated as internal constructor for term vec_load_lane_rev_undef.
pub fn constructor_vec_load_lane_rev_undef<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
    arg2: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v7 = C::temp_writable_reg(ctx, arg0);
        let v8 = MInst::VecLoadLaneRevUndef {
            size: v2.0,
            rd: v7,
            mem: arg1.clone(),
            lane_imm: arg2,
        };
        let v9 = C::emit(ctx, &v8);
        let v10 = C::writable_reg_to_reg(ctx, v7);
        // Rule at src\isa\s390x\inst.isle line 2636.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_lane_rev_undef", "src\\isa\\s390x\\inst.isle line 2635")
}

// Generated as internal constructor for term vec_store_lane.
pub fn constructor_vec_store_lane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
    arg3: u8,
) -> SideEffectNoResult {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v8 = MInst::VecStoreLane {
            size: v2.0,
            rd: arg1,
            mem: arg2.clone(),
            lane_imm: arg3,
        };
        let v9 = SideEffectNoResult::Inst {
            inst: v8,
        };
        // Rule at src\isa\s390x\inst.isle line 2643.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_store_lane", "src\\isa\\s390x\\inst.isle line 2642")
}

// Generated as internal constructor for term vec_store_lane_rev.
pub fn constructor_vec_store_lane_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
    arg3: u8,
) -> SideEffectNoResult {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v8 = MInst::VecStoreLaneRev {
            size: v2.0,
            rd: arg1,
            mem: arg2.clone(),
            lane_imm: arg3,
        };
        let v9 = SideEffectNoResult::Inst {
            inst: v8,
        };
        // Rule at src\isa\s390x\inst.isle line 2648.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_store_lane_rev", "src\\isa\\s390x\\inst.isle line 2647")
}

// Generated as internal constructor for term vec_insert_lane.
pub fn constructor_vec_insert_lane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: u8,
    arg4: Reg,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v9 = C::temp_writable_reg(ctx, arg0);
        let v10 = MInst::VecInsertLane {
            size: v2.0,
            rd: v9,
            ri: arg1,
            rn: arg2,
            lane_imm: arg3,
            lane_reg: arg4,
        };
        let v11 = C::emit(ctx, &v10);
        let v12 = C::writable_reg_to_reg(ctx, v9);
        // Rule at src\isa\s390x\inst.isle line 2653.
        return v12;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_insert_lane", "src\\isa\\s390x\\inst.isle line 2652")
}

// Generated as internal constructor for term vec_insert_lane_undef.
pub fn constructor_vec_insert_lane_undef<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
    arg3: Reg,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v8 = C::temp_writable_reg(ctx, arg0);
        let v9 = MInst::VecInsertLaneUndef {
            size: v2.0,
            rd: v8,
            rn: arg1,
            lane_imm: arg2,
            lane_reg: arg3,
        };
        let v10 = C::emit(ctx, &v9);
        let v11 = C::writable_reg_to_reg(ctx, v8);
        // Rule at src\isa\s390x\inst.isle line 2660.
        return v11;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_insert_lane_undef", "src\\isa\\s390x\\inst.isle line 2659")
}

// Generated as internal constructor for term vec_extract_lane.
pub fn constructor_vec_extract_lane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
    arg3: Reg,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v9 = C::temp_writable_reg(ctx, I64);
        let v10 = MInst::VecExtractLane {
            size: v2.0,
            rd: v9,
            rn: arg1,
            lane_imm: arg2,
            lane_reg: arg3,
        };
        let v11 = C::emit(ctx, &v10);
        let v12 = C::writable_reg_to_reg(ctx, v9);
        // Rule at src\isa\s390x\inst.isle line 2667.
        return v12;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_extract_lane", "src\\isa\\s390x\\inst.isle line 2666")
}

// Generated as internal constructor for term vec_insert_lane_imm.
pub fn constructor_vec_insert_lane_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i16,
    arg3: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v8 = C::temp_writable_reg(ctx, arg0);
        let v9 = MInst::VecInsertLaneImm {
            size: v2.0,
            rd: v8,
            ri: arg1,
            imm: arg2,
            lane_imm: arg3,
        };
        let v10 = C::emit(ctx, &v9);
        let v11 = C::writable_reg_to_reg(ctx, v8);
        // Rule at src\isa\s390x\inst.isle line 2674.
        return v11;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_insert_lane_imm", "src\\isa\\s390x\\inst.isle line 2673")
}

// Generated as internal constructor for term vec_insert_lane_imm_undef.
pub fn constructor_vec_insert_lane_imm_undef<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: i16,
    arg2: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v7 = C::temp_writable_reg(ctx, arg0);
        let v8 = MInst::VecInsertLaneImmUndef {
            size: v2.0,
            rd: v7,
            imm: arg1,
            lane_imm: arg2,
        };
        let v9 = C::emit(ctx, &v8);
        let v10 = C::writable_reg_to_reg(ctx, v7);
        // Rule at src\isa\s390x\inst.isle line 2681.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_insert_lane_imm_undef", "src\\isa\\s390x\\inst.isle line 2680")
}

// Generated as internal constructor for term vec_replicate_lane.
pub fn constructor_vec_replicate_lane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v7 = C::temp_writable_reg(ctx, arg0);
        let v8 = MInst::VecReplicateLane {
            size: v2.0,
            rd: v7,
            rn: arg1,
            lane_imm: arg2,
        };
        let v9 = C::emit(ctx, &v8);
        let v10 = C::writable_reg_to_reg(ctx, v7);
        // Rule at src\isa\s390x\inst.isle line 2688.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_replicate_lane", "src\\isa\\s390x\\inst.isle line 2687")
}

// Generated as internal constructor for term vec_elt_rev.
pub fn constructor_vec_elt_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = C::temp_writable_reg(ctx, arg0);
        let v7 = MInst::VecEltRev {
            lane_count: v2.1,
            rd: v6,
            rn: arg1,
        };
        let v8 = C::emit(ctx, &v7);
        let v9 = C::writable_reg_to_reg(ctx, v6);
        // Rule at src\isa\s390x\inst.isle line 2695.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_elt_rev", "src\\isa\\s390x\\inst.isle line 2694")
}

// Generated as internal constructor for term load_symbol_reloc.
pub fn constructor_load_symbol_reloc<C: Context>(
    ctx: &mut C,
    arg0: &SymbolReloc,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I64);
    let v3 = C::box_symbol_reloc(ctx, arg0);
    let v4 = MInst::LoadSymbolReloc {
        rd: v2,
        symbol_reloc: v3,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2702.
    return v6;
}

// Generated as internal constructor for term load_addr.
pub fn constructor_load_addr<C: Context>(
    ctx: &mut C,
    arg0: &MemArg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I64);
    let v3 = MInst::LoadAddr {
        rd: v2,
        mem: arg0.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2709.
    return v5;
}

// Generated as internal constructor for term call_impl.
pub fn constructor_call_impl<C: Context>(
    ctx: &mut C,
    arg0: WritableReg,
    arg1: BoxCallInfo,
) -> SideEffectNoResult {
    let v2 = MInst::Call {
        link: arg0,
        info: arg1,
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2716.
    return v3;
}

// Generated as internal constructor for term patchable_call_impl.
pub fn constructor_patchable_call_impl<C: Context>(
    ctx: &mut C,
    arg0: WritableReg,
    arg1: BoxCallInfo,
) -> SideEffectNoResult {
    let v2 = MInst::PatchableCall {
        link: arg0,
        info: arg1,
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 2721.
    return v3;
}

// Generated as internal constructor for term return_call_impl.
pub fn constructor_return_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxReturnCallInfo,
) -> SideEffectNoResult {
    let v1 = MInst::ReturnCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\s390x\inst.isle line 2726.
    return v2;
}

// Generated as internal constructor for term jump_impl.
pub fn constructor_jump_impl<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
) -> SideEffectNoResult {
    let v1 = MInst::Jump {
        dest: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\s390x\inst.isle line 2731.
    return v2;
}

// Generated as internal constructor for term cond_br.
pub fn constructor_cond_br<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
    arg1: MachLabel,
    arg2: &Cond,
) -> ConsumesFlags {
    let v3 = MInst::CondBr {
        taken: arg0,
        not_taken: arg1,
        cond: arg2.clone(),
    };
    let v4 = ConsumesFlags::ConsumesFlagsSideEffect {
        inst: v3,
    };
    // Rule at src\isa\s390x\inst.isle line 2736.
    return v4;
}

// Generated as internal constructor for term jt_sequence.
pub fn constructor_jt_sequence<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: MachLabel,
    arg2: &Cond,
    arg3: &BoxVecMachLabel,
) -> ConsumesFlags {
    let v4 = MInst::JTSequence {
        ridx: arg0,
        default: arg1,
        default_cond: arg2.clone(),
        targets: arg3.clone(),
    };
    let v5 = ConsumesFlags::ConsumesFlagsSideEffect {
        inst: v4,
    };
    // Rule at src\isa\s390x\inst.isle line 2741.
    return v5;
}

// Generated as internal constructor for term jt_sequence_default_bool.
pub fn constructor_jt_sequence_default_bool<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: MachLabel,
    arg2: &ProducesBool,
    arg3: &BoxVecMachLabel,
) -> SideEffectNoResult {
    if let &ProducesBool::ProducesBool {
        producer: ref v3,
        cond: ref v4,
    } = arg2 {
        let v6 = &constructor_jt_sequence(ctx, arg0, arg1, v4, arg3);
        let v7 = &constructor_with_flags_side_effect(ctx, v3, v6);
        // Rule at src\isa\s390x\inst.isle line 2747.
        return v7.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "jt_sequence_default_bool", "src\\isa\\s390x\\inst.isle line 2746")
}

// Generated as internal constructor for term push_alu_reg.
pub fn constructor_push_alu_reg<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: &ALUOp,
    arg2: WritableReg,
    arg3: Reg,
    arg4: Reg,
) -> Reg {
    let v3 = C::real_reg(ctx, arg2);
    if let Some(v4) = v3 {
        let v7 = MInst::AluRRR {
            alu_op: arg1.clone(),
            rd: v4,
            rn: arg3,
            rm: arg4,
        };
        let v8 = C::inst_builder_push(ctx, arg0, &v7);
        let v9 = C::writable_reg_to_reg(ctx, v4);
        // Rule at src\isa\s390x\inst.isle line 2786.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_alu_reg", "src\\isa\\s390x\\inst.isle line 2785")
}

// Generated as internal constructor for term push_alu_uimm32shifted.
pub fn constructor_push_alu_uimm32shifted<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: &ALUOp,
    arg2: WritableReg,
    arg3: Reg,
    arg4: UImm32Shifted,
) -> Reg {
    let v3 = C::real_reg(ctx, arg2);
    if let Some(v4) = v3 {
        let v7 = MInst::AluRUImm32Shifted {
            alu_op: arg1.clone(),
            rd: v4,
            ri: arg3,
            imm: arg4,
        };
        let v8 = C::inst_builder_push(ctx, arg0, &v7);
        let v9 = C::writable_reg_to_reg(ctx, v4);
        // Rule at src\isa\s390x\inst.isle line 2792.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_alu_uimm32shifted", "src\\isa\\s390x\\inst.isle line 2791")
}

// Generated as internal constructor for term push_shift.
pub fn constructor_push_shift<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: &ShiftOp,
    arg2: WritableReg,
    arg3: Reg,
    arg4: u8,
    arg5: Reg,
) -> Reg {
    let v3 = C::real_reg(ctx, arg2);
    if let Some(v4) = v3 {
        let v8 = MInst::ShiftRR {
            shift_op: arg1.clone(),
            rd: v4,
            rn: arg3,
            shift_imm: arg4,
            shift_reg: arg5,
        };
        let v9 = C::inst_builder_push(ctx, arg0, &v8);
        let v10 = C::writable_reg_to_reg(ctx, v4);
        // Rule at src\isa\s390x\inst.isle line 2798.
        return v10;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_shift", "src\\isa\\s390x\\inst.isle line 2797")
}

// Generated as internal constructor for term push_rxsbg.
pub fn constructor_push_rxsbg<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: &RxSBGOp,
    arg2: WritableReg,
    arg3: Reg,
    arg4: Reg,
    arg5: u8,
    arg6: u8,
    arg7: i8,
) -> Reg {
    let v3 = C::real_reg(ctx, arg2);
    if let Some(v4) = v3 {
        let v10 = C::same_reg(ctx, v4, arg3);
        if let Some(v11) = v10 {
            let v12 = MInst::RxSBG {
                op: arg1.clone(),
                rd: v4,
                ri: arg3,
                rn: arg4,
                start_bit: arg5,
                end_bit: arg6,
                rotate_amt: arg7,
            };
            let v13 = C::inst_builder_push(ctx, arg0, &v12);
            let v14 = C::writable_reg_to_reg(ctx, v4);
            // Rule at src\isa\s390x\inst.isle line 2805.
            return v14;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_rxsbg", "src\\isa\\s390x\\inst.isle line 2804")
}

// Generated as internal constructor for term push_unary.
pub fn constructor_push_unary<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: &UnaryOp,
    arg2: WritableReg,
    arg3: Reg,
) -> Reg {
    let v3 = C::real_reg(ctx, arg2);
    if let Some(v4) = v3 {
        let v6 = MInst::UnaryRR {
            op: arg1.clone(),
            rd: v4,
            rn: arg3,
        };
        let v7 = C::inst_builder_push(ctx, arg0, &v6);
        let v8 = C::writable_reg_to_reg(ctx, v4);
        // Rule at src\isa\s390x\inst.isle line 2813.
        return v8;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_unary", "src\\isa\\s390x\\inst.isle line 2812")
}

// Generated as internal constructor for term push_atomic_cas32.
pub fn constructor_push_atomic_cas32<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: WritableReg,
    arg2: Reg,
    arg3: &MemArg,
) -> Reg {
    let v2 = C::real_reg(ctx, arg1);
    if let Some(v3) = v2 {
        let v6 = C::writable_reg_to_reg(ctx, v3);
        let v7 = MInst::AtomicCas32 {
            rd: v3,
            ri: v6,
            rn: arg2,
            mem: arg3.clone(),
        };
        let v8 = C::inst_builder_push(ctx, arg0, &v7);
        // Rule at src\isa\s390x\inst.isle line 2819.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_atomic_cas32", "src\\isa\\s390x\\inst.isle line 2818")
}

// Generated as internal constructor for term push_atomic_cas64.
pub fn constructor_push_atomic_cas64<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: WritableReg,
    arg2: Reg,
    arg3: &MemArg,
) -> Reg {
    let v2 = C::real_reg(ctx, arg1);
    if let Some(v3) = v2 {
        let v6 = C::writable_reg_to_reg(ctx, v3);
        let v7 = MInst::AtomicCas64 {
            rd: v3,
            ri: v6,
            rn: arg2,
            mem: arg3.clone(),
        };
        let v8 = C::inst_builder_push(ctx, arg0, &v7);
        // Rule at src\isa\s390x\inst.isle line 2825.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_atomic_cas64", "src\\isa\\s390x\\inst.isle line 2824")
}

// Generated as internal constructor for term push_break_if.
pub fn constructor_push_break_if<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: &ProducesFlags,
    arg2: &Cond,
) -> Reg {
    if let &ProducesFlags::ProducesFlagsSideEffect {
        inst: ref v2,
    } = arg1 {
        let v4 = C::inst_builder_push(ctx, arg0, v2);
        let v5 = MInst::CondBreak {
            cond: arg2.clone(),
        };
        let v6 = C::inst_builder_push(ctx, arg0, &v5);
        let v7 = C::invalid_reg(ctx);
        // Rule at src\isa\s390x\inst.isle line 2831.
        return v7;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_break_if", "src\\isa\\s390x\\inst.isle line 2830")
}

// Generated as internal constructor for term emit_loop.
pub fn constructor_emit_loop<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: &Cond,
) -> Unit {
    let v2 = C::inst_builder_finish(ctx, arg0);
    let v3 = MInst::Loop {
        body: v2,
        cond: arg1.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    // Rule at src\isa\s390x\inst.isle line 2838.
    return v4;
}

// Generated as internal constructor for term copy_reg.
pub fn constructor_copy_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v8 = C::gpr64_ty(ctx, arg0);
    if let Some(v9) = v8 {
        let v10 = C::temp_writable_reg(ctx, v9);
        let v11 = MInst::Mov64 {
            rd: v10,
            rm: arg1,
        };
        let v12 = C::emit(ctx, &v11);
        let v13 = C::writable_reg_to_reg(ctx, v10);
        // Rule at src\isa\s390x\inst.isle line 2850.
        return v13;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v4 = C::temp_writable_reg(ctx, v2);
        let v5 = MInst::Mov32 {
            rd: v4,
            rm: arg1,
        };
        let v6 = C::emit(ctx, &v5);
        let v7 = C::writable_reg_to_reg(ctx, v4);
        // Rule at src\isa\s390x\inst.isle line 2846.
        return v7;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "copy_reg", "src\\isa\\s390x\\inst.isle line 2845")
}

// Generated as internal constructor for term emit_load.
pub fn constructor_emit_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: WritableReg,
    arg2: &MemArg,
) -> Unit {
    match arg0 {
        I32 => {
            let v3 = MInst::Load32 {
                rd: arg1,
                mem: arg2.clone(),
            };
            let v4 = C::emit(ctx, &v3);
            // Rule at src\isa\s390x\inst.isle line 2857.
            return v4;
        }
        I64 => {
            let v5 = MInst::Load64 {
                rd: arg1,
                mem: arg2.clone(),
            };
            let v6 = C::emit(ctx, &v5);
            // Rule at src\isa\s390x\inst.isle line 2859.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_load", "src\\isa\\s390x\\inst.isle line 2856")
}

// Generated as internal constructor for term mov_preg.
pub fn constructor_mov_preg<C: Context>(
    ctx: &mut C,
    arg0: PReg,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I64);
    let v3 = MInst::MovPReg {
        rd: v2,
        rm: arg0,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 2864.
    return v5;
}

// Generated as internal constructor for term sp.
pub fn constructor_sp<C: Context>(
    ctx: &mut C,
) -> Reg {
    let v0 = C::preg_stack(ctx);
    let v1 = constructor_mov_preg(ctx, v0);
    // Rule at src\isa\s390x\inst.isle line 2877.
    return v1;
}

// Generated as internal constructor for term imm.
pub fn constructor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
) -> Reg {
    match arg0 {
        F16 => {
            let v7 = C::u64_truncate_into_u16(ctx, arg1);
            let v8 = C::u16_cast_signed(ctx, v7);
            let v56 = constructor_vec_insert_lane_imm_undef(ctx, F16X8, v8, 0x0_u8);
            // Rule at src\isa\s390x\inst.isle line 2952.
            return v56;
        }
        F32 => {
            let v24 = C::u64_truncate_into_u32(ctx, arg1);
            let v59 = C::u32_pair_concat(ctx, v24, 0x0_u32);
            let v60 = C::emit_u64_be_const(ctx, v59);
            let v61 = &C::memarg_const(ctx, v60);
            let v62 = constructor_vec_load_lane_undef(ctx, F32X4, v61, 0x0_u8);
            // Rule at src\isa\s390x\inst.isle line 2960.
            return v62;
        }
        F64 => {
            let v64 = C::emit_u64_be_const(ctx, arg1);
            let v65 = &C::memarg_const(ctx, v64);
            let v66 = constructor_vec_load_lane_undef(ctx, F64X2, v65, 0x0_u8);
            // Rule at src\isa\s390x\inst.isle line 2966.
            return v66;
        }
        _ => {}
    }
    let v1 = C::fits_in_16(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::ty_int(ctx, v2);
        if let Some(v4) = v3 {
            let v6 = C::temp_writable_reg(ctx, v4);
            let v7 = C::u64_truncate_into_u16(ctx, arg1);
            let v8 = C::u16_cast_signed(ctx, v7);
            let v9 = MInst::Mov32SImm16 {
                rd: v6,
                imm: v8,
            };
            let v10 = C::emit(ctx, &v9);
            let v11 = C::writable_reg_to_reg(ctx, v6);
            // Rule at src\isa\s390x\inst.isle line 2887.
            return v11;
        }
    }
    let v12 = C::gpr32_ty(ctx, arg0);
    if let Some(v13) = v12 {
        let v14 = C::u32_pair_split(ctx, arg1);
        let v17 = C::u32_cast_signed(ctx, v14.1);
        let v18 = C::i32_from_i16(ctx, v17);
        if let Some(v19) = v18 {
            let v20 = C::temp_writable_reg(ctx, v13);
            let v21 = MInst::Mov32SImm16 {
                rd: v20,
                imm: v19,
            };
            let v22 = C::emit(ctx, &v21);
            let v23 = C::writable_reg_to_reg(ctx, v20);
            // Rule at src\isa\s390x\inst.isle line 2893.
            return v23;
        }
        let v20 = C::temp_writable_reg(ctx, v13);
        let v24 = C::u64_truncate_into_u32(ctx, arg1);
        let v25 = MInst::Mov32Imm {
            rd: v20,
            imm: v24,
        };
        let v26 = C::emit(ctx, &v25);
        let v23 = C::writable_reg_to_reg(ctx, v20);
        // Rule at src\isa\s390x\inst.isle line 2900.
        return v23;
    }
    let v27 = C::gpr64_ty(ctx, arg0);
    if let Some(v28) = v27 {
        let v29 = C::u64_cast_signed(ctx, arg1);
        let v30 = C::i64_from_i16(ctx, v29);
        if let Some(v31) = v30 {
            let v32 = C::temp_writable_reg(ctx, v28);
            let v33 = MInst::Mov64SImm16 {
                rd: v32,
                imm: v31,
            };
            let v34 = C::emit(ctx, &v33);
            let v35 = C::writable_reg_to_reg(ctx, v32);
            // Rule at src\isa\s390x\inst.isle line 2906.
            return v35;
        }
        let v36 = C::i64_from_i32(ctx, v29);
        if let Some(v37) = v36 {
            let v32 = C::temp_writable_reg(ctx, v28);
            let v38 = MInst::Mov64SImm32 {
                rd: v32,
                imm: v37,
            };
            let v39 = C::emit(ctx, &v38);
            let v35 = C::writable_reg_to_reg(ctx, v32);
            // Rule at src\isa\s390x\inst.isle line 2913.
            return v35;
        }
        let v40 = C::uimm16shifted_from_u64(ctx, arg1);
        if let Some(v41) = v40 {
            let v32 = C::temp_writable_reg(ctx, v28);
            let v42 = MInst::Mov64UImm16Shifted {
                rd: v32,
                imm: v41,
            };
            let v43 = C::emit(ctx, &v42);
            let v35 = C::writable_reg_to_reg(ctx, v32);
            // Rule at src\isa\s390x\inst.isle line 2920.
            return v35;
        }
        let v44 = C::uimm32shifted_from_u64(ctx, arg1);
        if let Some(v45) = v44 {
            let v32 = C::temp_writable_reg(ctx, v28);
            let v46 = MInst::Mov64UImm32Shifted {
                rd: v32,
                imm: v45,
            };
            let v47 = C::emit(ctx, &v46);
            let v35 = C::writable_reg_to_reg(ctx, v32);
            // Rule at src\isa\s390x\inst.isle line 2926.
            return v35;
        }
        let v48 = C::u64_nonzero_hipart(ctx, arg1);
        if let Some(v49) = v48 {
            let v50 = C::u64_nonzero_lopart(ctx, arg1);
            if let Some(v51) = v50 {
                let v52 = constructor_imm(ctx, v28, v49);
                let v53 = constructor_insert_imm(ctx, v28, v52, v51);
                // Rule at src\isa\s390x\inst.isle line 2932.
                return v53;
            }
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "imm", "src\\isa\\s390x\\inst.isle line 2884")
}

// Generated as internal constructor for term insert_imm.
pub fn constructor_insert_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u64,
) -> Reg {
    let v3 = C::uimm16shifted_from_u64(ctx, arg2);
    if let Some(v4) = v3 {
        let v5 = C::temp_writable_reg(ctx, arg0);
        let v6 = MInst::Insert64UImm16Shifted {
            rd: v5,
            ri: arg1,
            imm: v4,
        };
        let v7 = C::emit(ctx, &v6);
        let v8 = C::writable_reg_to_reg(ctx, v5);
        // Rule at src\isa\s390x\inst.isle line 2940.
        return v8;
    }
    let v9 = C::uimm32shifted_from_u64(ctx, arg2);
    if let Some(v10) = v9 {
        let v5 = C::temp_writable_reg(ctx, arg0);
        let v11 = MInst::Insert64UImm32Shifted {
            rd: v5,
            ri: arg1,
            imm: v10,
        };
        let v12 = C::emit(ctx, &v11);
        let v8 = C::writable_reg_to_reg(ctx, v5);
        // Rule at src\isa\s390x\inst.isle line 2946.
        return v8;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "insert_imm", "src\\isa\\s390x\\inst.isle line 2937")
}

// Generated as internal constructor for term imm32.
pub fn constructor_imm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: i32,
) -> Reg {
    if arg0 == I64 {
        let v3 = C::temp_writable_reg(ctx, I64);
        let v4 = MInst::Mov64SImm32 {
            rd: v3,
            imm: arg1,
        };
        let v5 = C::emit(ctx, &v4);
        let v6 = C::writable_reg_to_reg(ctx, v3);
        // Rule at src\isa\s390x\inst.isle line 2971.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "imm32", "src\\isa\\s390x\\inst.isle line 2970")
}

// Generated as internal constructor for term vec_imm.
pub fn constructor_vec_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u128,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        if arg1 == 0x0_u128 {
            let v5 = constructor_vec_imm_byte_mask(ctx, v2, 0x0_u16);
            // Rule at src\isa\s390x\inst.isle line 2978.
            return v5;
        }
        let v6 = C::u64_pair_split(ctx, arg1);
        if v6.0 == v6.1 {
            let v10 = constructor_vec_imm_splat(ctx, I64X2, v6.0);
            // Rule at src\isa\s390x\inst.isle line 2980.
            return v10;
        }
        let v11 = C::emit_u128_be_const(ctx, arg1);
        let v12 = &C::memarg_const(ctx, v11);
        let v13 = constructor_vec_load(ctx, v2, v12);
        // Rule at src\isa\s390x\inst.isle line 2982.
        return v13;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_imm", "src\\isa\\s390x\\inst.isle line 2977")
}

// Generated as internal constructor for term vec_imm_splat.
pub fn constructor_vec_imm_splat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
) -> Reg {
    let v6 = C::multi_lane(ctx, arg0);
    if let Some(v7) = v6 {
        match v7.0 {
            0x8_u32 => {
                let v10 = C::u64_truncate_into_u16(ctx, arg1);
                let v11 = C::u16_cast_signed(ctx, v10);
                let v12 = constructor_vec_imm_replicate(ctx, arg0, v11);
                // Rule at src\isa\s390x\inst.isle line 2989.
                return v12;
            }
            0x10_u32 => {
                let v13 = C::u32_pair_split(ctx, arg1);
                let v24 = C::u16_pair_split(ctx, v13.1);
                let v27 = C::u8_pair_split(ctx, v24.1);
                if v27.0 == v27.1 {
                    let v31 = C::u8_into_u64(ctx, v27.0);
                    let v32 = constructor_vec_imm_splat(ctx, I8X16, v31);
                    // Rule at src\isa\s390x\inst.isle line 2999.
                    return v32;
                }
                let v10 = C::u64_truncate_into_u16(ctx, arg1);
                let v11 = C::u16_cast_signed(ctx, v10);
                let v12 = constructor_vec_imm_replicate(ctx, arg0, v11);
                // Rule at src\isa\s390x\inst.isle line 2991.
                return v12;
            }
            0x20_u32 => {
                let v13 = C::u32_pair_split(ctx, arg1);
                let v24 = C::u16_pair_split(ctx, v13.1);
                if v24.0 == v24.1 {
                    let v34 = C::u16_into_u64(ctx, v24.0);
                    let v35 = constructor_vec_imm_splat(ctx, I16X8, v34);
                    // Rule at src\isa\s390x\inst.isle line 3001.
                    return v35;
                }
                let v16 = C::u32_cast_signed(ctx, v13.1);
                let v17 = C::i32_from_i16(ctx, v16);
                if let Some(v18) = v17 {
                    let v19 = constructor_vec_imm_replicate(ctx, arg0, v18);
                    // Rule at src\isa\s390x\inst.isle line 2993.
                    return v19;
                }
            }
            0x40_u32 => {
                let v13 = C::u32_pair_split(ctx, arg1);
                if v13.0 == v13.1 {
                    let v37 = C::u32_into_u64(ctx, v13.0);
                    let v38 = constructor_vec_imm_splat(ctx, I32X4, v37);
                    // Rule at src\isa\s390x\inst.isle line 3003.
                    return v38;
                }
                let v20 = C::u64_cast_signed(ctx, arg1);
                let v21 = C::i64_from_i16(ctx, v20);
                if let Some(v22) = v21 {
                    let v23 = constructor_vec_imm_replicate(ctx, arg0, v22);
                    // Rule at src\isa\s390x\inst.isle line 2996.
                    return v23;
                }
            }
            _ => {}
        }
    }
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        if arg1 == 0x0_u64 {
            let v5 = constructor_vec_imm_byte_mask(ctx, v2, 0x0_u16);
            // Rule at src\isa\s390x\inst.isle line 2987.
            return v5;
        }
    }
    if let Some(v7) = v6 {
        match v7.0 {
            0x20_u32 => {
                let v39 = C::u64_truncate_into_u32(ctx, arg1);
                let v41 = C::u32_pair_concat(ctx, v39, 0x0_u32);
                let v42 = C::emit_u64_be_const(ctx, v41);
                let v43 = &C::memarg_const(ctx, v42);
                let v44 = constructor_vec_load_replicate(ctx, arg0, v43);
                // Rule at src\isa\s390x\inst.isle line 3006.
                return v44;
            }
            0x40_u32 => {
                let v45 = C::emit_u64_be_const(ctx, arg1);
                let v46 = &C::memarg_const(ctx, v45);
                let v47 = constructor_vec_load_replicate(ctx, arg0, v46);
                // Rule at src\isa\s390x\inst.isle line 3009.
                return v47;
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_imm_splat", "src\\isa\\s390x\\inst.isle line 2986")
}

// Generated as internal constructor for term ty_ext32.
pub fn constructor_ty_ext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Type {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\inst.isle line 3016.
            return I32;
        }
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3017.
            return I32;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3018.
            return I32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3019.
            return I64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "ty_ext32", "src\\isa\\s390x\\inst.isle line 3015")
}

// Generated as internal constructor for term ty_ext64.
pub fn constructor_ty_ext64<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Type {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\inst.isle line 3023.
            return I64;
        }
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3024.
            return I64;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3025.
            return I64;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3026.
            return I64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "ty_ext64", "src\\isa\\s390x\\inst.isle line 3022")
}

// Generated as internal constructor for term zext32_reg.
pub fn constructor_zext32_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, I32);
    let v4 = false;
    let v5 = C::ty_bits(ctx, arg0);
    let v7 = MInst::Extend {
        rd: v3,
        rn: arg1,
        signed: v4,
        from_bits: v5,
        to_bits: 0x20_u8,
    };
    let v8 = C::emit(ctx, &v7);
    let v9 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 3031.
    return v9;
}

// Generated as internal constructor for term sext32_reg.
pub fn constructor_sext32_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, I32);
    let v4 = true;
    let v5 = C::ty_bits(ctx, arg0);
    let v7 = MInst::Extend {
        rd: v3,
        rn: arg1,
        signed: v4,
        from_bits: v5,
        to_bits: 0x20_u8,
    };
    let v8 = C::emit(ctx, &v7);
    let v9 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 3038.
    return v9;
}

// Generated as internal constructor for term zext64_reg.
pub fn constructor_zext64_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, I64);
    let v4 = false;
    let v5 = C::ty_bits(ctx, arg0);
    let v7 = MInst::Extend {
        rd: v3,
        rn: arg1,
        signed: v4,
        from_bits: v5,
        to_bits: 0x40_u8,
    };
    let v8 = C::emit(ctx, &v7);
    let v9 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 3045.
    return v9;
}

// Generated as internal constructor for term sext64_reg.
pub fn constructor_sext64_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v3 = C::temp_writable_reg(ctx, I64);
    let v4 = true;
    let v5 = C::ty_bits(ctx, arg0);
    let v7 = MInst::Extend {
        rd: v3,
        rn: arg1,
        signed: v4,
        from_bits: v5,
        to_bits: 0x40_u8,
    };
    let v8 = C::emit(ctx, &v7);
    let v9 = C::writable_reg_to_reg(ctx, v3);
    // Rule at src\isa\s390x\inst.isle line 3052.
    return v9;
}

// Generated as internal constructor for term zext32_mem.
pub fn constructor_zext32_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    match arg0 {
        I8 => {
            let v3 = C::temp_writable_reg(ctx, I32);
            let v4 = MInst::Load32ZExt8 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v5 = C::emit(ctx, &v4);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3060.
            return v6;
        }
        I16 => {
            let v3 = C::temp_writable_reg(ctx, I32);
            let v7 = MInst::Load32ZExt16 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v8 = C::emit(ctx, &v7);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3064.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "zext32_mem", "src\\isa\\s390x\\inst.isle line 3059")
}

// Generated as internal constructor for term sext32_mem.
pub fn constructor_sext32_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    match arg0 {
        I8 => {
            let v3 = C::temp_writable_reg(ctx, I32);
            let v4 = MInst::Load32SExt8 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v5 = C::emit(ctx, &v4);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3071.
            return v6;
        }
        I16 => {
            let v3 = C::temp_writable_reg(ctx, I32);
            let v7 = MInst::Load32SExt16 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v8 = C::emit(ctx, &v7);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3075.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sext32_mem", "src\\isa\\s390x\\inst.isle line 3070")
}

// Generated as internal constructor for term zext64_mem.
pub fn constructor_zext64_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    match arg0 {
        I8 => {
            let v3 = C::temp_writable_reg(ctx, I64);
            let v4 = MInst::Load64ZExt8 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v5 = C::emit(ctx, &v4);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3082.
            return v6;
        }
        I16 => {
            let v3 = C::temp_writable_reg(ctx, I64);
            let v7 = MInst::Load64ZExt16 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v8 = C::emit(ctx, &v7);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3086.
            return v6;
        }
        I32 => {
            let v3 = C::temp_writable_reg(ctx, I64);
            let v9 = MInst::Load64ZExt32 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v10 = C::emit(ctx, &v9);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3090.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "zext64_mem", "src\\isa\\s390x\\inst.isle line 3081")
}

// Generated as internal constructor for term sext64_mem.
pub fn constructor_sext64_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    match arg0 {
        I8 => {
            let v3 = C::temp_writable_reg(ctx, I64);
            let v4 = MInst::Load64SExt8 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v5 = C::emit(ctx, &v4);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3097.
            return v6;
        }
        I16 => {
            let v3 = C::temp_writable_reg(ctx, I64);
            let v7 = MInst::Load64SExt16 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v8 = C::emit(ctx, &v7);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3101.
            return v6;
        }
        I32 => {
            let v3 = C::temp_writable_reg(ctx, I64);
            let v9 = MInst::Load64SExt32 {
                rd: v3,
                mem: arg1.clone(),
            };
            let v10 = C::emit(ctx, &v9);
            let v6 = C::writable_reg_to_reg(ctx, v3);
            // Rule at src\isa\s390x\inst.isle line 3105.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sext64_mem", "src\\isa\\s390x\\inst.isle line 3096")
}

// Generated as internal constructor for term put_in_reg_zext32.
pub fn constructor_put_in_reg_zext32<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v2 = C::u64_from_value(ctx, arg0);
    if let Some(v3) = v2 {
        let v1 = C::value_type(ctx, arg0);
        let v4 = constructor_ty_ext32(ctx, v1);
        let v5 = constructor_imm(ctx, v4, v3);
        // Rule at src\isa\s390x\inst.isle line 3113.
        return v5;
    }
    let v1 = C::value_type(ctx, arg0);
    let v21 = C::ty_32_or_64(ctx, v1);
    if let Some(v22) = v21 {
        let v19 = C::put_in_reg(ctx, arg0);
        // Rule at src\isa\s390x\inst.isle line 3119.
        return v19;
    }
    let v6 = C::fits_in_16(ctx, v1);
    if let Some(v7) = v6 {
        let v8 = C::sinkable_inst(ctx, arg0);
        if let Some(v9) = v8 {
            let v10 = &C::inst_data_value(ctx, v9);
            if let &InstructionData::Load {
                opcode: ref v11,
                arg: v12,
                flags: v13,
                offset: v14,
            } = v10 {
                if let &Opcode::Load = v11 {
                    let v15 = C::bigendian(ctx, v13);
                    if let Some(v16) = v15 {
                        let v17 = &constructor_sink_load(ctx, v9);
                        let v18 = constructor_zext32_mem(ctx, v7, v17);
                        // Rule at src\isa\s390x\inst.isle line 3115.
                        return v18;
                    }
                }
            }
        }
        let v19 = C::put_in_reg(ctx, arg0);
        let v20 = constructor_zext32_reg(ctx, v7, v19);
        // Rule at src\isa\s390x\inst.isle line 3117.
        return v20;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "put_in_reg_zext32", "src\\isa\\s390x\\inst.isle line 3112")
}

// Generated as internal constructor for term put_in_reg_sext32.
pub fn constructor_put_in_reg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v2 = C::u64_from_signed_value(ctx, arg0);
    if let Some(v3) = v2 {
        let v1 = C::value_type(ctx, arg0);
        let v4 = constructor_ty_ext32(ctx, v1);
        let v5 = constructor_imm(ctx, v4, v3);
        // Rule at src\isa\s390x\inst.isle line 3124.
        return v5;
    }
    let v1 = C::value_type(ctx, arg0);
    let v21 = C::ty_32_or_64(ctx, v1);
    if let Some(v22) = v21 {
        let v19 = C::put_in_reg(ctx, arg0);
        // Rule at src\isa\s390x\inst.isle line 3130.
        return v19;
    }
    let v6 = C::fits_in_16(ctx, v1);
    if let Some(v7) = v6 {
        let v8 = C::sinkable_inst(ctx, arg0);
        if let Some(v9) = v8 {
            let v10 = &C::inst_data_value(ctx, v9);
            if let &InstructionData::Load {
                opcode: ref v11,
                arg: v12,
                flags: v13,
                offset: v14,
            } = v10 {
                if let &Opcode::Load = v11 {
                    let v15 = C::bigendian(ctx, v13);
                    if let Some(v16) = v15 {
                        let v17 = &constructor_sink_load(ctx, v9);
                        let v18 = constructor_sext32_mem(ctx, v7, v17);
                        // Rule at src\isa\s390x\inst.isle line 3126.
                        return v18;
                    }
                }
            }
        }
        let v19 = C::put_in_reg(ctx, arg0);
        let v20 = constructor_sext32_reg(ctx, v7, v19);
        // Rule at src\isa\s390x\inst.isle line 3128.
        return v20;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "put_in_reg_sext32", "src\\isa\\s390x\\inst.isle line 3123")
}

// Generated as internal constructor for term put_in_reg_zext64.
pub fn constructor_put_in_reg_zext64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v2 = C::u64_from_value(ctx, arg0);
    if let Some(v3) = v2 {
        let v1 = C::value_type(ctx, arg0);
        let v4 = constructor_ty_ext64(ctx, v1);
        let v5 = constructor_imm(ctx, v4, v3);
        // Rule at src\isa\s390x\inst.isle line 3135.
        return v5;
    }
    let v1 = C::value_type(ctx, arg0);
    let v21 = C::gpr64_ty(ctx, v1);
    if let Some(v22) = v21 {
        let v19 = C::put_in_reg(ctx, arg0);
        // Rule at src\isa\s390x\inst.isle line 3141.
        return v19;
    }
    let v6 = C::gpr32_ty(ctx, v1);
    if let Some(v7) = v6 {
        let v8 = C::sinkable_inst(ctx, arg0);
        if let Some(v9) = v8 {
            let v10 = &C::inst_data_value(ctx, v9);
            if let &InstructionData::Load {
                opcode: ref v11,
                arg: v12,
                flags: v13,
                offset: v14,
            } = v10 {
                if let &Opcode::Load = v11 {
                    let v15 = C::bigendian(ctx, v13);
                    if let Some(v16) = v15 {
                        let v17 = &constructor_sink_load(ctx, v9);
                        let v18 = constructor_zext64_mem(ctx, v7, v17);
                        // Rule at src\isa\s390x\inst.isle line 3137.
                        return v18;
                    }
                }
            }
        }
        let v19 = C::put_in_reg(ctx, arg0);
        let v20 = constructor_zext64_reg(ctx, v7, v19);
        // Rule at src\isa\s390x\inst.isle line 3139.
        return v20;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "put_in_reg_zext64", "src\\isa\\s390x\\inst.isle line 3134")
}

// Generated as internal constructor for term put_in_reg_sext64.
pub fn constructor_put_in_reg_sext64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v2 = C::u64_from_signed_value(ctx, arg0);
    if let Some(v3) = v2 {
        let v1 = C::value_type(ctx, arg0);
        let v4 = constructor_ty_ext64(ctx, v1);
        let v5 = constructor_imm(ctx, v4, v3);
        // Rule at src\isa\s390x\inst.isle line 3146.
        return v5;
    }
    let v1 = C::value_type(ctx, arg0);
    let v21 = C::gpr64_ty(ctx, v1);
    if let Some(v22) = v21 {
        let v19 = C::put_in_reg(ctx, arg0);
        // Rule at src\isa\s390x\inst.isle line 3152.
        return v19;
    }
    let v6 = C::gpr32_ty(ctx, v1);
    if let Some(v7) = v6 {
        let v8 = C::sinkable_inst(ctx, arg0);
        if let Some(v9) = v8 {
            let v10 = &C::inst_data_value(ctx, v9);
            if let &InstructionData::Load {
                opcode: ref v11,
                arg: v12,
                flags: v13,
                offset: v14,
            } = v10 {
                if let &Opcode::Load = v11 {
                    let v15 = C::bigendian(ctx, v13);
                    if let Some(v16) = v15 {
                        let v17 = &constructor_sink_load(ctx, v9);
                        let v18 = constructor_sext64_mem(ctx, v7, v17);
                        // Rule at src\isa\s390x\inst.isle line 3148.
                        return v18;
                    }
                }
            }
        }
        let v19 = C::put_in_reg(ctx, arg0);
        let v20 = constructor_sext64_reg(ctx, v7, v19);
        // Rule at src\isa\s390x\inst.isle line 3150.
        return v20;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "put_in_reg_sext64", "src\\isa\\s390x\\inst.isle line 3145")
}

// Generated as internal constructor for term cmov_imm.
pub fn constructor_cmov_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Cond,
    arg2: i16,
    arg3: Reg,
) -> ConsumesFlags {
    let v10 = C::gpr64_ty(ctx, arg0);
    if let Some(v11) = v10 {
        let v12 = C::temp_writable_reg(ctx, v11);
        let v13 = MInst::CMov64SImm16 {
            rd: v12,
            cond: arg1.clone(),
            ri: arg3,
            imm: arg2,
        };
        let v14 = C::writable_reg_to_reg(ctx, v12);
        let v15 = ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: v13,
            result: v14,
        };
        // Rule at src\isa\s390x\inst.isle line 3164.
        return v15;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = C::temp_writable_reg(ctx, v2);
        let v7 = MInst::CMov32SImm16 {
            rd: v6,
            cond: arg1.clone(),
            ri: arg3,
            imm: arg2,
        };
        let v8 = C::writable_reg_to_reg(ctx, v6);
        let v9 = ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: v7,
            result: v8,
        };
        // Rule at src\isa\s390x\inst.isle line 3160.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmov_imm", "src\\isa\\s390x\\inst.isle line 3159")
}

// Generated as internal constructor for term cmov_imm_imm.
pub fn constructor_cmov_imm_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Cond,
    arg2: i16,
    arg3: i16,
) -> ConsumesFlags {
    let v14 = C::gpr64_ty(ctx, arg0);
    if let Some(v15) = v14 {
        let v16 = C::temp_writable_reg(ctx, v15);
        let v17 = C::temp_writable_reg(ctx, v15);
        let v21 = C::writable_reg_to_reg(ctx, v17);
        let v22 = C::value_reg(ctx, v21);
        let v18 = MInst::Mov64SImm16 {
            rd: v16,
            imm: arg3,
        };
        let v19 = C::writable_reg_to_reg(ctx, v16);
        let v20 = MInst::CMov64SImm16 {
            rd: v17,
            cond: arg1.clone(),
            ri: v19,
            imm: arg2,
        };
        let v23 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
            inst1: v18,
            inst2: v20,
            result: v22,
        };
        // Rule at src\isa\s390x\inst.isle line 3178.
        return v23;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = C::temp_writable_reg(ctx, v2);
        let v7 = C::temp_writable_reg(ctx, v2);
        let v11 = C::writable_reg_to_reg(ctx, v7);
        let v12 = C::value_reg(ctx, v11);
        let v8 = MInst::Mov32SImm16 {
            rd: v6,
            imm: arg3,
        };
        let v9 = C::writable_reg_to_reg(ctx, v6);
        let v10 = MInst::CMov32SImm16 {
            rd: v7,
            cond: arg1.clone(),
            ri: v9,
            imm: arg2,
        };
        let v13 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
            inst1: v8,
            inst2: v10,
            result: v12,
        };
        // Rule at src\isa\s390x\inst.isle line 3171.
        return v13;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmov_imm_imm", "src\\isa\\s390x\\inst.isle line 3170")
}

// Generated as internal constructor for term cmov_reg_reg.
pub fn constructor_cmov_reg_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &Cond,
    arg2: Reg,
    arg3: Reg,
) -> ConsumesFlags {
    match arg0 {
        F16 => {
            let v17 = C::temp_writable_reg(ctx, F16);
            let v18 = MInst::FpuCMov32 {
                rd: v17,
                cond: arg1.clone(),
                ri: arg3,
                rm: arg2,
            };
            let v19 = C::writable_reg_to_reg(ctx, v17);
            let v20 = ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: v18,
                result: v19,
            };
            // Rule at src\isa\s390x\inst.isle line 3196.
            return v20;
        }
        F32 => {
            let v22 = C::temp_writable_reg(ctx, F32);
            let v23 = MInst::FpuCMov32 {
                rd: v22,
                cond: arg1.clone(),
                ri: arg3,
                rm: arg2,
            };
            let v24 = C::writable_reg_to_reg(ctx, v22);
            let v25 = ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: v23,
                result: v24,
            };
            // Rule at src\isa\s390x\inst.isle line 3200.
            return v25;
        }
        F64 => {
            let v27 = C::temp_writable_reg(ctx, F64);
            let v28 = MInst::FpuCMov64 {
                rd: v27,
                cond: arg1.clone(),
                ri: arg3,
                rm: arg2,
            };
            let v29 = C::writable_reg_to_reg(ctx, v27);
            let v30 = ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: v28,
                result: v29,
            };
            // Rule at src\isa\s390x\inst.isle line 3204.
            return v30;
        }
        _ => {}
    }
    let v10 = C::gpr64_ty(ctx, arg0);
    if let Some(v11) = v10 {
        let v12 = C::temp_writable_reg(ctx, v11);
        let v13 = MInst::CMov64 {
            rd: v12,
            cond: arg1.clone(),
            ri: arg3,
            rm: arg2,
        };
        let v14 = C::writable_reg_to_reg(ctx, v12);
        let v15 = ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: v13,
            result: v14,
        };
        // Rule at src\isa\s390x\inst.isle line 3192.
        return v15;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = C::temp_writable_reg(ctx, v2);
        let v7 = MInst::CMov32 {
            rd: v6,
            cond: arg1.clone(),
            ri: arg3,
            rm: arg2,
        };
        let v8 = C::writable_reg_to_reg(ctx, v6);
        let v9 = ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: v7,
            result: v8,
        };
        // Rule at src\isa\s390x\inst.isle line 3188.
        return v9;
    }
    let v31 = C::vr128_ty(ctx, arg0);
    if let Some(v32) = v31 {
        let v27 = C::temp_writable_reg(ctx, F64);
        let v33 = MInst::VecCMov {
            rd: v27,
            cond: arg1.clone(),
            ri: arg3,
            rm: arg2,
        };
        let v29 = C::writable_reg_to_reg(ctx, v27);
        let v34 = ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: v33,
            result: v29,
        };
        // Rule at src\isa\s390x\inst.isle line 3208.
        return v34;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmov_reg_reg", "src\\isa\\s390x\\inst.isle line 3187")
}

// Generated as internal constructor for term trap_if.
pub fn constructor_trap_if<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &Cond,
    arg2: &TrapCode,
) -> Reg {
    let v3 = &constructor_trap_if_impl(ctx, arg1, arg2);
    let v4 = &constructor_with_flags_side_effect(ctx, arg0, v3);
    let v5 = constructor_side_effect(ctx, v4);
    let v6 = C::invalid_reg(ctx);
    // Rule at src\isa\s390x\inst.isle line 3217.
    return v6;
}

// Generated as internal constructor for term icmps_reg_and_trap.
pub fn constructor_icmps_reg_and_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: &Cond,
    arg4: &TrapCode,
) -> Reg {
    let v5 = &constructor_cmpop_cmps(ctx, arg0);
    let v6 = MInst::CmpTrapRR {
        op: v5.clone(),
        rn: arg1,
        rm: arg2,
        cond: arg3.clone(),
        trap_code: arg4.clone(),
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::invalid_reg(ctx);
    // Rule at src\isa\s390x\inst.isle line 3223.
    return v8;
}

// Generated as internal constructor for term icmps_simm16_and_trap.
pub fn constructor_icmps_simm16_and_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i16,
    arg3: &Cond,
    arg4: &TrapCode,
) -> Reg {
    let v5 = &constructor_cmpop_cmps(ctx, arg0);
    let v6 = MInst::CmpTrapRSImm16 {
        op: v5.clone(),
        rn: arg1,
        imm: arg2,
        cond: arg3.clone(),
        trap_code: arg4.clone(),
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::invalid_reg(ctx);
    // Rule at src\isa\s390x\inst.isle line 3229.
    return v8;
}

// Generated as internal constructor for term icmpu_reg_and_trap.
pub fn constructor_icmpu_reg_and_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: &Cond,
    arg4: &TrapCode,
) -> Reg {
    let v5 = &constructor_cmpop_cmpu(ctx, arg0);
    let v6 = MInst::CmpTrapRR {
        op: v5.clone(),
        rn: arg1,
        rm: arg2,
        cond: arg3.clone(),
        trap_code: arg4.clone(),
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::invalid_reg(ctx);
    // Rule at src\isa\s390x\inst.isle line 3235.
    return v8;
}

// Generated as internal constructor for term icmpu_uimm16_and_trap.
pub fn constructor_icmpu_uimm16_and_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u16,
    arg3: &Cond,
    arg4: &TrapCode,
) -> Reg {
    let v5 = &constructor_cmpop_cmpu(ctx, arg0);
    let v6 = MInst::CmpTrapRUImm16 {
        op: v5.clone(),
        rn: arg1,
        imm: arg2,
        cond: arg3.clone(),
        trap_code: arg4.clone(),
    };
    let v7 = C::emit(ctx, &v6);
    let v8 = C::invalid_reg(ctx);
    // Rule at src\isa\s390x\inst.isle line 3241.
    return v8;
}

// Generated as internal constructor for term trap_impl.
pub fn constructor_trap_impl<C: Context>(
    ctx: &mut C,
    arg0: &TrapCode,
) -> SideEffectNoResult {
    let v1 = MInst::Trap {
        trap_code: arg0.clone(),
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\s390x\inst.isle line 3247.
    return v2;
}

// Generated as internal constructor for term trap_if_impl.
pub fn constructor_trap_if_impl<C: Context>(
    ctx: &mut C,
    arg0: &Cond,
    arg1: &TrapCode,
) -> ConsumesFlags {
    let v2 = MInst::TrapIf {
        cond: arg0.clone(),
        trap_code: arg1.clone(),
    };
    let v3 = ConsumesFlags::ConsumesFlagsSideEffect {
        inst: v2,
    };
    // Rule at src\isa\s390x\inst.isle line 3251.
    return v3;
}

// Generated as internal constructor for term debugtrap_impl.
pub fn constructor_debugtrap_impl<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = SideEffectNoResult::Inst {
        inst: MInst::Debugtrap,
    };
    // Rule at src\isa\s390x\inst.isle line 3255.
    return v1;
}

// Generated as internal constructor for term bool.
pub fn constructor_bool<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &Cond,
) -> ProducesBool {
    let v2 = ProducesBool::ProducesBool {
        producer: arg0.clone(),
        cond: arg1.clone(),
    };
    // Rule at src\isa\s390x\inst.isle line 3266.
    return v2;
}

// Generated as internal constructor for term invert_bool.
pub fn constructor_invert_bool<C: Context>(
    ctx: &mut C,
    arg0: &ProducesBool,
) -> ProducesBool {
    if let &ProducesBool::ProducesBool {
        producer: ref v1,
        cond: ref v2,
    } = arg0 {
        let v3 = &C::invert_cond(ctx, v2);
        let v4 = &constructor_bool(ctx, v1, v3);
        // Rule at src\isa\s390x\inst.isle line 3270.
        return v4.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "invert_bool", "src\\isa\\s390x\\inst.isle line 3269")
}

// Generated as internal constructor for term select_bool_reg.
pub fn constructor_select_bool_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ProducesBool,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    if let &ProducesBool::ProducesBool {
        producer: ref v2,
        cond: ref v3,
    } = arg1 {
        let v6 = &constructor_cmov_reg_reg(ctx, arg0, v3, arg2, arg3);
        let v7 = constructor_with_flags_reg(ctx, v2, v6);
        // Rule at src\isa\s390x\inst.isle line 3275.
        return v7;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "select_bool_reg", "src\\isa\\s390x\\inst.isle line 3274")
}

// Generated as internal constructor for term select_bool_imm.
pub fn constructor_select_bool_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ProducesBool,
    arg2: i16,
    arg3: i16,
) -> Reg {
    if let &ProducesBool::ProducesBool {
        producer: ref v2,
        cond: ref v3,
    } = arg1 {
        let v6 = &constructor_cmov_imm_imm(ctx, arg0, v3, arg2, arg3);
        let v7 = constructor_with_flags_reg(ctx, v2, v6);
        // Rule at src\isa\s390x\inst.isle line 3280.
        return v7;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "select_bool_imm", "src\\isa\\s390x\\inst.isle line 3279")
}

// Generated as internal constructor for term lower_bool.
pub fn constructor_lower_bool<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ProducesBool,
) -> Reg {
    if arg0 == I8 {
        let v5 = constructor_select_bool_imm(ctx, I8, arg1, 1_i16, 0_i16);
        // Rule at src\isa\s390x\inst.isle line 3286.
        return v5;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_bool", "src\\isa\\s390x\\inst.isle line 3285")
}

// Generated as internal constructor for term lower_bool_to_mask.
pub fn constructor_lower_bool_to_mask<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &ProducesBool,
) -> Reg {
    if arg0 == I128 {
        let v8 = constructor_lower_bool_to_mask(ctx, I64, arg1);
        let v10 = constructor_mov_to_vec128(ctx, I128, v8, v8);
        // Rule at src\isa\s390x\inst.isle line 3293.
        return v10;
    }
    let v1 = C::fits_in_64(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_select_bool_imm(ctx, v2, arg1, -1_i16, 0_i16);
        // Rule at src\isa\s390x\inst.isle line 3290.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_bool_to_mask", "src\\isa\\s390x\\inst.isle line 3289")
}

// Generated as internal constructor for term cond_br_bool.
pub fn constructor_cond_br_bool<C: Context>(
    ctx: &mut C,
    arg0: &ProducesBool,
    arg1: MachLabel,
    arg2: MachLabel,
) -> SideEffectNoResult {
    if let &ProducesBool::ProducesBool {
        producer: ref v1,
        cond: ref v2,
    } = arg0 {
        let v5 = &constructor_cond_br(ctx, arg1, arg2, v2);
        let v6 = &constructor_with_flags_side_effect(ctx, v1, v5);
        // Rule at src\isa\s390x\inst.isle line 3299.
        return v6.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cond_br_bool", "src\\isa\\s390x\\inst.isle line 3298")
}

// Generated as internal constructor for term trap_if_bool.
pub fn constructor_trap_if_bool<C: Context>(
    ctx: &mut C,
    arg0: &ProducesBool,
    arg1: &TrapCode,
) -> SideEffectNoResult {
    if let &ProducesBool::ProducesBool {
        producer: ref v1,
        cond: ref v2,
    } = arg0 {
        let v4 = &constructor_trap_if_impl(ctx, v2, arg1);
        let v5 = &constructor_with_flags_side_effect(ctx, v1, v4);
        // Rule at src\isa\s390x\inst.isle line 3304.
        return v5.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "trap_if_bool", "src\\isa\\s390x\\inst.isle line 3303")
}

// Generated as internal constructor for term casloop_val_reg.
pub fn constructor_casloop_val_reg<C: Context>(
    ctx: &mut C,
) -> WritableReg {
    let v1 = C::writable_gpr(ctx, 0x0_u8);
    // Rule at src\isa\s390x\inst.isle line 3317.
    return v1;
}

// Generated as internal constructor for term casloop_tmp_reg.
pub fn constructor_casloop_tmp_reg<C: Context>(
    ctx: &mut C,
) -> WritableReg {
    let v1 = C::writable_gpr(ctx, 0x1_u8);
    // Rule at src\isa\s390x\inst.isle line 3321.
    return v1;
}

// Generated as internal constructor for term casloop_emit.
pub fn constructor_casloop_emit<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: Reg,
    arg4: Reg,
) -> PReg {
    let v7 = &C::memarg_reg_plus_off(ctx, arg3, 0_i64, 0x0_u8, arg2);
    let v8 = constructor_ty_ext32(ctx, arg1);
    let v9 = constructor_casloop_val_reg(ctx);
    let v10 = constructor_push_atomic_cas(ctx, arg0, v8, v9, arg4, v7);
    let v11 = constructor_ty_ext32(ctx, arg1);
    let v12 = constructor_casloop_val_reg(ctx);
    let v13 = constructor_emit_load(ctx, v11, v12, v7);
    let v15 = &C::intcc_as_cond(ctx, &IntCC::NotEqual);
    let v16 = constructor_emit_loop(ctx, arg0, v15);
    let v17 = C::preg_gpr_0(ctx);
    // Rule at src\isa\s390x\inst.isle line 3330.
    return v17;
}

// Generated as internal constructor for term casloop_result.
pub fn constructor_casloop_result<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: PReg,
) -> Reg {
    let v1 = C::ty_32_or_64(ctx, arg0);
    if let Some(v2) = v1 {
        let v4 = C::bigendian(ctx, arg1);
        if let Some(v5) = v4 {
            let v7 = constructor_mov_preg(ctx, arg2);
            // Rule at src\isa\s390x\inst.isle line 3353.
            return v7;
        }
        let v8 = C::littleendian(ctx, arg1);
        if let Some(v9) = v8 {
            let v10 = C::preg_to_reg(ctx, arg2);
            let v11 = constructor_bswap_reg(ctx, v2, v10);
            // Rule at src\isa\s390x\inst.isle line 3355.
            return v11;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "casloop_result", "src\\isa\\s390x\\inst.isle line 3352")
}

// Generated as internal constructor for term casloop.
pub fn constructor_casloop<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: Reg,
    arg4: Reg,
) -> Reg {
    let v5 = constructor_casloop_emit(ctx, arg0, arg1, arg2, arg3, arg4);
    let v6 = constructor_casloop_result(ctx, arg1, arg2, v5);
    // Rule at src\isa\s390x\inst.isle line 3360.
    return v6;
}

// Generated as internal constructor for term casloop_bitshift.
pub fn constructor_casloop_bitshift<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> Reg {
    let v3 = constructor_lshl_imm(ctx, I32, arg0, 0x3_u8);
    // Rule at src\isa\s390x\inst.isle line 3375.
    return v3;
}

// Generated as internal constructor for term casloop_aligned_addr.
pub fn constructor_casloop_aligned_addr<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> Reg {
    let v4 = C::uimm16shifted(ctx, 0xfffc_u16, 0x0_u8);
    let v5 = constructor_and_uimm16shifted(ctx, I64, arg0, v4);
    // Rule at src\isa\s390x\inst.isle line 3380.
    return v5;
}

// Generated as internal constructor for term casloop_rotate_in.
pub fn constructor_casloop_rotate_in<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: Reg,
    arg4: Reg,
) -> Reg {
    match arg1 {
        I8 => {
            let v6 = constructor_casloop_tmp_reg(ctx);
            let v8 = constructor_push_rot_imm_reg(ctx, arg0, I32, v6, arg4, 0x0_u8, arg3);
            // Rule at src\isa\s390x\inst.isle line 3390.
            return v8;
        }
        I16 => {
            let v9 = C::bigendian(ctx, arg2);
            if let Some(v10) = v9 {
                let v6 = constructor_casloop_tmp_reg(ctx);
                let v8 = constructor_push_rot_imm_reg(ctx, arg0, I32, v6, arg4, 0x0_u8, arg3);
                // Rule at src\isa\s390x\inst.isle line 3392.
                return v8;
            }
            let v11 = C::littleendian(ctx, arg2);
            if let Some(v12) = v11 {
                let v6 = constructor_casloop_tmp_reg(ctx);
                let v14 = constructor_push_rot_imm_reg(ctx, arg0, I32, v6, arg4, 0x10_u8, arg3);
                // Rule at src\isa\s390x\inst.isle line 3394.
                return v14;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "casloop_rotate_in", "src\\isa\\s390x\\inst.isle line 3389")
}

// Generated as internal constructor for term casloop_rotate_out.
pub fn constructor_casloop_rotate_out<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: Reg,
    arg4: Reg,
) -> Reg {
    match arg1 {
        I8 => {
            let v6 = constructor_casloop_tmp_reg(ctx);
            let v8 = constructor_neg_reg(ctx, I32, arg3);
            let v9 = constructor_push_rot_imm_reg(ctx, arg0, I32, v6, arg4, 0x0_u8, v8);
            // Rule at src\isa\s390x\inst.isle line 3403.
            return v9;
        }
        I16 => {
            let v10 = C::bigendian(ctx, arg2);
            if let Some(v11) = v10 {
                let v6 = constructor_casloop_tmp_reg(ctx);
                let v12 = constructor_push_rot_imm_reg(ctx, arg0, I32, v6, arg4, 0x0_u8, arg3);
                // Rule at src\isa\s390x\inst.isle line 3405.
                return v12;
            }
            let v13 = C::littleendian(ctx, arg2);
            if let Some(v14) = v13 {
                let v6 = constructor_casloop_tmp_reg(ctx);
                let v16 = constructor_push_rot_imm_reg(ctx, arg0, I32, v6, arg4, 0x10_u8, arg3);
                // Rule at src\isa\s390x\inst.isle line 3407.
                return v16;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "casloop_rotate_out", "src\\isa\\s390x\\inst.isle line 3402")
}

// Generated as internal constructor for term casloop_rotate_result.
pub fn constructor_casloop_rotate_result<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    match arg0 {
        I8 => {
            let v6 = constructor_rot_imm_reg(ctx, I32, arg3, 0x8_u8, arg2);
            // Rule at src\isa\s390x\inst.isle line 3418.
            return v6;
        }
        I16 => {
            let v7 = C::bigendian(ctx, arg1);
            if let Some(v8) = v7 {
                let v10 = constructor_rot_imm_reg(ctx, I32, arg3, 0x10_u8, arg2);
                // Rule at src\isa\s390x\inst.isle line 3420.
                return v10;
            }
            let v11 = C::littleendian(ctx, arg1);
            if let Some(v12) = v11 {
                let v13 = constructor_rot_reg(ctx, I32, arg3, arg2);
                let v14 = constructor_bswap_reg(ctx, I32, v13);
                // Rule at src\isa\s390x\inst.isle line 3422.
                return v14;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "casloop_rotate_result", "src\\isa\\s390x\\inst.isle line 3417")
}

// Generated as internal constructor for term casloop_subword.
pub fn constructor_casloop_subword<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: Reg,
    arg4: Reg,
    arg5: Reg,
) -> Reg {
    let v6 = constructor_casloop_emit(ctx, arg0, arg1, arg2, arg3, arg5);
    let v7 = C::preg_to_reg(ctx, v6);
    let v8 = constructor_casloop_rotate_result(ctx, arg1, arg2, arg4, v7);
    // Rule at src\isa\s390x\inst.isle line 3427.
    return v8;
}

// Generated as internal constructor for term writable_link_reg.
pub fn constructor_writable_link_reg<C: Context>(
    ctx: &mut C,
) -> WritableReg {
    let v1 = C::writable_gpr(ctx, 0xe_u8);
    // Rule at src\isa\s390x\inst.isle line 3450.
    return v1;
}

// Generated as internal constructor for term vec_widen_type.
pub fn constructor_vec_widen_type<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Type {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3456.
            return I16X8;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3457.
            return I32X4;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3458.
            return I64X2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_widen_type", "src\\isa\\s390x\\inst.isle line 3455")
}

// Generated as internal constructor for term vecop_pack.
pub fn constructor_vecop_pack<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3461.
            return VecBinaryOp::Pack16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3462.
            return VecBinaryOp::Pack32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3463.
            return VecBinaryOp::Pack64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_pack", "src\\isa\\s390x\\inst.isle line 3460")
}

// Generated as internal constructor for term vec_pack.
pub fn constructor_vec_pack<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_pack(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3466.
    return v4;
}

// Generated as internal constructor for term vecop_pack_ssat.
pub fn constructor_vecop_pack_ssat<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3469.
            return VecBinaryOp::PackSSat16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3470.
            return VecBinaryOp::PackSSat32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3471.
            return VecBinaryOp::PackSSat64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_pack_ssat", "src\\isa\\s390x\\inst.isle line 3468")
}

// Generated as internal constructor for term vec_pack_ssat.
pub fn constructor_vec_pack_ssat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_pack_ssat(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3474.
    return v4;
}

// Generated as internal constructor for term vecop_pack_usat.
pub fn constructor_vecop_pack_usat<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3477.
            return VecBinaryOp::PackUSat16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3478.
            return VecBinaryOp::PackUSat32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3479.
            return VecBinaryOp::PackUSat64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_pack_usat", "src\\isa\\s390x\\inst.isle line 3476")
}

// Generated as internal constructor for term vec_pack_usat.
pub fn constructor_vec_pack_usat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_pack_usat(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3482.
    return v4;
}

// Generated as internal constructor for term vecop_unpacks_low.
pub fn constructor_vecop_unpacks_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3485.
            return VecUnaryOp::UnpackSLow8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3486.
            return VecUnaryOp::UnpackSLow16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3487.
            return VecUnaryOp::UnpackSLow32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_unpacks_low", "src\\isa\\s390x\\inst.isle line 3484")
}

// Generated as internal constructor for term vec_unpacks_low.
pub fn constructor_vec_unpacks_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_unpacks_low(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 3490.
    return v3;
}

// Generated as internal constructor for term vecop_unpacks_high.
pub fn constructor_vecop_unpacks_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3493.
            return VecUnaryOp::UnpackSHigh8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3494.
            return VecUnaryOp::UnpackSHigh16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3495.
            return VecUnaryOp::UnpackSHigh32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_unpacks_high", "src\\isa\\s390x\\inst.isle line 3492")
}

// Generated as internal constructor for term vec_unpacks_high.
pub fn constructor_vec_unpacks_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_unpacks_high(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 3498.
    return v3;
}

// Generated as internal constructor for term vecop_unpacku_low.
pub fn constructor_vecop_unpacku_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3501.
            return VecUnaryOp::UnpackULow8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3502.
            return VecUnaryOp::UnpackULow16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3503.
            return VecUnaryOp::UnpackULow32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_unpacku_low", "src\\isa\\s390x\\inst.isle line 3500")
}

// Generated as internal constructor for term vec_unpacku_low.
pub fn constructor_vec_unpacku_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_unpacku_low(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 3506.
    return v3;
}

// Generated as internal constructor for term vecop_unpacku_high.
pub fn constructor_vecop_unpacku_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3509.
            return VecUnaryOp::UnpackUHigh8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3510.
            return VecUnaryOp::UnpackUHigh16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3511.
            return VecUnaryOp::UnpackUHigh32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_unpacku_high", "src\\isa\\s390x\\inst.isle line 3508")
}

// Generated as internal constructor for term vec_unpacku_high.
pub fn constructor_vec_unpacku_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_unpacku_high(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 3514.
    return v3;
}

// Generated as internal constructor for term vec_pack_lane_order.
pub fn constructor_vec_pack_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &C::lane_order(ctx);
    match v3 {
        &LaneOrder::LittleEndian => {
            let v5 = constructor_vec_pack(ctx, arg0, arg2, arg1);
            // Rule at src\isa\s390x\inst.isle line 3525.
            return v5;
        }
        &LaneOrder::BigEndian => {
            let v4 = constructor_vec_pack(ctx, arg0, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3522.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_pack_lane_order", "src\\isa\\s390x\\inst.isle line 3521")
}

// Generated as internal constructor for term vec_pack_ssat_lane_order.
pub fn constructor_vec_pack_ssat_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &C::lane_order(ctx);
    match v3 {
        &LaneOrder::LittleEndian => {
            let v5 = constructor_vec_pack_ssat(ctx, arg0, arg2, arg1);
            // Rule at src\isa\s390x\inst.isle line 3533.
            return v5;
        }
        &LaneOrder::BigEndian => {
            let v4 = constructor_vec_pack_ssat(ctx, arg0, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3530.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_pack_ssat_lane_order", "src\\isa\\s390x\\inst.isle line 3529")
}

// Generated as internal constructor for term vec_pack_usat_lane_order.
pub fn constructor_vec_pack_usat_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &C::lane_order(ctx);
    match v3 {
        &LaneOrder::LittleEndian => {
            let v5 = constructor_vec_pack_usat(ctx, arg0, arg2, arg1);
            // Rule at src\isa\s390x\inst.isle line 3541.
            return v5;
        }
        &LaneOrder::BigEndian => {
            let v4 = constructor_vec_pack_usat(ctx, arg0, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3538.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_pack_usat_lane_order", "src\\isa\\s390x\\inst.isle line 3537")
}

// Generated as internal constructor for term vec_unpacks_low_lane_order.
pub fn constructor_vec_unpacks_low_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &C::lane_order(ctx);
    match v2 {
        &LaneOrder::LittleEndian => {
            let v4 = constructor_vec_unpacks_low(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3554.
            return v4;
        }
        &LaneOrder::BigEndian => {
            let v3 = constructor_vec_unpacks_high(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3551.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_unpacks_low_lane_order", "src\\isa\\s390x\\inst.isle line 3550")
}

// Generated as internal constructor for term vec_unpacks_high_lane_order.
pub fn constructor_vec_unpacks_high_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &C::lane_order(ctx);
    match v2 {
        &LaneOrder::LittleEndian => {
            let v4 = constructor_vec_unpacks_high(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3562.
            return v4;
        }
        &LaneOrder::BigEndian => {
            let v3 = constructor_vec_unpacks_low(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3559.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_unpacks_high_lane_order", "src\\isa\\s390x\\inst.isle line 3558")
}

// Generated as internal constructor for term vec_unpacku_low_lane_order.
pub fn constructor_vec_unpacku_low_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &C::lane_order(ctx);
    match v2 {
        &LaneOrder::LittleEndian => {
            let v4 = constructor_vec_unpacku_low(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3570.
            return v4;
        }
        &LaneOrder::BigEndian => {
            let v3 = constructor_vec_unpacku_high(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3567.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_unpacku_low_lane_order", "src\\isa\\s390x\\inst.isle line 3566")
}

// Generated as internal constructor for term vec_unpacku_high_lane_order.
pub fn constructor_vec_unpacku_high_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &C::lane_order(ctx);
    match v2 {
        &LaneOrder::LittleEndian => {
            let v4 = constructor_vec_unpacku_high(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3578.
            return v4;
        }
        &LaneOrder::BigEndian => {
            let v3 = constructor_vec_unpacku_low(ctx, arg0, arg1);
            // Rule at src\isa\s390x\inst.isle line 3575.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_unpacku_high_lane_order", "src\\isa\\s390x\\inst.isle line 3574")
}

// Generated as internal constructor for term vecop_merge_low.
pub fn constructor_vecop_merge_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3586.
            return VecBinaryOp::MergeLow8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3587.
            return VecBinaryOp::MergeLow16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3588.
            return VecBinaryOp::MergeLow32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3589.
            return VecBinaryOp::MergeLow64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_merge_low", "src\\isa\\s390x\\inst.isle line 3585")
}

// Generated as internal constructor for term vec_merge_low.
pub fn constructor_vec_merge_low<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_merge_low(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3592.
    return v4;
}

// Generated as internal constructor for term vecop_merge_high.
pub fn constructor_vecop_merge_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3595.
            return VecBinaryOp::MergeHigh8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3596.
            return VecBinaryOp::MergeHigh16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3597.
            return VecBinaryOp::MergeHigh32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3598.
            return VecBinaryOp::MergeHigh64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_merge_high", "src\\isa\\s390x\\inst.isle line 3594")
}

// Generated as internal constructor for term vec_merge_high.
pub fn constructor_vec_merge_high<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_merge_high(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3601.
    return v4;
}

// Generated as internal constructor for term vec_merge_low_lane_order.
pub fn constructor_vec_merge_low_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &C::lane_order(ctx);
    match v3 {
        &LaneOrder::LittleEndian => {
            let v5 = constructor_vec_merge_low(ctx, arg0, arg2, arg1);
            // Rule at src\isa\s390x\inst.isle line 3615.
            return v5;
        }
        &LaneOrder::BigEndian => {
            let v4 = constructor_vec_merge_high(ctx, arg0, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3612.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_merge_low_lane_order", "src\\isa\\s390x\\inst.isle line 3611")
}

// Generated as internal constructor for term vec_merge_high_lane_order.
pub fn constructor_vec_merge_high_lane_order<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &C::lane_order(ctx);
    match v3 {
        &LaneOrder::LittleEndian => {
            let v5 = constructor_vec_merge_high(ctx, arg0, arg2, arg1);
            // Rule at src\isa\s390x\inst.isle line 3623.
            return v5;
        }
        &LaneOrder::BigEndian => {
            let v4 = constructor_vec_merge_low(ctx, arg0, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3620.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_merge_high_lane_order", "src\\isa\\s390x\\inst.isle line 3619")
}

// Generated as internal constructor for term clz_reg.
pub fn constructor_clz_reg<C: Context>(
    ctx: &mut C,
    arg0: i16,
    arg1: Reg,
) -> Reg {
    if arg0 == 64_i16 {
        let v3 = constructor_temp_writable_regpair(ctx, I64);
        let v4 = MInst::Flogr {
            rd: v3,
            rn: arg1,
        };
        let v5 = C::emit(ctx, &v4);
        let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
        let v7 = C::regpair_hi(ctx, v6);
        // Rule at src\isa\s390x\inst.isle line 3634.
        return v7;
    }
    let v3 = constructor_temp_writable_regpair(ctx, I64);
    let v10 = &C::intcc_as_cond(ctx, &IntCC::Equal);
    let v6 = constructor_writable_regpair_to_regpair(ctx, v3);
    let v7 = C::regpair_hi(ctx, v6);
    let v11 = &constructor_cmov_imm(ctx, I64, v10, arg0, v7);
    let v4 = MInst::Flogr {
        rd: v3,
        rn: arg1,
    };
    let v8 = ProducesFlags::ProducesFlagsSideEffect {
        inst: v4,
    };
    let v12 = constructor_with_flags_reg(ctx, &v8, v11);
    // Rule at src\isa\s390x\inst.isle line 3640.
    return v12;
}

// Generated as internal constructor for term vecop_clz.
pub fn constructor_vecop_clz<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3648.
            return VecUnaryOp::Clz8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3649.
            return VecUnaryOp::Clz16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3650.
            return VecUnaryOp::Clz32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3651.
            return VecUnaryOp::Clz64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_clz", "src\\isa\\s390x\\inst.isle line 3647")
}

// Generated as internal constructor for term vec_clz.
pub fn constructor_vec_clz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_clz(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 3654.
    return v3;
}

// Generated as internal constructor for term vecop_ctz.
pub fn constructor_vecop_ctz<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3658.
            return VecUnaryOp::Ctz8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3659.
            return VecUnaryOp::Ctz16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3660.
            return VecUnaryOp::Ctz32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3661.
            return VecUnaryOp::Ctz64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_ctz", "src\\isa\\s390x\\inst.isle line 3657")
}

// Generated as internal constructor for term vec_ctz.
pub fn constructor_vec_ctz<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_ctz(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 3664.
    return v3;
}

// Generated as internal constructor for term uint_sat_reg.
pub fn constructor_uint_sat_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: Reg,
) -> Reg {
    if arg0 == arg1 {
        // Rule at src\isa\s390x\inst.isle line 3670.
        return arg2;
    }
    match arg0 {
        I8 => {
            let v3 = C::ty_32_or_64(ctx, arg1);
            if let Some(v4) = v3 {
                let v6 = &constructor_icmpu_uimm32(ctx, v4, arg2, 0x100_u32);
                let v8 = &C::intcc_as_cond(ctx, &IntCC::UnsignedGreaterThan);
                let v10 = &constructor_cmov_imm(ctx, v4, v8, 255_i16, arg2);
                let v11 = constructor_with_flags_reg(ctx, v6, v10);
                // Rule at src\isa\s390x\inst.isle line 3671.
                return v11;
            }
        }
        I16 => {
            let v3 = C::ty_32_or_64(ctx, arg1);
            if let Some(v4) = v3 {
                let v13 = &constructor_icmpu_uimm32(ctx, v4, arg2, 0xffff_u32);
                let v8 = &C::intcc_as_cond(ctx, &IntCC::UnsignedGreaterThan);
                let v15 = &constructor_cmov_imm(ctx, v4, v8, -1_i16, arg2);
                let v16 = constructor_with_flags_reg(ctx, v13, v15);
                // Rule at src\isa\s390x\inst.isle line 3674.
                return v16;
            }
        }
        I32 => {
            if arg1 == I64 {
                let v19 = constructor_imm(ctx, I64, 0xffffffff_u64);
                let v20 = &constructor_icmpu_reg(ctx, I64, arg2, v19);
                let v21 = &C::intcc_as_cond(ctx, &IntCC::UnsignedGreaterThan);
                let v22 = &constructor_bool(ctx, v20, v21);
                let v23 = constructor_select_bool_reg(ctx, I64, v22, v19, arg2);
                // Rule at src\isa\s390x\inst.isle line 3677.
                return v23;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "uint_sat_reg", "src\\isa\\s390x\\inst.isle line 3669")
}

// Generated as internal constructor for term sint_sat_reg.
pub fn constructor_sint_sat_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: Reg,
) -> Reg {
    if arg0 == arg1 {
        // Rule at src\isa\s390x\inst.isle line 3685.
        return arg2;
    }
    match arg0 {
        I8 => {
            let v3 = C::ty_32_or_64(ctx, arg1);
            if let Some(v4) = v3 {
                let v6 = &constructor_icmps_simm16(ctx, v4, arg2, 127_i16);
                let v8 = &C::intcc_as_cond(ctx, &IntCC::SignedGreaterThan);
                let v9 = &constructor_cmov_imm(ctx, v4, v8, 127_i16, arg2);
                let v10 = constructor_with_flags_reg(ctx, v6, v9);
                let v12 = &constructor_icmps_simm16(ctx, v4, v10, -128_i16);
                let v14 = &C::intcc_as_cond(ctx, &IntCC::SignedLessThan);
                let v15 = &constructor_cmov_imm(ctx, v4, v14, -128_i16, v10);
                let v16 = constructor_with_flags_reg(ctx, v12, v15);
                // Rule at src\isa\s390x\inst.isle line 3686.
                return v16;
            }
        }
        I16 => {
            let v3 = C::ty_32_or_64(ctx, arg1);
            if let Some(v4) = v3 {
                let v18 = &constructor_icmps_simm16(ctx, v4, arg2, 32767_i16);
                let v8 = &C::intcc_as_cond(ctx, &IntCC::SignedGreaterThan);
                let v19 = &constructor_cmov_imm(ctx, v4, v8, 32767_i16, arg2);
                let v20 = constructor_with_flags_reg(ctx, v18, v19);
                let v22 = &constructor_icmps_simm16(ctx, v4, v20, -32768_i16);
                let v14 = &C::intcc_as_cond(ctx, &IntCC::SignedLessThan);
                let v23 = &constructor_cmov_imm(ctx, v4, v14, -32768_i16, v20);
                let v24 = constructor_with_flags_reg(ctx, v22, v23);
                // Rule at src\isa\s390x\inst.isle line 3692.
                return v24;
            }
        }
        I32 => {
            if arg1 == I64 {
                let v27 = constructor_imm32(ctx, I64, 2147483647_i32);
                let v28 = &constructor_icmps_reg(ctx, I64, arg2, v27);
                let v29 = &C::intcc_as_cond(ctx, &IntCC::SignedGreaterThan);
                let v30 = &constructor_bool(ctx, v28, v29);
                let v31 = constructor_select_bool_reg(ctx, I64, v30, v27, arg2);
                let v33 = constructor_imm32(ctx, I64, -2147483648_i32);
                let v34 = &constructor_icmps_reg(ctx, I64, v31, v33);
                let v35 = &C::intcc_as_cond(ctx, &IntCC::SignedLessThan);
                let v36 = &constructor_bool(ctx, v34, v35);
                let v37 = constructor_select_bool_reg(ctx, I64, v36, v33, v31);
                // Rule at src\isa\s390x\inst.isle line 3698.
                return v37;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sint_sat_reg", "src\\isa\\s390x\\inst.isle line 3684")
}

// Generated as internal constructor for term aluop_add.
pub fn constructor_aluop_add<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\inst.isle line 3714.
            return ALUOp::Add32;
        }
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3715.
            return ALUOp::Add32;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3716.
            return ALUOp::Add32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3717.
            return ALUOp::Add64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_add", "src\\isa\\s390x\\inst.isle line 3713")
}

// Generated as internal constructor for term aluop_add_sext16.
pub fn constructor_aluop_add_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3720.
            return ALUOp::Add32Ext16;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3721.
            return ALUOp::Add32Ext16;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3722.
            return ALUOp::Add64Ext16;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_add_sext16", "src\\isa\\s390x\\inst.isle line 3719")
}

// Generated as internal constructor for term aluop_add_sext32.
pub fn constructor_aluop_add_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 3725.
        return ALUOp::Add64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_add_sext32", "src\\isa\\s390x\\inst.isle line 3724")
}

// Generated as internal constructor for term add_reg.
pub fn constructor_add_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_add(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3728.
    return v4;
}

// Generated as internal constructor for term add_reg_sext32.
pub fn constructor_add_reg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_add_sext32(ctx, arg0);
    let v4 = constructor_alu_rr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3731.
    return v4;
}

// Generated as internal constructor for term add_simm16.
pub fn constructor_add_simm16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i16,
) -> Reg {
    let v3 = &constructor_aluop_add(ctx, arg0);
    let v4 = constructor_alu_rrsimm16(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3734.
    return v4;
}

// Generated as internal constructor for term add_simm32.
pub fn constructor_add_simm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i32,
) -> Reg {
    let v3 = &constructor_aluop_add(ctx, arg0);
    let v4 = constructor_alu_rsimm32(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3737.
    return v4;
}

// Generated as internal constructor for term add_mem.
pub fn constructor_add_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_add(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3740.
    return v4;
}

// Generated as internal constructor for term add_mem_sext16.
pub fn constructor_add_mem_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_add_sext16(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3743.
    return v4;
}

// Generated as internal constructor for term add_mem_sext32.
pub fn constructor_add_mem_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_add_sext32(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3746.
    return v4;
}

// Generated as internal constructor for term vecop_add.
pub fn constructor_vecop_add<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I128 => {
            // Rule at src\isa\s390x\inst.isle line 3753.
            return VecBinaryOp::Add128;
        }
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3749.
            return VecBinaryOp::Add8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3750.
            return VecBinaryOp::Add16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3751.
            return VecBinaryOp::Add32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3752.
            return VecBinaryOp::Add64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_add", "src\\isa\\s390x\\inst.isle line 3748")
}

// Generated as internal constructor for term vec_add.
pub fn constructor_vec_add<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_add(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3756.
    return v4;
}

// Generated as internal constructor for term aluop_add_logical.
pub fn constructor_aluop_add_logical<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3762.
            return ALUOp::AddLogical32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3763.
            return ALUOp::AddLogical64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_add_logical", "src\\isa\\s390x\\inst.isle line 3761")
}

// Generated as internal constructor for term aluop_add_logical_zext32.
pub fn constructor_aluop_add_logical_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 3766.
        return ALUOp::AddLogical64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_add_logical_zext32", "src\\isa\\s390x\\inst.isle line 3765")
}

// Generated as internal constructor for term add_logical_reg.
pub fn constructor_add_logical_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_add_logical(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3769.
    return v4;
}

// Generated as internal constructor for term add_logical_reg_with_flags_paired.
pub fn constructor_add_logical_reg_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v3 = &constructor_aluop_add_logical(ctx, arg0);
    let v4 = &constructor_alu_rrr_with_flags_paired(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3772.
    return v4.clone();
}

// Generated as internal constructor for term add_logical_reg_zext32.
pub fn constructor_add_logical_reg_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_add_logical_zext32(ctx, arg0);
    let v4 = constructor_alu_rr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3776.
    return v4;
}

// Generated as internal constructor for term add_logical_reg_zext32_with_flags_paired.
pub fn constructor_add_logical_reg_zext32_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v3 = &constructor_aluop_add_logical_zext32(ctx, arg0);
    let v4 = &constructor_alu_rr_with_flags_paired(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3779.
    return v4.clone();
}

// Generated as internal constructor for term add_logical_zimm32.
pub fn constructor_add_logical_zimm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u32,
) -> Reg {
    let v3 = &constructor_aluop_add_logical(ctx, arg0);
    let v4 = constructor_alu_ruimm32(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3783.
    return v4;
}

// Generated as internal constructor for term add_logical_zimm32_with_flags_paired.
pub fn constructor_add_logical_zimm32_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u32,
) -> ProducesFlags {
    let v3 = &constructor_aluop_add_logical(ctx, arg0);
    let v4 = &constructor_alu_ruimm32_with_flags_paired(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3786.
    return v4.clone();
}

// Generated as internal constructor for term add_logical_mem.
pub fn constructor_add_logical_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_add_logical(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3790.
    return v4;
}

// Generated as internal constructor for term add_logical_mem_with_flags_paired.
pub fn constructor_add_logical_mem_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_aluop_add_logical(ctx, arg0);
    let v4 = &constructor_alu_rx_with_flags_paired(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3793.
    return v4.clone();
}

// Generated as internal constructor for term add_logical_mem_zext32.
pub fn constructor_add_logical_mem_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_add_logical_zext32(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3797.
    return v4;
}

// Generated as internal constructor for term add_logical_mem_zext32_with_flags_paired.
pub fn constructor_add_logical_mem_zext32_with_flags_paired<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_aluop_add_logical_zext32(ctx, arg0);
    let v4 = &constructor_alu_rx_with_flags_paired(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3800.
    return v4.clone();
}

// Generated as internal constructor for term aluop_sub.
pub fn constructor_aluop_sub<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\inst.isle line 3807.
            return ALUOp::Sub32;
        }
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3808.
            return ALUOp::Sub32;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3809.
            return ALUOp::Sub32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3810.
            return ALUOp::Sub64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_sub", "src\\isa\\s390x\\inst.isle line 3806")
}

// Generated as internal constructor for term aluop_sub_sext16.
pub fn constructor_aluop_sub_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3813.
            return ALUOp::Sub32Ext16;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3814.
            return ALUOp::Sub32Ext16;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3815.
            return ALUOp::Sub64Ext16;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_sub_sext16", "src\\isa\\s390x\\inst.isle line 3812")
}

// Generated as internal constructor for term aluop_sub_sext32.
pub fn constructor_aluop_sub_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 3818.
        return ALUOp::Sub64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_sub_sext32", "src\\isa\\s390x\\inst.isle line 3817")
}

// Generated as internal constructor for term sub_reg.
pub fn constructor_sub_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_sub(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3821.
    return v4;
}

// Generated as internal constructor for term sub_reg_sext32.
pub fn constructor_sub_reg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_sub_sext32(ctx, arg0);
    let v4 = constructor_alu_rr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3824.
    return v4;
}

// Generated as internal constructor for term sub_mem.
pub fn constructor_sub_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_sub(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3827.
    return v4;
}

// Generated as internal constructor for term sub_mem_sext16.
pub fn constructor_sub_mem_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_sub_sext16(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3830.
    return v4;
}

// Generated as internal constructor for term sub_mem_sext32.
pub fn constructor_sub_mem_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_sub_sext32(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3833.
    return v4;
}

// Generated as internal constructor for term vecop_sub.
pub fn constructor_vecop_sub<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I128 => {
            // Rule at src\isa\s390x\inst.isle line 3840.
            return VecBinaryOp::Sub128;
        }
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3836.
            return VecBinaryOp::Sub8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3837.
            return VecBinaryOp::Sub16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3838.
            return VecBinaryOp::Sub32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3839.
            return VecBinaryOp::Sub64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_sub", "src\\isa\\s390x\\inst.isle line 3835")
}

// Generated as internal constructor for term vec_sub.
pub fn constructor_vec_sub<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_sub(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3843.
    return v4;
}

// Generated as internal constructor for term aluop_sub_logical.
pub fn constructor_aluop_sub_logical<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3849.
            return ALUOp::SubLogical32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3850.
            return ALUOp::SubLogical64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_sub_logical", "src\\isa\\s390x\\inst.isle line 3848")
}

// Generated as internal constructor for term aluop_sub_logical_zext32.
pub fn constructor_aluop_sub_logical_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 3853.
        return ALUOp::SubLogical64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_sub_logical_zext32", "src\\isa\\s390x\\inst.isle line 3852")
}

// Generated as internal constructor for term sub_logical_reg.
pub fn constructor_sub_logical_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_sub_logical(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3856.
    return v4;
}

// Generated as internal constructor for term sub_logical_reg_zext32.
pub fn constructor_sub_logical_reg_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_sub_logical_zext32(ctx, arg0);
    let v4 = constructor_alu_rr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3859.
    return v4;
}

// Generated as internal constructor for term sub_logical_zimm32.
pub fn constructor_sub_logical_zimm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u32,
) -> Reg {
    let v3 = &constructor_aluop_sub_logical(ctx, arg0);
    let v4 = constructor_alu_ruimm32(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3862.
    return v4;
}

// Generated as internal constructor for term sub_logical_mem.
pub fn constructor_sub_logical_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_sub_logical(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3865.
    return v4;
}

// Generated as internal constructor for term sub_logical_mem_zext32.
pub fn constructor_sub_logical_mem_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_sub_logical(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3868.
    return v4;
}

// Generated as internal constructor for term aluop_mul.
pub fn constructor_aluop_mul<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\inst.isle line 3874.
            return ALUOp::Mul32;
        }
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3875.
            return ALUOp::Mul32;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3876.
            return ALUOp::Mul32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3877.
            return ALUOp::Mul64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_mul", "src\\isa\\s390x\\inst.isle line 3873")
}

// Generated as internal constructor for term aluop_mul_sext16.
pub fn constructor_aluop_mul_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    match arg0 {
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 3880.
            return ALUOp::Mul32Ext16;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 3881.
            return ALUOp::Mul32Ext16;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 3882.
            return ALUOp::Mul64Ext16;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_mul_sext16", "src\\isa\\s390x\\inst.isle line 3879")
}

// Generated as internal constructor for term aluop_mul_sext32.
pub fn constructor_aluop_mul_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 3885.
        return ALUOp::Mul64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_mul_sext32", "src\\isa\\s390x\\inst.isle line 3884")
}

// Generated as internal constructor for term mul_reg.
pub fn constructor_mul_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_mul(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3888.
    return v4;
}

// Generated as internal constructor for term mul_reg_sext32.
pub fn constructor_mul_reg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_mul_sext32(ctx, arg0);
    let v4 = constructor_alu_rr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3891.
    return v4;
}

// Generated as internal constructor for term mul_simm16.
pub fn constructor_mul_simm16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i16,
) -> Reg {
    let v3 = &constructor_aluop_mul(ctx, arg0);
    let v4 = constructor_alu_rsimm16(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3894.
    return v4;
}

// Generated as internal constructor for term mul_simm32.
pub fn constructor_mul_simm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i32,
) -> Reg {
    let v3 = &constructor_aluop_mul(ctx, arg0);
    let v4 = constructor_alu_rsimm32(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3897.
    return v4;
}

// Generated as internal constructor for term mul_mem.
pub fn constructor_mul_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_mul(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3900.
    return v4;
}

// Generated as internal constructor for term mul_mem_sext16.
pub fn constructor_mul_mem_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_mul_sext16(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3903.
    return v4;
}

// Generated as internal constructor for term mul_mem_sext32.
pub fn constructor_mul_mem_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_mul_sext32(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3906.
    return v4;
}

// Generated as internal constructor for term vecop_mul.
pub fn constructor_vecop_mul<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3909.
            return VecBinaryOp::Mul8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3910.
            return VecBinaryOp::Mul16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3911.
            return VecBinaryOp::Mul32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_mul", "src\\isa\\s390x\\inst.isle line 3908")
}

// Generated as internal constructor for term vec_mul.
pub fn constructor_vec_mul<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_mul(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3915.
    return v4;
}

// Generated as internal constructor for term vecop_umulhi.
pub fn constructor_vecop_umulhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3918.
            return VecBinaryOp::UMulHi8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3919.
            return VecBinaryOp::UMulHi16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3920.
            return VecBinaryOp::UMulHi32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_umulhi", "src\\isa\\s390x\\inst.isle line 3917")
}

// Generated as internal constructor for term vec_umulhi.
pub fn constructor_vec_umulhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_umulhi(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3924.
    return v4;
}

// Generated as internal constructor for term vecop_smulhi.
pub fn constructor_vecop_smulhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3927.
            return VecBinaryOp::SMulHi8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3928.
            return VecBinaryOp::SMulHi16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3929.
            return VecBinaryOp::SMulHi32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_smulhi", "src\\isa\\s390x\\inst.isle line 3926")
}

// Generated as internal constructor for term vec_smulhi.
pub fn constructor_vec_smulhi<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_smulhi(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3933.
    return v4;
}

// Generated as internal constructor for term vecop_umul_even.
pub fn constructor_vecop_umul_even<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3936.
            return VecBinaryOp::UMulEven8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3937.
            return VecBinaryOp::UMulEven16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3938.
            return VecBinaryOp::UMulEven32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_umul_even", "src\\isa\\s390x\\inst.isle line 3935")
}

// Generated as internal constructor for term vec_umul_even.
pub fn constructor_vec_umul_even<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_umul_even(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3942.
    return v4;
}

// Generated as internal constructor for term vecop_smul_even.
pub fn constructor_vecop_smul_even<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3945.
            return VecBinaryOp::SMulEven8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3946.
            return VecBinaryOp::SMulEven16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3947.
            return VecBinaryOp::SMulEven32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_smul_even", "src\\isa\\s390x\\inst.isle line 3944")
}

// Generated as internal constructor for term vec_smul_even.
pub fn constructor_vec_smul_even<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_smul_even(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3951.
    return v4;
}

// Generated as internal constructor for term vecop_umul_odd.
pub fn constructor_vecop_umul_odd<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3954.
            return VecBinaryOp::UMulOdd8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3955.
            return VecBinaryOp::UMulOdd16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3956.
            return VecBinaryOp::UMulOdd32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_umul_odd", "src\\isa\\s390x\\inst.isle line 3953")
}

// Generated as internal constructor for term vec_umul_odd.
pub fn constructor_vec_umul_odd<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_umul_odd(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3960.
    return v4;
}

// Generated as internal constructor for term vecop_smul_odd.
pub fn constructor_vecop_smul_odd<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3963.
            return VecBinaryOp::SMulOdd8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3964.
            return VecBinaryOp::SMulOdd16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3965.
            return VecBinaryOp::SMulOdd32x4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_smul_odd", "src\\isa\\s390x\\inst.isle line 3962")
}

// Generated as internal constructor for term vec_smul_odd.
pub fn constructor_vec_smul_odd<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_smul_odd(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3969.
    return v4;
}

// Generated as internal constructor for term udivmod.
pub fn constructor_udivmod<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: RegPair,
    arg2: Reg,
) -> RegPair {
    match arg0 {
        I32 => {
            let v3 = constructor_udivmod32(ctx, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3975.
            return v3;
        }
        I64 => {
            let v4 = constructor_udivmod64(ctx, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3976.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "udivmod", "src\\isa\\s390x\\inst.isle line 3974")
}

// Generated as internal constructor for term sdivmod.
pub fn constructor_sdivmod<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> RegPair {
    match arg0 {
        I32 => {
            let v3 = constructor_sdivmod32(ctx, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3982.
            return v3;
        }
        I64 => {
            let v4 = constructor_sdivmod64(ctx, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 3983.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sdivmod", "src\\isa\\s390x\\inst.isle line 3981")
}

// Generated as internal constructor for term vecop_umax.
pub fn constructor_vecop_umax<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 3989.
            return VecBinaryOp::UMax8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 3990.
            return VecBinaryOp::UMax16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 3991.
            return VecBinaryOp::UMax32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 3992.
            return VecBinaryOp::UMax64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_umax", "src\\isa\\s390x\\inst.isle line 3988")
}

// Generated as internal constructor for term vec_umax.
pub fn constructor_vec_umax<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_umax(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 3995.
    return v4;
}

// Generated as internal constructor for term vecop_smax.
pub fn constructor_vecop_smax<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4001.
            return VecBinaryOp::SMax8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4002.
            return VecBinaryOp::SMax16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4003.
            return VecBinaryOp::SMax32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4004.
            return VecBinaryOp::SMax64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_smax", "src\\isa\\s390x\\inst.isle line 4000")
}

// Generated as internal constructor for term vec_smax.
pub fn constructor_vec_smax<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_smax(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4007.
    return v4;
}

// Generated as internal constructor for term vecop_umin.
pub fn constructor_vecop_umin<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4013.
            return VecBinaryOp::UMin8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4014.
            return VecBinaryOp::UMin16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4015.
            return VecBinaryOp::UMin32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4016.
            return VecBinaryOp::UMin64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_umin", "src\\isa\\s390x\\inst.isle line 4012")
}

// Generated as internal constructor for term vec_umin.
pub fn constructor_vec_umin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_umin(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4019.
    return v4;
}

// Generated as internal constructor for term vecop_smin.
pub fn constructor_vecop_smin<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4025.
            return VecBinaryOp::SMin8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4026.
            return VecBinaryOp::SMin16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4027.
            return VecBinaryOp::SMin32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4028.
            return VecBinaryOp::SMin64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_smin", "src\\isa\\s390x\\inst.isle line 4024")
}

// Generated as internal constructor for term vec_smin.
pub fn constructor_vec_smin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_smin(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4031.
    return v4;
}

// Generated as internal constructor for term vecop_uavg.
pub fn constructor_vecop_uavg<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecBinaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4037.
            return VecBinaryOp::UAvg8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4038.
            return VecBinaryOp::UAvg16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4039.
            return VecBinaryOp::UAvg32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4040.
            return VecBinaryOp::UAvg64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_uavg", "src\\isa\\s390x\\inst.isle line 4036")
}

// Generated as internal constructor for term vec_uavg.
pub fn constructor_vec_uavg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vecop_uavg(ctx, arg0);
    let v4 = constructor_vec_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4043.
    return v4;
}

// Generated as internal constructor for term aluop_and.
pub fn constructor_aluop_and<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4050.
        return ALUOp::And64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4049.
        return ALUOp::And32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_and", "src\\isa\\s390x\\inst.isle line 4048")
}

// Generated as internal constructor for term and_reg.
pub fn constructor_and_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_and(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4053.
    return v4;
}

// Generated as internal constructor for term and_uimm16shifted.
pub fn constructor_and_uimm16shifted<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: UImm16Shifted,
) -> Reg {
    let v3 = &constructor_aluop_and(ctx, arg0);
    let v4 = constructor_alu_ruimm16shifted(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4056.
    return v4;
}

// Generated as internal constructor for term and_uimm32shifted.
pub fn constructor_and_uimm32shifted<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: UImm32Shifted,
) -> Reg {
    let v3 = &constructor_aluop_and(ctx, arg0);
    let v4 = constructor_alu_ruimm32shifted(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4059.
    return v4;
}

// Generated as internal constructor for term and_mem.
pub fn constructor_and_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_and(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4062.
    return v4;
}

// Generated as internal constructor for term vec_and.
pub fn constructor_vec_and<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::And128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4065.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_and", "src\\isa\\s390x\\inst.isle line 4064")
}

// Generated as internal constructor for term aluop_or.
pub fn constructor_aluop_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4072.
        return ALUOp::Orr64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4071.
        return ALUOp::Orr32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_or", "src\\isa\\s390x\\inst.isle line 4070")
}

// Generated as internal constructor for term or_reg.
pub fn constructor_or_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_or(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4075.
    return v4;
}

// Generated as internal constructor for term or_uimm16shifted.
pub fn constructor_or_uimm16shifted<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: UImm16Shifted,
) -> Reg {
    let v3 = &constructor_aluop_or(ctx, arg0);
    let v4 = constructor_alu_ruimm16shifted(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4078.
    return v4;
}

// Generated as internal constructor for term or_uimm32shifted.
pub fn constructor_or_uimm32shifted<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: UImm32Shifted,
) -> Reg {
    let v3 = &constructor_aluop_or(ctx, arg0);
    let v4 = constructor_alu_ruimm32shifted(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4081.
    return v4;
}

// Generated as internal constructor for term or_mem.
pub fn constructor_or_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_or(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4084.
    return v4;
}

// Generated as internal constructor for term vec_or.
pub fn constructor_vec_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::Orr128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4087.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_or", "src\\isa\\s390x\\inst.isle line 4086")
}

// Generated as internal constructor for term aluop_xor.
pub fn constructor_aluop_xor<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4094.
        return ALUOp::Xor64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4093.
        return ALUOp::Xor32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_xor", "src\\isa\\s390x\\inst.isle line 4092")
}

// Generated as internal constructor for term xor_reg.
pub fn constructor_xor_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_xor(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4097.
    return v4;
}

// Generated as internal constructor for term xor_uimm32shifted.
pub fn constructor_xor_uimm32shifted<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: UImm32Shifted,
) -> Reg {
    let v3 = &constructor_aluop_xor(ctx, arg0);
    let v4 = constructor_alu_ruimm32shifted(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4100.
    return v4;
}

// Generated as internal constructor for term xor_mem.
pub fn constructor_xor_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    let v3 = &constructor_aluop_xor(ctx, arg0);
    let v4 = constructor_alu_rx(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4103.
    return v4;
}

// Generated as internal constructor for term push_xor_uimm32shifted.
pub fn constructor_push_xor_uimm32shifted<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: WritableReg,
    arg3: Reg,
    arg4: UImm32Shifted,
) -> Reg {
    let v5 = &constructor_aluop_xor(ctx, arg1);
    let v6 = constructor_push_alu_uimm32shifted(ctx, arg0, v5, arg2, arg3, arg4);
    // Rule at src\isa\s390x\inst.isle line 4106.
    return v6;
}

// Generated as internal constructor for term vec_xor.
pub fn constructor_vec_xor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::Xor128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4110.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_xor", "src\\isa\\s390x\\inst.isle line 4109")
}

// Generated as internal constructor for term not_reg.
pub fn constructor_not_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v8 = C::gpr64_ty(ctx, arg0);
    if let Some(v9) = v8 {
        let v6 = C::uimm32shifted(ctx, 0xffffffff_u32, 0x0_u8);
        let v10 = constructor_xor_uimm32shifted(ctx, v9, arg1, v6);
        let v12 = C::uimm32shifted(ctx, 0xffffffff_u32, 0x20_u8);
        let v13 = constructor_xor_uimm32shifted(ctx, v9, v10, v12);
        // Rule at src\isa\s390x\inst.isle line 4118.
        return v13;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = C::uimm32shifted(ctx, 0xffffffff_u32, 0x0_u8);
        let v7 = constructor_xor_uimm32shifted(ctx, v2, arg1, v6);
        // Rule at src\isa\s390x\inst.isle line 4116.
        return v7;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "not_reg", "src\\isa\\s390x\\inst.isle line 4115")
}

// Generated as internal constructor for term push_not_reg.
pub fn constructor_push_not_reg<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: WritableReg,
    arg3: Reg,
) -> Reg {
    let v10 = C::gpr64_ty(ctx, arg1);
    if let Some(v11) = v10 {
        let v8 = C::uimm32shifted(ctx, 0xffffffff_u32, 0x0_u8);
        let v12 = constructor_push_xor_uimm32shifted(ctx, arg0, v11, arg2, arg3, v8);
        let v14 = C::uimm32shifted(ctx, 0xffffffff_u32, 0x20_u8);
        let v15 = constructor_push_xor_uimm32shifted(ctx, arg0, v11, arg2, v12, v14);
        // Rule at src\isa\s390x\inst.isle line 4126.
        return v15;
    }
    let v2 = C::gpr32_ty(ctx, arg1);
    if let Some(v3) = v2 {
        let v8 = C::uimm32shifted(ctx, 0xffffffff_u32, 0x0_u8);
        let v9 = constructor_push_xor_uimm32shifted(ctx, arg0, v3, arg2, arg3, v8);
        // Rule at src\isa\s390x\inst.isle line 4124.
        return v9;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_not_reg", "src\\isa\\s390x\\inst.isle line 4123")
}

// Generated as internal constructor for term vec_not.
pub fn constructor_vec_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = constructor_vec_not_or(ctx, arg0, arg1, arg1);
    // Rule at src\isa\s390x\inst.isle line 4131.
    return v2;
}

// Generated as internal constructor for term aluop_not_and.
pub fn constructor_aluop_not_and<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4138.
        return ALUOp::NotAnd64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4137.
        return ALUOp::NotAnd32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_not_and", "src\\isa\\s390x\\inst.isle line 4136")
}

// Generated as internal constructor for term not_and_reg.
pub fn constructor_not_and_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_not_and(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4141.
    return v4;
}

// Generated as internal constructor for term vec_not_and.
pub fn constructor_vec_not_and<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::NotAnd128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4144.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_not_and", "src\\isa\\s390x\\inst.isle line 4143")
}

// Generated as internal constructor for term aluop_not_or.
pub fn constructor_aluop_not_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4151.
        return ALUOp::NotOrr64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4150.
        return ALUOp::NotOrr32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_not_or", "src\\isa\\s390x\\inst.isle line 4149")
}

// Generated as internal constructor for term not_or_reg.
pub fn constructor_not_or_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_not_or(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4154.
    return v4;
}

// Generated as internal constructor for term vec_not_or.
pub fn constructor_vec_not_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::NotOrr128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4157.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_not_or", "src\\isa\\s390x\\inst.isle line 4156")
}

// Generated as internal constructor for term aluop_not_xor.
pub fn constructor_aluop_not_xor<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4164.
        return ALUOp::NotXor64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4163.
        return ALUOp::NotXor32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_not_xor", "src\\isa\\s390x\\inst.isle line 4162")
}

// Generated as internal constructor for term not_xor_reg.
pub fn constructor_not_xor_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_not_xor(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4167.
    return v4;
}

// Generated as internal constructor for term vec_not_xor.
pub fn constructor_vec_not_xor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::NotXor128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4170.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_not_xor", "src\\isa\\s390x\\inst.isle line 4169")
}

// Generated as internal constructor for term aluop_and_not.
pub fn constructor_aluop_and_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4177.
        return ALUOp::AndNot64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4176.
        return ALUOp::AndNot32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_and_not", "src\\isa\\s390x\\inst.isle line 4175")
}

// Generated as internal constructor for term and_not_reg.
pub fn constructor_and_not_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_and_not(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4180.
    return v4;
}

// Generated as internal constructor for term vec_and_not.
pub fn constructor_vec_and_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::AndNot128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4183.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_and_not", "src\\isa\\s390x\\inst.isle line 4182")
}

// Generated as internal constructor for term aluop_or_not.
pub fn constructor_aluop_or_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ALUOp {
    let v4 = C::gpr64_ty(ctx, arg0);
    if let Some(v5) = v4 {
        // Rule at src\isa\s390x\inst.isle line 4190.
        return ALUOp::OrrNot64;
    }
    let v1 = C::gpr32_ty(ctx, arg0);
    if let Some(v2) = v1 {
        // Rule at src\isa\s390x\inst.isle line 4189.
        return ALUOp::OrrNot32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "aluop_or_not", "src\\isa\\s390x\\inst.isle line 4188")
}

// Generated as internal constructor for term or_not_reg.
pub fn constructor_or_not_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_aluop_or_not(ctx, arg0);
    let v4 = constructor_alu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4193.
    return v4;
}

// Generated as internal constructor for term vec_or_not.
pub fn constructor_vec_or_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::vr128_ty(ctx, arg0);
    if let Some(v2) = v1 {
        let v6 = constructor_vec_rrr(ctx, v2, &VecBinaryOp::OrrNot128, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4196.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_or_not", "src\\isa\\s390x\\inst.isle line 4195")
}

// Generated as internal constructor for term vec_bitpermute.
pub fn constructor_vec_bitpermute<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> Reg {
    let v4 = constructor_vec_rrr(ctx, I64X2, &VecBinaryOp::BitPermute128, arg0, arg1);
    // Rule at src\isa\s390x\inst.isle line 4202.
    return v4;
}

// Generated as internal constructor for term unaryop_abs.
pub fn constructor_unaryop_abs<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> UnaryOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4208.
            return UnaryOp::Abs32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4209.
            return UnaryOp::Abs64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "unaryop_abs", "src\\isa\\s390x\\inst.isle line 4207")
}

// Generated as internal constructor for term unaryop_abs_sext32.
pub fn constructor_unaryop_abs_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> UnaryOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 4212.
        return UnaryOp::Abs64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "unaryop_abs_sext32", "src\\isa\\s390x\\inst.isle line 4211")
}

// Generated as internal constructor for term abs_reg.
pub fn constructor_abs_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_unaryop_abs(ctx, arg0);
    let v3 = constructor_unary_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4215.
    return v3;
}

// Generated as internal constructor for term abs_reg_sext32.
pub fn constructor_abs_reg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_unaryop_abs_sext32(ctx, arg0);
    let v3 = constructor_unary_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4218.
    return v3;
}

// Generated as internal constructor for term vecop_abs.
pub fn constructor_vecop_abs<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4221.
            return VecUnaryOp::Abs8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4222.
            return VecUnaryOp::Abs16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4223.
            return VecUnaryOp::Abs32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4224.
            return VecUnaryOp::Abs64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_abs", "src\\isa\\s390x\\inst.isle line 4220")
}

// Generated as internal constructor for term vec_abs.
pub fn constructor_vec_abs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_abs(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4227.
    return v3;
}

// Generated as internal constructor for term unaryop_neg.
pub fn constructor_unaryop_neg<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> UnaryOp {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\inst.isle line 4233.
            return UnaryOp::Neg32;
        }
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 4234.
            return UnaryOp::Neg32;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4235.
            return UnaryOp::Neg32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4236.
            return UnaryOp::Neg64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "unaryop_neg", "src\\isa\\s390x\\inst.isle line 4232")
}

// Generated as internal constructor for term unaryop_neg_sext32.
pub fn constructor_unaryop_neg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> UnaryOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 4239.
        return UnaryOp::Neg64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "unaryop_neg_sext32", "src\\isa\\s390x\\inst.isle line 4238")
}

// Generated as internal constructor for term neg_reg.
pub fn constructor_neg_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_unaryop_neg(ctx, arg0);
    let v3 = constructor_unary_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4242.
    return v3;
}

// Generated as internal constructor for term neg_reg_sext32.
pub fn constructor_neg_reg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_unaryop_neg_sext32(ctx, arg0);
    let v3 = constructor_unary_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4245.
    return v3;
}

// Generated as internal constructor for term vecop_neg.
pub fn constructor_vecop_neg<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4248.
            return VecUnaryOp::Neg8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4249.
            return VecUnaryOp::Neg16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4250.
            return VecUnaryOp::Neg32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4251.
            return VecUnaryOp::Neg64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_neg", "src\\isa\\s390x\\inst.isle line 4247")
}

// Generated as internal constructor for term vec_neg.
pub fn constructor_vec_neg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_neg(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4254.
    return v3;
}

// Generated as internal constructor for term unaryop_bswap.
pub fn constructor_unaryop_bswap<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> UnaryOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4260.
            return UnaryOp::BSwap32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4261.
            return UnaryOp::BSwap64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "unaryop_bswap", "src\\isa\\s390x\\inst.isle line 4259")
}

// Generated as internal constructor for term bswap_reg.
pub fn constructor_bswap_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_unaryop_bswap(ctx, arg0);
    let v3 = constructor_unary_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4264.
    return v3;
}

// Generated as internal constructor for term push_bswap_reg.
pub fn constructor_push_bswap_reg<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: WritableReg,
    arg3: Reg,
) -> Reg {
    let v4 = &constructor_unaryop_bswap(ctx, arg1);
    let v5 = constructor_push_unary(ctx, arg0, v4, arg2, arg3);
    // Rule at src\isa\s390x\inst.isle line 4267.
    return v5;
}

// Generated as internal constructor for term shiftop_rot.
pub fn constructor_shiftop_rot<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ShiftOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4273.
            return ShiftOp::RotL32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4274.
            return ShiftOp::RotL64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "shiftop_rot", "src\\isa\\s390x\\inst.isle line 4272")
}

// Generated as internal constructor for term rot_reg.
pub fn constructor_rot_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_shiftop_rot(ctx, arg0);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4277.
    return v5;
}

// Generated as internal constructor for term rot_imm.
pub fn constructor_rot_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_shiftop_rot(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4281.
    return v5;
}

// Generated as internal constructor for term rot_imm_reg.
pub fn constructor_rot_imm_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
    arg3: Reg,
) -> Reg {
    let v4 = &constructor_shiftop_rot(ctx, arg0);
    let v5 = constructor_shift_rr(ctx, arg0, v4, arg1, arg2, arg3);
    // Rule at src\isa\s390x\inst.isle line 4285.
    return v5;
}

// Generated as internal constructor for term push_rot_imm_reg.
pub fn constructor_push_rot_imm_reg<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: WritableReg,
    arg3: Reg,
    arg4: u8,
    arg5: Reg,
) -> Reg {
    let v6 = &constructor_shiftop_rot(ctx, arg1);
    let v7 = constructor_push_shift(ctx, arg0, v6, arg2, arg3, arg4, arg5);
    // Rule at src\isa\s390x\inst.isle line 4289.
    return v7;
}

// Generated as internal constructor for term vec_shiftop_rot.
pub fn constructor_vec_shiftop_rot<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecShiftOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4293.
            return VecShiftOp::RotL8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4294.
            return VecShiftOp::RotL16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4295.
            return VecShiftOp::RotL32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4296.
            return VecShiftOp::RotL64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_shiftop_rot", "src\\isa\\s390x\\inst.isle line 4292")
}

// Generated as internal constructor for term vec_rot_reg.
pub fn constructor_vec_rot_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vec_shiftop_rot(ctx, arg0);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4299.
    return v5;
}

// Generated as internal constructor for term vec_rot_imm.
pub fn constructor_vec_rot_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_vec_shiftop_rot(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4303.
    return v5;
}

// Generated as internal constructor for term shiftop_lshl.
pub fn constructor_shiftop_lshl<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ShiftOp {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\inst.isle line 4310.
            return ShiftOp::LShL32;
        }
        I16 => {
            // Rule at src\isa\s390x\inst.isle line 4311.
            return ShiftOp::LShL32;
        }
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4312.
            return ShiftOp::LShL32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4313.
            return ShiftOp::LShL64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "shiftop_lshl", "src\\isa\\s390x\\inst.isle line 4309")
}

// Generated as internal constructor for term lshl_reg.
pub fn constructor_lshl_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_shiftop_lshl(ctx, arg0);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4316.
    return v5;
}

// Generated as internal constructor for term lshl_imm.
pub fn constructor_lshl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_shiftop_lshl(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4320.
    return v5;
}

// Generated as internal constructor for term vec_shiftop_lshl.
pub fn constructor_vec_shiftop_lshl<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecShiftOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4324.
            return VecShiftOp::LShL8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4325.
            return VecShiftOp::LShL16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4326.
            return VecShiftOp::LShL32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4327.
            return VecShiftOp::LShL64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_shiftop_lshl", "src\\isa\\s390x\\inst.isle line 4323")
}

// Generated as internal constructor for term vec_lshl_reg.
pub fn constructor_vec_lshl_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vec_shiftop_lshl(ctx, arg0);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4330.
    return v5;
}

// Generated as internal constructor for term vec_lshl_imm.
pub fn constructor_vec_lshl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_vec_shiftop_lshl(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4334.
    return v5;
}

// Generated as internal constructor for term vec_lshl_by_byte.
pub fn constructor_vec_lshl_by_byte<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> Reg {
    let v4 = constructor_vec_rrr(ctx, I8X16, &VecBinaryOp::LShLByByte128, arg0, arg1);
    // Rule at src\isa\s390x\inst.isle line 4338.
    return v4;
}

// Generated as internal constructor for term vec_lshl_by_bit.
pub fn constructor_vec_lshl_by_bit<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> Reg {
    let v4 = constructor_vec_rrr(ctx, I8X16, &VecBinaryOp::LShLByBit128, arg0, arg1);
    // Rule at src\isa\s390x\inst.isle line 4341.
    return v4;
}

// Generated as internal constructor for term shiftop_lshr.
pub fn constructor_shiftop_lshr<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ShiftOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4347.
            return ShiftOp::LShR32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4348.
            return ShiftOp::LShR64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "shiftop_lshr", "src\\isa\\s390x\\inst.isle line 4346")
}

// Generated as internal constructor for term lshr_reg.
pub fn constructor_lshr_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_shiftop_lshr(ctx, arg0);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4351.
    return v5;
}

// Generated as internal constructor for term lshr_imm.
pub fn constructor_lshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_shiftop_lshr(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4355.
    return v5;
}

// Generated as internal constructor for term vec_shiftop_lshr.
pub fn constructor_vec_shiftop_lshr<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecShiftOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4359.
            return VecShiftOp::LShR8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4360.
            return VecShiftOp::LShR16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4361.
            return VecShiftOp::LShR32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4362.
            return VecShiftOp::LShR64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_shiftop_lshr", "src\\isa\\s390x\\inst.isle line 4358")
}

// Generated as internal constructor for term vec_lshr_reg.
pub fn constructor_vec_lshr_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vec_shiftop_lshr(ctx, arg0);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4365.
    return v5;
}

// Generated as internal constructor for term vec_lshr_imm.
pub fn constructor_vec_lshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_vec_shiftop_lshr(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4369.
    return v5;
}

// Generated as internal constructor for term vec_lshr_by_byte.
pub fn constructor_vec_lshr_by_byte<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> Reg {
    let v4 = constructor_vec_rrr(ctx, I8X16, &VecBinaryOp::LShRByByte128, arg0, arg1);
    // Rule at src\isa\s390x\inst.isle line 4373.
    return v4;
}

// Generated as internal constructor for term vec_lshr_by_bit.
pub fn constructor_vec_lshr_by_bit<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> Reg {
    let v4 = constructor_vec_rrr(ctx, I8X16, &VecBinaryOp::LShRByBit128, arg0, arg1);
    // Rule at src\isa\s390x\inst.isle line 4376.
    return v4;
}

// Generated as internal constructor for term shiftop_ashr.
pub fn constructor_shiftop_ashr<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> ShiftOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4382.
            return ShiftOp::AShR32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4383.
            return ShiftOp::AShR64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "shiftop_ashr", "src\\isa\\s390x\\inst.isle line 4381")
}

// Generated as internal constructor for term ashr_reg.
pub fn constructor_ashr_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_shiftop_ashr(ctx, arg0);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4386.
    return v5;
}

// Generated as internal constructor for term ashr_imm.
pub fn constructor_ashr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_shiftop_ashr(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4390.
    return v5;
}

// Generated as internal constructor for term vec_shiftop_ashr.
pub fn constructor_vec_shiftop_ashr<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecShiftOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4394.
            return VecShiftOp::AShR8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4395.
            return VecShiftOp::AShR16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4396.
            return VecShiftOp::AShR32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4397.
            return VecShiftOp::AShR64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_shiftop_ashr", "src\\isa\\s390x\\inst.isle line 4393")
}

// Generated as internal constructor for term vec_ashr_reg.
pub fn constructor_vec_ashr_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_vec_shiftop_ashr(ctx, arg0);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, 0x0_u8, arg2);
    // Rule at src\isa\s390x\inst.isle line 4400.
    return v5;
}

// Generated as internal constructor for term vec_ashr_imm.
pub fn constructor_vec_ashr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
) -> Reg {
    let v3 = &constructor_vec_shiftop_ashr(ctx, arg0);
    let v4 = C::zero_reg(ctx);
    let v5 = constructor_vec_shift_rr(ctx, arg0, v3, arg1, arg2, v4);
    // Rule at src\isa\s390x\inst.isle line 4404.
    return v5;
}

// Generated as internal constructor for term vec_ashr_by_byte.
pub fn constructor_vec_ashr_by_byte<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> Reg {
    let v4 = constructor_vec_rrr(ctx, I8X16, &VecBinaryOp::AShRByByte128, arg0, arg1);
    // Rule at src\isa\s390x\inst.isle line 4408.
    return v4;
}

// Generated as internal constructor for term vec_ashr_by_bit.
pub fn constructor_vec_ashr_by_bit<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
) -> Reg {
    let v4 = constructor_vec_rrr(ctx, I8X16, &VecBinaryOp::AShRByBit128, arg0, arg1);
    // Rule at src\isa\s390x\inst.isle line 4411.
    return v4;
}

// Generated as internal constructor for term popcnt_byte.
pub fn constructor_popcnt_byte<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> Reg {
    let v3 = constructor_unary_rr(ctx, I64, &UnaryOp::PopcntByte, arg0);
    // Rule at src\isa\s390x\inst.isle line 4417.
    return v3;
}

// Generated as internal constructor for term popcnt_reg.
pub fn constructor_popcnt_reg<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> Reg {
    let v3 = constructor_unary_rr(ctx, I64, &UnaryOp::PopcntReg, arg0);
    // Rule at src\isa\s390x\inst.isle line 4420.
    return v3;
}

// Generated as internal constructor for term vecop_popcnt.
pub fn constructor_vecop_popcnt<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecUnaryOp {
    match arg0 {
        I8X16 => {
            // Rule at src\isa\s390x\inst.isle line 4423.
            return VecUnaryOp::Popcnt8x16;
        }
        I16X8 => {
            // Rule at src\isa\s390x\inst.isle line 4424.
            return VecUnaryOp::Popcnt16x8;
        }
        I32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4425.
            return VecUnaryOp::Popcnt32x4;
        }
        I64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4426.
            return VecUnaryOp::Popcnt64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_popcnt", "src\\isa\\s390x\\inst.isle line 4422")
}

// Generated as internal constructor for term vec_popcnt.
pub fn constructor_vec_popcnt<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_vecop_popcnt(ctx, arg0);
    let v3 = constructor_vec_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4429.
    return v3;
}

// Generated as internal constructor for term atomic_rmw_and.
pub fn constructor_atomic_rmw_and<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    match arg0 {
        I32 => {
            let v5 = constructor_atomic_rmw_impl(ctx, I32, &ALUOp::And32, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4435.
            return v5;
        }
        I64 => {
            let v8 = constructor_atomic_rmw_impl(ctx, I64, &ALUOp::And64, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4436.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_and", "src\\isa\\s390x\\inst.isle line 4434")
}

// Generated as internal constructor for term atomic_rmw_or.
pub fn constructor_atomic_rmw_or<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    match arg0 {
        I32 => {
            let v5 = constructor_atomic_rmw_impl(ctx, I32, &ALUOp::Orr32, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4439.
            return v5;
        }
        I64 => {
            let v8 = constructor_atomic_rmw_impl(ctx, I64, &ALUOp::Orr64, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4440.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_or", "src\\isa\\s390x\\inst.isle line 4438")
}

// Generated as internal constructor for term atomic_rmw_xor.
pub fn constructor_atomic_rmw_xor<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    match arg0 {
        I32 => {
            let v5 = constructor_atomic_rmw_impl(ctx, I32, &ALUOp::Xor32, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4443.
            return v5;
        }
        I64 => {
            let v8 = constructor_atomic_rmw_impl(ctx, I64, &ALUOp::Xor64, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4444.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_xor", "src\\isa\\s390x\\inst.isle line 4442")
}

// Generated as internal constructor for term atomic_rmw_add.
pub fn constructor_atomic_rmw_add<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> Reg {
    match arg0 {
        I32 => {
            let v5 = constructor_atomic_rmw_impl(ctx, I32, &ALUOp::Add32, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4447.
            return v5;
        }
        I64 => {
            let v8 = constructor_atomic_rmw_impl(ctx, I64, &ALUOp::Add64, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4448.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_add", "src\\isa\\s390x\\inst.isle line 4446")
}

// Generated as internal constructor for term atomic_cas_impl.
pub fn constructor_atomic_cas_impl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: &MemArg,
) -> Reg {
    match arg0 {
        I32 => {
            let v4 = constructor_atomic_cas32(ctx, arg1, arg2, arg3);
            // Rule at src\isa\s390x\inst.isle line 4454.
            return v4;
        }
        I64 => {
            let v5 = constructor_atomic_cas64(ctx, arg1, arg2, arg3);
            // Rule at src\isa\s390x\inst.isle line 4455.
            return v5;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_cas_impl", "src\\isa\\s390x\\inst.isle line 4453")
}

// Generated as internal constructor for term push_atomic_cas.
pub fn constructor_push_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: WritableReg,
    arg3: Reg,
    arg4: &MemArg,
) -> Reg {
    match arg1 {
        I32 => {
            let v5 = constructor_push_atomic_cas32(ctx, arg0, arg2, arg3, arg4);
            // Rule at src\isa\s390x\inst.isle line 4458.
            return v5;
        }
        I64 => {
            let v6 = constructor_push_atomic_cas64(ctx, arg0, arg2, arg3, arg4);
            // Rule at src\isa\s390x\inst.isle line 4459.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "push_atomic_cas", "src\\isa\\s390x\\inst.isle line 4457")
}

// Generated as internal constructor for term fpuop2_add.
pub fn constructor_fpuop2_add<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4465.
            return FPUOp2::Add32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4466.
            return FPUOp2::Add64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4467.
            return FPUOp2::Add128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4468.
            return FPUOp2::Add32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4469.
            return FPUOp2::Add64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_add", "src\\isa\\s390x\\inst.isle line 4464")
}

// Generated as internal constructor for term fadd_reg.
pub fn constructor_fadd_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_add(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4472.
    return v4;
}

// Generated as internal constructor for term fpuop2_sub.
pub fn constructor_fpuop2_sub<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4478.
            return FPUOp2::Sub32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4479.
            return FPUOp2::Sub64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4480.
            return FPUOp2::Sub128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4481.
            return FPUOp2::Sub32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4482.
            return FPUOp2::Sub64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_sub", "src\\isa\\s390x\\inst.isle line 4477")
}

// Generated as internal constructor for term fsub_reg.
pub fn constructor_fsub_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_sub(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4485.
    return v4;
}

// Generated as internal constructor for term fpuop2_mul.
pub fn constructor_fpuop2_mul<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4491.
            return FPUOp2::Mul32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4492.
            return FPUOp2::Mul64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4493.
            return FPUOp2::Mul128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4494.
            return FPUOp2::Mul32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4495.
            return FPUOp2::Mul64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_mul", "src\\isa\\s390x\\inst.isle line 4490")
}

// Generated as internal constructor for term fmul_reg.
pub fn constructor_fmul_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_mul(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4498.
    return v4;
}

// Generated as internal constructor for term fpuop2_div.
pub fn constructor_fpuop2_div<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4504.
            return FPUOp2::Div32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4505.
            return FPUOp2::Div64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4506.
            return FPUOp2::Div128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4507.
            return FPUOp2::Div32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4508.
            return FPUOp2::Div64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_div", "src\\isa\\s390x\\inst.isle line 4503")
}

// Generated as internal constructor for term fdiv_reg.
pub fn constructor_fdiv_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_div(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4511.
    return v4;
}

// Generated as internal constructor for term fpuop2_min.
pub fn constructor_fpuop2_min<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4517.
            return FPUOp2::Min32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4518.
            return FPUOp2::Min64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4519.
            return FPUOp2::Min128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4520.
            return FPUOp2::Min32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4521.
            return FPUOp2::Min64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_min", "src\\isa\\s390x\\inst.isle line 4516")
}

// Generated as internal constructor for term fmin_reg.
pub fn constructor_fmin_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_min(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4524.
    return v4;
}

// Generated as internal constructor for term fpuop2_max.
pub fn constructor_fpuop2_max<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4530.
            return FPUOp2::Max32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4531.
            return FPUOp2::Max64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4532.
            return FPUOp2::Max128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4533.
            return FPUOp2::Max32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4534.
            return FPUOp2::Max64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_max", "src\\isa\\s390x\\inst.isle line 4529")
}

// Generated as internal constructor for term fmax_reg.
pub fn constructor_fmax_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_max(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4537.
    return v4;
}

// Generated as internal constructor for term fpuop2_min_pseudo.
pub fn constructor_fpuop2_min_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4543.
            return FPUOp2::MinPseudo32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4544.
            return FPUOp2::MinPseudo64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4545.
            return FPUOp2::MinPseudo128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4546.
            return FPUOp2::MinPseudo32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4547.
            return FPUOp2::MinPseudo64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_min_pseudo", "src\\isa\\s390x\\inst.isle line 4542")
}

// Generated as internal constructor for term fmin_pseudo_reg.
pub fn constructor_fmin_pseudo_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_min_pseudo(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4550.
    return v4;
}

// Generated as internal constructor for term fpuop2_max_pseudo.
pub fn constructor_fpuop2_max_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp2 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4556.
            return FPUOp2::MaxPseudo32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4557.
            return FPUOp2::MaxPseudo64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4558.
            return FPUOp2::MaxPseudo128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4559.
            return FPUOp2::MaxPseudo32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4560.
            return FPUOp2::MaxPseudo64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop2_max_pseudo", "src\\isa\\s390x\\inst.isle line 4555")
}

// Generated as internal constructor for term fmax_pseudo_reg.
pub fn constructor_fmax_pseudo_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v3 = &constructor_fpuop2_max_pseudo(ctx, arg0);
    let v4 = constructor_fpu_rrr(ctx, arg0, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4563.
    return v4;
}

// Generated as internal constructor for term fpuop3_fma.
pub fn constructor_fpuop3_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp3 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4569.
            return FPUOp3::MAdd32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4570.
            return FPUOp3::MAdd64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4571.
            return FPUOp3::MAdd128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4572.
            return FPUOp3::MAdd32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4573.
            return FPUOp3::MAdd64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop3_fma", "src\\isa\\s390x\\inst.isle line 4568")
}

// Generated as internal constructor for term fma_reg.
pub fn constructor_fma_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let v4 = &constructor_fpuop3_fma(ctx, arg0);
    let v5 = constructor_fpu_rrrr(ctx, arg0, v4, arg1, arg2, arg3);
    // Rule at src\isa\s390x\inst.isle line 4576.
    return v5;
}

// Generated as internal constructor for term fpuop1_sqrt.
pub fn constructor_fpuop1_sqrt<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp1 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4582.
            return FPUOp1::Sqrt32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4583.
            return FPUOp1::Sqrt64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4584.
            return FPUOp1::Sqrt128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4585.
            return FPUOp1::Sqrt32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4586.
            return FPUOp1::Sqrt64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop1_sqrt", "src\\isa\\s390x\\inst.isle line 4581")
}

// Generated as internal constructor for term sqrt_reg.
pub fn constructor_sqrt_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_fpuop1_sqrt(ctx, arg0);
    let v3 = constructor_fpu_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4589.
    return v3;
}

// Generated as internal constructor for term fpuop1_neg.
pub fn constructor_fpuop1_neg<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp1 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4595.
            return FPUOp1::Neg32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4596.
            return FPUOp1::Neg64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4597.
            return FPUOp1::Neg128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4598.
            return FPUOp1::Neg32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4599.
            return FPUOp1::Neg64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop1_neg", "src\\isa\\s390x\\inst.isle line 4594")
}

// Generated as internal constructor for term fneg_reg.
pub fn constructor_fneg_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_fpuop1_neg(ctx, arg0);
    let v3 = constructor_fpu_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4602.
    return v3;
}

// Generated as internal constructor for term fpuop1_abs.
pub fn constructor_fpuop1_abs<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FPUOp1 {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4608.
            return FPUOp1::Abs32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4609.
            return FPUOp1::Abs64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4610.
            return FPUOp1::Abs128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4611.
            return FPUOp1::Abs32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4612.
            return FPUOp1::Abs64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuop1_abs", "src\\isa\\s390x\\inst.isle line 4607")
}

// Generated as internal constructor for term fabs_reg.
pub fn constructor_fabs_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_fpuop1_abs(ctx, arg0);
    let v3 = constructor_fpu_rr(ctx, arg0, v2, arg1);
    // Rule at src\isa\s390x\inst.isle line 4615.
    return v3;
}

// Generated as internal constructor for term fpuroundop_round.
pub fn constructor_fpuroundop_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> FpuRoundOp {
    match arg0 {
        F32 => {
            // Rule at src\isa\s390x\inst.isle line 4621.
            return FpuRoundOp::Round32;
        }
        F64 => {
            // Rule at src\isa\s390x\inst.isle line 4622.
            return FpuRoundOp::Round64;
        }
        F128 => {
            // Rule at src\isa\s390x\inst.isle line 4623.
            return FpuRoundOp::Round128;
        }
        F32X4 => {
            // Rule at src\isa\s390x\inst.isle line 4624.
            return FpuRoundOp::Round32x4;
        }
        F64X2 => {
            // Rule at src\isa\s390x\inst.isle line 4625.
            return FpuRoundOp::Round64x2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpuroundop_round", "src\\isa\\s390x\\inst.isle line 4620")
}

// Generated as internal constructor for term ceil_reg.
pub fn constructor_ceil_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_fpuroundop_round(ctx, arg0);
    let v4 = constructor_fpu_round(ctx, arg0, v2, &FpuRoundMode::ToPosInfinity, arg1);
    // Rule at src\isa\s390x\inst.isle line 4628.
    return v4;
}

// Generated as internal constructor for term floor_reg.
pub fn constructor_floor_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_fpuroundop_round(ctx, arg0);
    let v4 = constructor_fpu_round(ctx, arg0, v2, &FpuRoundMode::ToNegInfinity, arg1);
    // Rule at src\isa\s390x\inst.isle line 4632.
    return v4;
}

// Generated as internal constructor for term trunc_reg.
pub fn constructor_trunc_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_fpuroundop_round(ctx, arg0);
    let v4 = constructor_fpu_round(ctx, arg0, v2, &FpuRoundMode::ToZero, arg1);
    // Rule at src\isa\s390x\inst.isle line 4636.
    return v4;
}

// Generated as internal constructor for term nearest_reg.
pub fn constructor_nearest_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    let v2 = &constructor_fpuroundop_round(ctx, arg0);
    let v4 = constructor_fpu_round(ctx, arg0, v2, &FpuRoundMode::ToNearestTiesToEven, arg1);
    // Rule at src\isa\s390x\inst.isle line 4640.
    return v4;
}

// Generated as internal constructor for term fpromote_reg.
pub fn constructor_fpromote_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: Reg,
) -> Reg {
    if arg0 == arg1 {
        // Rule at src\isa\s390x\inst.isle line 4647.
        return arg2;
    }
    match arg0 {
        F64 => {
            if arg1 == F32 {
                let v5 = constructor_fpu_rr(ctx, F64, &FPUOp1::Cvt32To64, arg2);
                // Rule at src\isa\s390x\inst.isle line 4648.
                return v5;
            }
        }
        F128 => {
            if arg1 == F64 {
                let v10 = constructor_fpu_rr(ctx, F128, &FPUOp1::Cvt64To128, arg2);
                // Rule at src\isa\s390x\inst.isle line 4652.
                return v10;
            }
        }
        F64X2 => {
            if arg1 == F32X4 {
                let v7 = constructor_fpu_rr(ctx, F64, &FPUOp1::Cvt32x4To64x2, arg2);
                // Rule at src\isa\s390x\inst.isle line 4650.
                return v7;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fpromote_reg", "src\\isa\\s390x\\inst.isle line 4646")
}

// Generated as internal constructor for term fdemote_reg.
pub fn constructor_fdemote_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: &FpuRoundMode,
    arg3: Reg,
) -> Reg {
    if arg0 == arg1 {
        // Rule at src\isa\s390x\inst.isle line 4659.
        return arg3;
    }
    match arg0 {
        F32 => {
            if arg1 == F64 {
                let v6 = constructor_fpu_round(ctx, F32, &FpuRoundOp::Cvt64To32, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4660.
                return v6;
            }
        }
        F64 => {
            if arg1 == F128 {
                let v12 = constructor_fpu_round(ctx, F64, &FpuRoundOp::Cvt128To64, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4664.
                return v12;
            }
        }
        F32X4 => {
            if arg1 == F64X2 {
                let v9 = constructor_fpu_round(ctx, F32X4, &FpuRoundOp::Cvt64x2To32x4, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4662.
                return v9;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fdemote_reg", "src\\isa\\s390x\\inst.isle line 4658")
}

// Generated as internal constructor for term fcvt_from_uint_reg.
pub fn constructor_fcvt_from_uint_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: &FpuRoundMode,
    arg3: Reg,
) -> Reg {
    match arg0 {
        F32 => {
            if arg1 == I32 {
                let v8 = C::zero_reg(ctx);
                let v9 = constructor_vec_insert_lane_undef(ctx, I32X4, arg3, 0x0_u8, v8);
                let v10 = constructor_fpu_round(ctx, F32, &FpuRoundOp::FromUInt32, arg2, v9);
                // Rule at src\isa\s390x\inst.isle line 4671.
                return v10;
            }
        }
        F64 => {
            if arg1 == I64 {
                let v8 = C::zero_reg(ctx);
                let v14 = constructor_vec_insert_lane_undef(ctx, I64X2, arg3, 0x0_u8, v8);
                let v15 = constructor_fpu_round(ctx, F64, &FpuRoundOp::FromUInt64, arg2, v14);
                // Rule at src\isa\s390x\inst.isle line 4673.
                return v15;
            }
        }
        F128 => {
            match arg1 {
                I32 => {
                    let v23 = constructor_fpu_conv128_from_int(ctx, &FpuConv128Op::UInt32, arg2, arg3);
                    let v24 = constructor_fp_regpair_to_reg(ctx, v23);
                    // Rule at src\isa\s390x\inst.isle line 4679.
                    return v24;
                }
                I64 => {
                    let v26 = constructor_fpu_conv128_from_int(ctx, &FpuConv128Op::UInt64, arg2, arg3);
                    let v27 = constructor_fp_regpair_to_reg(ctx, v26);
                    // Rule at src\isa\s390x\inst.isle line 4681.
                    return v27;
                }
                _ => {}
            }
        }
        F32X4 => {
            if arg1 == I32X4 {
                let v18 = constructor_fpu_round(ctx, F32X4, &FpuRoundOp::FromUInt32x4, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4675.
                return v18;
            }
        }
        F64X2 => {
            if arg1 == I64X2 {
                let v21 = constructor_fpu_round(ctx, F64X2, &FpuRoundOp::FromUInt64x2, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4677.
                return v21;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_from_uint_reg", "src\\isa\\s390x\\inst.isle line 4670")
}

// Generated as internal constructor for term fcvt_from_sint_reg.
pub fn constructor_fcvt_from_sint_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: &FpuRoundMode,
    arg3: Reg,
) -> Reg {
    match arg0 {
        F32 => {
            if arg1 == I32 {
                let v8 = C::zero_reg(ctx);
                let v9 = constructor_vec_insert_lane_undef(ctx, I32X4, arg3, 0x0_u8, v8);
                let v10 = constructor_fpu_round(ctx, F32, &FpuRoundOp::FromSInt32, arg2, v9);
                // Rule at src\isa\s390x\inst.isle line 4688.
                return v10;
            }
        }
        F64 => {
            if arg1 == I64 {
                let v8 = C::zero_reg(ctx);
                let v14 = constructor_vec_insert_lane_undef(ctx, I64X2, arg3, 0x0_u8, v8);
                let v15 = constructor_fpu_round(ctx, F64, &FpuRoundOp::FromSInt64, arg2, v14);
                // Rule at src\isa\s390x\inst.isle line 4690.
                return v15;
            }
        }
        F128 => {
            match arg1 {
                I32 => {
                    let v23 = constructor_fpu_conv128_from_int(ctx, &FpuConv128Op::SInt32, arg2, arg3);
                    let v24 = constructor_fp_regpair_to_reg(ctx, v23);
                    // Rule at src\isa\s390x\inst.isle line 4696.
                    return v24;
                }
                I64 => {
                    let v26 = constructor_fpu_conv128_from_int(ctx, &FpuConv128Op::SInt64, arg2, arg3);
                    let v27 = constructor_fp_regpair_to_reg(ctx, v26);
                    // Rule at src\isa\s390x\inst.isle line 4698.
                    return v27;
                }
                _ => {}
            }
        }
        F32X4 => {
            if arg1 == I32X4 {
                let v18 = constructor_fpu_round(ctx, F32X4, &FpuRoundOp::FromSInt32x4, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4692.
                return v18;
            }
        }
        F64X2 => {
            if arg1 == I64X2 {
                let v21 = constructor_fpu_round(ctx, F64X2, &FpuRoundOp::FromSInt64x2, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4694.
                return v21;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_from_sint_reg", "src\\isa\\s390x\\inst.isle line 4687")
}

// Generated as internal constructor for term fcvt_flt_ty.
pub fn constructor_fcvt_flt_ty<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
) -> Type {
    match arg1 {
        F32 => {
            let v1 = C::fits_in_32(ctx, arg0);
            if let Some(v2) = v1 {
                let v4 = C::vxrs_ext2_enabled(ctx, arg1);
                if let Some(v5) = v4 {
                    // Rule at src\isa\s390x\inst.isle line 4705.
                    return F32;
                }
            }
            let v7 = C::fits_in_64(ctx, arg0);
            if let Some(v8) = v7 {
                // Rule at src\isa\s390x\inst.isle line 4706.
                return F64;
            }
        }
        F64 => {
            let v7 = C::fits_in_64(ctx, arg0);
            if let Some(v8) = v7 {
                // Rule at src\isa\s390x\inst.isle line 4707.
                return F64;
            }
        }
        F128 => {
            let v7 = C::fits_in_64(ctx, arg0);
            if let Some(v8) = v7 {
                // Rule at src\isa\s390x\inst.isle line 4708.
                return F128;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_flt_ty", "src\\isa\\s390x\\inst.isle line 4704")
}

// Generated as internal constructor for term fcvt_int_ty.
pub fn constructor_fcvt_int_ty<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
) -> Type {
    match arg1 {
        F32 => {
            let v1 = C::fits_in_32(ctx, arg0);
            if let Some(v2) = v1 {
                let v4 = C::vxrs_ext2_enabled(ctx, arg1);
                if let Some(v5) = v4 {
                    // Rule at src\isa\s390x\inst.isle line 4711.
                    return I32;
                }
            }
            let v7 = C::fits_in_64(ctx, arg0);
            if let Some(v8) = v7 {
                // Rule at src\isa\s390x\inst.isle line 4712.
                return I64;
            }
        }
        F64 => {
            let v7 = C::fits_in_64(ctx, arg0);
            if let Some(v8) = v7 {
                // Rule at src\isa\s390x\inst.isle line 4713.
                return I64;
            }
        }
        F128 => {
            let v1 = C::fits_in_32(ctx, arg0);
            if let Some(v2) = v1 {
                // Rule at src\isa\s390x\inst.isle line 4714.
                return I32;
            }
            let v7 = C::fits_in_64(ctx, arg0);
            if let Some(v8) = v7 {
                // Rule at src\isa\s390x\inst.isle line 4715.
                return I64;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_int_ty", "src\\isa\\s390x\\inst.isle line 4710")
}

// Generated as internal constructor for term fcvt_to_uint_reg.
pub fn constructor_fcvt_to_uint_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: &FpuRoundMode,
    arg3: Reg,
) -> Reg {
    match arg0 {
        I32 => {
            match arg1 {
                F32 => {
                    let v7 = constructor_fpu_round(ctx, F32, &FpuRoundOp::ToUInt32, arg2, arg3);
                    let v9 = C::zero_reg(ctx);
                    let v10 = constructor_vec_extract_lane(ctx, I32X4, v7, 0x0_u8, v9);
                    // Rule at src\isa\s390x\inst.isle line 4721.
                    return v10;
                }
                F128 => {
                    let v24 = constructor_fp_reg_to_regpair(ctx, arg3);
                    let v25 = constructor_fpu_conv128_to_int(ctx, I32, &FpuConv128Op::UInt32, arg2, v24);
                    // Rule at src\isa\s390x\inst.isle line 4729.
                    return v25;
                }
                _ => {}
            }
        }
        I64 => {
            match arg1 {
                F64 => {
                    let v14 = constructor_fpu_round(ctx, F64, &FpuRoundOp::ToUInt64, arg2, arg3);
                    let v9 = C::zero_reg(ctx);
                    let v15 = constructor_vec_extract_lane(ctx, I64X2, v14, 0x0_u8, v9);
                    // Rule at src\isa\s390x\inst.isle line 4723.
                    return v15;
                }
                F128 => {
                    let v24 = constructor_fp_reg_to_regpair(ctx, arg3);
                    let v28 = constructor_fpu_conv128_to_int(ctx, I64, &FpuConv128Op::UInt64, arg2, v24);
                    // Rule at src\isa\s390x\inst.isle line 4731.
                    return v28;
                }
                _ => {}
            }
        }
        I32X4 => {
            if arg1 == F32X4 {
                let v18 = constructor_fpu_round(ctx, F32X4, &FpuRoundOp::ToUInt32x4, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4725.
                return v18;
            }
        }
        I64X2 => {
            if arg1 == F64X2 {
                let v21 = constructor_fpu_round(ctx, F64X2, &FpuRoundOp::ToUInt64x2, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4727.
                return v21;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_to_uint_reg", "src\\isa\\s390x\\inst.isle line 4720")
}

// Generated as internal constructor for term fcvt_to_uint_ub.
pub fn constructor_fcvt_to_uint_ub<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
) -> Reg {
    match arg0 {
        F32 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v4 = C::fcvt_to_uint_ub32(ctx, v3);
            let v5 = constructor_imm(ctx, F32, v4);
            // Rule at src\isa\s390x\inst.isle line 4735.
            return v5;
        }
        F64 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v7 = C::fcvt_to_uint_ub64(ctx, v3);
            let v8 = constructor_imm(ctx, F64, v7);
            // Rule at src\isa\s390x\inst.isle line 4737.
            return v8;
        }
        F128 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v10 = C::fcvt_to_uint_ub128(ctx, v3);
            let v11 = constructor_vec_imm(ctx, F128, v10);
            // Rule at src\isa\s390x\inst.isle line 4739.
            return v11;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_to_uint_ub", "src\\isa\\s390x\\inst.isle line 4734")
}

// Generated as internal constructor for term fcvt_to_uint_lb.
pub fn constructor_fcvt_to_uint_lb<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Reg {
    match arg0 {
        F32 => {
            let v2 = C::fcvt_to_uint_lb32(ctx);
            let v3 = constructor_imm(ctx, F32, v2);
            // Rule at src\isa\s390x\inst.isle line 4743.
            return v3;
        }
        F64 => {
            let v5 = C::fcvt_to_uint_lb64(ctx);
            let v6 = constructor_imm(ctx, F64, v5);
            // Rule at src\isa\s390x\inst.isle line 4744.
            return v6;
        }
        F128 => {
            let v8 = C::fcvt_to_uint_lb128(ctx);
            let v9 = constructor_vec_imm(ctx, F128, v8);
            // Rule at src\isa\s390x\inst.isle line 4745.
            return v9;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_to_uint_lb", "src\\isa\\s390x\\inst.isle line 4742")
}

// Generated as internal constructor for term fcvt_to_sint_reg.
pub fn constructor_fcvt_to_sint_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: &FpuRoundMode,
    arg3: Reg,
) -> Reg {
    match arg0 {
        I32 => {
            match arg1 {
                F32 => {
                    let v7 = constructor_fpu_round(ctx, F32, &FpuRoundOp::ToSInt32, arg2, arg3);
                    let v9 = C::zero_reg(ctx);
                    let v10 = constructor_vec_extract_lane(ctx, F32X4, v7, 0x0_u8, v9);
                    // Rule at src\isa\s390x\inst.isle line 4764.
                    return v10;
                }
                F128 => {
                    let v22 = constructor_fp_reg_to_regpair(ctx, arg3);
                    let v23 = constructor_fpu_conv128_to_int(ctx, I32, &FpuConv128Op::SInt32, arg2, v22);
                    // Rule at src\isa\s390x\inst.isle line 4772.
                    return v23;
                }
                _ => {}
            }
        }
        I64 => {
            match arg1 {
                F64 => {
                    let v14 = constructor_fpu_round(ctx, F64, &FpuRoundOp::ToSInt64, arg2, arg3);
                    let v9 = C::zero_reg(ctx);
                    let v15 = constructor_vec_extract_lane(ctx, F64X2, v14, 0x0_u8, v9);
                    // Rule at src\isa\s390x\inst.isle line 4766.
                    return v15;
                }
                F128 => {
                    let v22 = constructor_fp_reg_to_regpair(ctx, arg3);
                    let v26 = constructor_fpu_conv128_to_int(ctx, I64, &FpuConv128Op::SInt64, arg2, v22);
                    // Rule at src\isa\s390x\inst.isle line 4774.
                    return v26;
                }
                _ => {}
            }
        }
        I32X4 => {
            if arg1 == F32X4 {
                let v17 = constructor_fpu_round(ctx, F32X4, &FpuRoundOp::ToSInt32x4, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4768.
                return v17;
            }
        }
        I64X2 => {
            if arg1 == F64X2 {
                let v19 = constructor_fpu_round(ctx, F64X2, &FpuRoundOp::ToSInt64x2, arg2, arg3);
                // Rule at src\isa\s390x\inst.isle line 4770.
                return v19;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_to_sint_reg", "src\\isa\\s390x\\inst.isle line 4763")
}

// Generated as internal constructor for term fcvt_to_sint_ub.
pub fn constructor_fcvt_to_sint_ub<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
) -> Reg {
    match arg0 {
        F32 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v4 = C::fcvt_to_sint_ub32(ctx, v3);
            let v5 = constructor_imm(ctx, F32, v4);
            // Rule at src\isa\s390x\inst.isle line 4778.
            return v5;
        }
        F64 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v7 = C::fcvt_to_sint_ub64(ctx, v3);
            let v8 = constructor_imm(ctx, F64, v7);
            // Rule at src\isa\s390x\inst.isle line 4780.
            return v8;
        }
        F128 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v10 = C::fcvt_to_sint_ub128(ctx, v3);
            let v11 = constructor_vec_imm(ctx, F128, v10);
            // Rule at src\isa\s390x\inst.isle line 4782.
            return v11;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_to_sint_ub", "src\\isa\\s390x\\inst.isle line 4777")
}

// Generated as internal constructor for term fcvt_to_sint_lb.
pub fn constructor_fcvt_to_sint_lb<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
) -> Reg {
    match arg0 {
        F32 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v4 = C::fcvt_to_sint_lb32(ctx, v3);
            let v5 = constructor_imm(ctx, F32, v4);
            // Rule at src\isa\s390x\inst.isle line 4786.
            return v5;
        }
        F64 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v7 = C::fcvt_to_sint_lb64(ctx, v3);
            let v8 = constructor_imm(ctx, F64, v7);
            // Rule at src\isa\s390x\inst.isle line 4788.
            return v8;
        }
        F128 => {
            let v3 = C::ty_bits(ctx, arg1);
            let v10 = C::fcvt_to_sint_lb128(ctx, v3);
            let v11 = constructor_vec_imm(ctx, F128, v10);
            // Rule at src\isa\s390x\inst.isle line 4790.
            return v11;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcvt_to_sint_lb", "src\\isa\\s390x\\inst.isle line 4785")
}

// Generated as internal constructor for term cmpop_cmps.
pub fn constructor_cmpop_cmps<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> CmpOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4810.
            return CmpOp::CmpS32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4811.
            return CmpOp::CmpS64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmpop_cmps", "src\\isa\\s390x\\inst.isle line 4809")
}

// Generated as internal constructor for term cmpop_cmps_sext16.
pub fn constructor_cmpop_cmps_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> CmpOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4814.
            return CmpOp::CmpS32Ext16;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4815.
            return CmpOp::CmpS64Ext16;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmpop_cmps_sext16", "src\\isa\\s390x\\inst.isle line 4813")
}

// Generated as internal constructor for term cmpop_cmps_sext32.
pub fn constructor_cmpop_cmps_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> CmpOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 4818.
        return CmpOp::CmpS64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmpop_cmps_sext32", "src\\isa\\s390x\\inst.isle line 4817")
}

// Generated as internal constructor for term icmps_reg.
pub fn constructor_icmps_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmps(ctx, arg0);
    let v4 = &constructor_cmp_rr(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4821.
    return v4.clone();
}

// Generated as internal constructor for term icmps_reg_sext32.
pub fn constructor_icmps_reg_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmps_sext32(ctx, arg0);
    let v4 = &constructor_cmp_rr(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4824.
    return v4.clone();
}

// Generated as internal constructor for term icmps_simm16.
pub fn constructor_icmps_simm16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i16,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmps(ctx, arg0);
    let v4 = &constructor_cmp_rsimm16(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4827.
    return v4.clone();
}

// Generated as internal constructor for term icmps_simm32.
pub fn constructor_icmps_simm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: i32,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmps(ctx, arg0);
    let v4 = &constructor_cmp_rsimm32(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4830.
    return v4.clone();
}

// Generated as internal constructor for term icmps_mem.
pub fn constructor_icmps_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmps(ctx, arg0);
    let v4 = &constructor_cmp_rx(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4833.
    return v4.clone();
}

// Generated as internal constructor for term icmps_mem_sext16.
pub fn constructor_icmps_mem_sext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmps_sext16(ctx, arg0);
    let v4 = &constructor_cmp_rx(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4836.
    return v4.clone();
}

// Generated as internal constructor for term icmps_mem_sext32.
pub fn constructor_icmps_mem_sext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmps_sext32(ctx, arg0);
    let v4 = &constructor_cmp_rx(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4839.
    return v4.clone();
}

// Generated as internal constructor for term cmpop_cmpu.
pub fn constructor_cmpop_cmpu<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> CmpOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4845.
            return CmpOp::CmpL32;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4846.
            return CmpOp::CmpL64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmpop_cmpu", "src\\isa\\s390x\\inst.isle line 4844")
}

// Generated as internal constructor for term cmpop_cmpu_zext16.
pub fn constructor_cmpop_cmpu_zext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> CmpOp {
    match arg0 {
        I32 => {
            // Rule at src\isa\s390x\inst.isle line 4849.
            return CmpOp::CmpL32Ext16;
        }
        I64 => {
            // Rule at src\isa\s390x\inst.isle line 4850.
            return CmpOp::CmpL64Ext16;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmpop_cmpu_zext16", "src\\isa\\s390x\\inst.isle line 4848")
}

// Generated as internal constructor for term cmpop_cmpu_zext32.
pub fn constructor_cmpop_cmpu_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> CmpOp {
    if arg0 == I64 {
        // Rule at src\isa\s390x\inst.isle line 4853.
        return CmpOp::CmpL64Ext32;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cmpop_cmpu_zext32", "src\\isa\\s390x\\inst.isle line 4852")
}

// Generated as internal constructor for term icmpu_reg.
pub fn constructor_icmpu_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmpu(ctx, arg0);
    let v4 = &constructor_cmp_rr(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4856.
    return v4.clone();
}

// Generated as internal constructor for term icmpu_reg_zext32.
pub fn constructor_icmpu_reg_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmpu_zext32(ctx, arg0);
    let v4 = &constructor_cmp_rr(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4859.
    return v4.clone();
}

// Generated as internal constructor for term icmpu_uimm32.
pub fn constructor_icmpu_uimm32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u32,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmpu(ctx, arg0);
    let v4 = &constructor_cmp_ruimm32(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4862.
    return v4.clone();
}

// Generated as internal constructor for term icmpu_mem.
pub fn constructor_icmpu_mem<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmpu(ctx, arg0);
    let v4 = &constructor_cmp_rx(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4865.
    return v4.clone();
}

// Generated as internal constructor for term icmpu_mem_zext16.
pub fn constructor_icmpu_mem_zext16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmpu_zext16(ctx, arg0);
    let v4 = &constructor_cmp_rx(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4868.
    return v4.clone();
}

// Generated as internal constructor for term icmpu_mem_zext32.
pub fn constructor_icmpu_mem_zext32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
) -> ProducesFlags {
    let v3 = &constructor_cmpop_cmpu_zext32(ctx, arg0);
    let v4 = &constructor_cmp_rx(ctx, v3, arg1, arg2);
    // Rule at src\isa\s390x\inst.isle line 4871.
    return v4.clone();
}

// Generated as internal constructor for term vecop_int_cmpeq.
pub fn constructor_vecop_int_cmpeq<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecIntCmpOp {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x8_u32 => {
                if v2.1 == 0x10_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4877.
                    return VecIntCmpOp::CmpEq8x16;
                }
            }
            0x10_u32 => {
                if v2.1 == 0x8_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4878.
                    return VecIntCmpOp::CmpEq16x8;
                }
            }
            0x20_u32 => {
                if v2.1 == 0x4_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4879.
                    return VecIntCmpOp::CmpEq32x4;
                }
            }
            0x40_u32 => {
                if v2.1 == 0x2_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4880.
                    return VecIntCmpOp::CmpEq64x2;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_int_cmpeq", "src\\isa\\s390x\\inst.isle line 4876")
}

// Generated as internal constructor for term vec_cmpeq.
pub fn constructor_vec_cmpeq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_int_cmpeq(ctx, v2);
        let v6 = constructor_vec_int_cmp(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4883.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_cmpeq", "src\\isa\\s390x\\inst.isle line 4882")
}

// Generated as internal constructor for term vec_cmpeqs.
pub fn constructor_vec_cmpeqs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_int_cmpeq(ctx, v2);
        let v6 = &constructor_vec_int_cmps(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4885.
        return v6.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_cmpeqs", "src\\isa\\s390x\\inst.isle line 4884")
}

// Generated as internal constructor for term vecop_int_cmph.
pub fn constructor_vecop_int_cmph<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecIntCmpOp {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x8_u32 => {
                if v2.1 == 0x10_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4888.
                    return VecIntCmpOp::SCmpHi8x16;
                }
            }
            0x10_u32 => {
                if v2.1 == 0x8_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4889.
                    return VecIntCmpOp::SCmpHi16x8;
                }
            }
            0x20_u32 => {
                if v2.1 == 0x4_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4890.
                    return VecIntCmpOp::SCmpHi32x4;
                }
            }
            0x40_u32 => {
                if v2.1 == 0x2_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4891.
                    return VecIntCmpOp::SCmpHi64x2;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_int_cmph", "src\\isa\\s390x\\inst.isle line 4887")
}

// Generated as internal constructor for term vec_cmph.
pub fn constructor_vec_cmph<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_int_cmph(ctx, v2);
        let v6 = constructor_vec_int_cmp(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4894.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_cmph", "src\\isa\\s390x\\inst.isle line 4893")
}

// Generated as internal constructor for term vec_cmphs.
pub fn constructor_vec_cmphs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_int_cmph(ctx, v2);
        let v6 = &constructor_vec_int_cmps(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4896.
        return v6.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_cmphs", "src\\isa\\s390x\\inst.isle line 4895")
}

// Generated as internal constructor for term vecop_int_cmphl.
pub fn constructor_vecop_int_cmphl<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecIntCmpOp {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x8_u32 => {
                if v2.1 == 0x10_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4899.
                    return VecIntCmpOp::UCmpHi8x16;
                }
            }
            0x10_u32 => {
                if v2.1 == 0x8_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4900.
                    return VecIntCmpOp::UCmpHi16x8;
                }
            }
            0x20_u32 => {
                if v2.1 == 0x4_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4901.
                    return VecIntCmpOp::UCmpHi32x4;
                }
            }
            0x40_u32 => {
                if v2.1 == 0x2_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4902.
                    return VecIntCmpOp::UCmpHi64x2;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_int_cmphl", "src\\isa\\s390x\\inst.isle line 4898")
}

// Generated as internal constructor for term vec_cmphl.
pub fn constructor_vec_cmphl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_int_cmphl(ctx, v2);
        let v6 = constructor_vec_int_cmp(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4905.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_cmphl", "src\\isa\\s390x\\inst.isle line 4904")
}

// Generated as internal constructor for term vec_cmphls.
pub fn constructor_vec_cmphls<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_int_cmphl(ctx, v2);
        let v6 = &constructor_vec_int_cmps(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4907.
        return v6.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_cmphls", "src\\isa\\s390x\\inst.isle line 4906")
}

// Generated as internal constructor for term fcmp_reg.
pub fn constructor_fcmp_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    match arg0 {
        F32 => {
            let v3 = &constructor_fpu_cmp32(ctx, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4913.
            return v3.clone();
        }
        F64 => {
            let v4 = &constructor_fpu_cmp64(ctx, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4914.
            return v4.clone();
        }
        F128 => {
            let v5 = &constructor_fpu_cmp128(ctx, arg1, arg2);
            // Rule at src\isa\s390x\inst.isle line 4915.
            return v5.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "fcmp_reg", "src\\isa\\s390x\\inst.isle line 4912")
}

// Generated as internal constructor for term vecop_float_cmpeq.
pub fn constructor_vecop_float_cmpeq<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecFloatCmpOp {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x20_u32 => {
                if v2.1 == 0x4_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4921.
                    return VecFloatCmpOp::CmpEq32x4;
                }
            }
            0x40_u32 => {
                if v2.1 == 0x2_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4922.
                    return VecFloatCmpOp::CmpEq64x2;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_float_cmpeq", "src\\isa\\s390x\\inst.isle line 4920")
}

// Generated as internal constructor for term vec_fcmpeq.
pub fn constructor_vec_fcmpeq<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_float_cmpeq(ctx, v2);
        let v6 = constructor_vec_float_cmp(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4925.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_fcmpeq", "src\\isa\\s390x\\inst.isle line 4924")
}

// Generated as internal constructor for term vec_fcmpeqs.
pub fn constructor_vec_fcmpeqs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_float_cmpeq(ctx, v2);
        let v6 = &constructor_vec_float_cmps(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4927.
        return v6.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_fcmpeqs", "src\\isa\\s390x\\inst.isle line 4926")
}

// Generated as internal constructor for term vecop_float_cmph.
pub fn constructor_vecop_float_cmph<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecFloatCmpOp {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x20_u32 => {
                if v2.1 == 0x4_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4930.
                    return VecFloatCmpOp::CmpHi32x4;
                }
            }
            0x40_u32 => {
                if v2.1 == 0x2_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4931.
                    return VecFloatCmpOp::CmpHi64x2;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_float_cmph", "src\\isa\\s390x\\inst.isle line 4929")
}

// Generated as internal constructor for term vec_fcmph.
pub fn constructor_vec_fcmph<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_float_cmph(ctx, v2);
        let v6 = constructor_vec_float_cmp(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4934.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_fcmph", "src\\isa\\s390x\\inst.isle line 4933")
}

// Generated as internal constructor for term vec_fcmphs.
pub fn constructor_vec_fcmphs<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_float_cmph(ctx, v2);
        let v6 = &constructor_vec_float_cmps(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4936.
        return v6.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_fcmphs", "src\\isa\\s390x\\inst.isle line 4935")
}

// Generated as internal constructor for term vecop_float_cmphe.
pub fn constructor_vecop_float_cmphe<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> VecFloatCmpOp {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x20_u32 => {
                if v2.1 == 0x4_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4939.
                    return VecFloatCmpOp::CmpHiEq32x4;
                }
            }
            0x40_u32 => {
                if v2.1 == 0x2_u32 {
                    // Rule at src\isa\s390x\inst.isle line 4940.
                    return VecFloatCmpOp::CmpHiEq64x2;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vecop_float_cmphe", "src\\isa\\s390x\\inst.isle line 4938")
}

// Generated as internal constructor for term vec_fcmphe.
pub fn constructor_vec_fcmphe<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_float_cmphe(ctx, v2);
        let v6 = constructor_vec_float_cmp(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4943.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_fcmphe", "src\\isa\\s390x\\inst.isle line 4942")
}

// Generated as internal constructor for term vec_fcmphes.
pub fn constructor_vec_fcmphes<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> ProducesFlags {
    let v1 = C::ty_vec128(ctx, arg0);
    if let Some(v2) = v1 {
        let v5 = &constructor_vecop_float_cmphe(ctx, v2);
        let v6 = &constructor_vec_float_cmps(ctx, v2, v5, arg1, arg2);
        // Rule at src\isa\s390x\inst.isle line 4945.
        return v6.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_fcmphes", "src\\isa\\s390x\\inst.isle line 4944")
}

// Generated as internal constructor for term s390x_label_address.
pub fn constructor_s390x_label_address<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
) -> Reg {
    let v2 = C::temp_writable_reg(ctx, I64);
    let v3 = MInst::LabelAddress {
        dst: v2,
        label: arg0,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\s390x\inst.isle line 4951.
    return v5;
}

// Generated as internal constructor for term s390x_sequence_point.
pub fn constructor_s390x_sequence_point<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = SideEffectNoResult::Inst {
        inst: MInst::SequencePoint,
    };
    // Rule at src\isa\s390x\inst.isle line 4958.
    return v1;
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> Option<InstOutput> {
    let v4 = &C::inst_data_value(ctx, arg0);
    match v4 {
        &InstructionData::AtomicCas {
            opcode: ref v2158,
            args: ref v2159,
            flags: v2160,
        } => {
            if let &Opcode::AtomicCas = v2158 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    let v3 = C::value_type(ctx, v2);
                    let v643 = C::ty_32_or_64(ctx, v3);
                    if let Some(v644) = v643 {
                        let v2165 = C::bigendian(ctx, v2160);
                        if let Some(v2166) = v2165 {
                            let v2161 = C::unpack_value_array_3(ctx, v2159);
                            let v2167 = C::put_in_reg(ctx, v2161.1);
                            let v2168 = C::put_in_reg(ctx, v2161.2);
                            let v2110 = C::zero_offset(ctx);
                            let v2169 = &constructor_lower_address(ctx, v2160, v2161.0, v2110);
                            let v2170 = constructor_atomic_cas_impl(ctx, v644, v2167, v2168, v2169);
                            let v2171 = constructor_output_reg(ctx, v2170);
                            let v2172 = Some(v2171);
                            // Rule at src\isa\s390x\lower.isle line 3216.
                            return v2172;
                        }
                        let v2173 = C::littleendian(ctx, v2160);
                        if let Some(v2174) = v2173 {
                            let v2161 = C::unpack_value_array_3(ctx, v2159);
                            let v2167 = C::put_in_reg(ctx, v2161.1);
                            let v2175 = constructor_bswap_reg(ctx, v644, v2167);
                            let v2176 = C::put_in_reg(ctx, v2161.2);
                            let v2177 = constructor_bswap_reg(ctx, v644, v2176);
                            let v2178 = C::zero_offset(ctx);
                            let v2179 = &constructor_lower_address(ctx, v2160, v2161.0, v2178);
                            let v2180 = constructor_atomic_cas_impl(ctx, v644, v2175, v2177, v2179);
                            let v2181 = constructor_bswap_reg(ctx, v644, v2180);
                            let v2182 = constructor_output_reg(ctx, v2181);
                            let v2183 = Some(v2182);
                            // Rule at src\isa\s390x\lower.isle line 3223.
                            return v2183;
                        }
                    }
                    let v469 = C::ty_8_or_16(ctx, v3);
                    if let Some(v470) = v469 {
                        let v2161 = C::unpack_value_array_3(ctx, v2159);
                        let v2167 = C::put_in_reg(ctx, v2161.1);
                        let v2168 = C::put_in_reg(ctx, v2161.2);
                        let v2184 = C::put_in_reg(ctx, v2161.0);
                        let v2185 = constructor_casloop_bitshift(ctx, v2184);
                        let v2186 = constructor_casloop_aligned_addr(ctx, v2184);
                        let v2187 = &C::inst_builder_new(ctx);
                        let v2188 = constructor_casloop_val_reg(ctx);
                        let v2189 = C::writable_reg_to_reg(ctx, v2188);
                        let v2190 = constructor_casloop_rotate_in(ctx, v2187, v470, v2160, v2185, v2189);
                        let v2191 = constructor_casloop_tmp_reg(ctx);
                        let v2192 = constructor_atomic_cas_body(ctx, v2187, v470, v2160, v2191, v2190, v2167, v2168);
                        let v2193 = constructor_casloop_rotate_out(ctx, v2187, v470, v2160, v2185, v2192);
                        let v2194 = constructor_casloop_subword(ctx, v2187, v470, v2160, v2186, v2185, v2193);
                        let v2195 = constructor_output_reg(ctx, v2194);
                        let v2196 = Some(v2195);
                        // Rule at src\isa\s390x\lower.isle line 3230.
                        return v2196;
                    }
                }
            }
        }
        &InstructionData::AtomicRmw {
            opcode: ref v2092,
            args: ref v2093,
            flags: v2094,
            op: ref v2095,
        } => {
            if let &Opcode::AtomicRmw = v2092 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    let v3 = C::value_type(ctx, v2);
                    let v643 = C::ty_32_or_64(ctx, v3);
                    if let Some(v644) = v643 {
                        match v2095 {
                            &AtomicRmwOp::Add => {
                                let v2099 = C::bigendian(ctx, v2094);
                                if let Some(v2100) = v2099 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2102 = C::zero_offset(ctx);
                                    let v2103 = &constructor_lower_address(ctx, v2094, v2096.0, v2102);
                                    let v2130 = constructor_atomic_rmw_add(ctx, v644, v2101, v2103);
                                    let v2131 = constructor_output_reg(ctx, v2130);
                                    let v2132 = Some(v2131);
                                    // Rule at src\isa\s390x\lower.isle line 2996.
                                    return v2132;
                                }
                            }
                            &AtomicRmwOp::And => {
                                let v2099 = C::bigendian(ctx, v2094);
                                if let Some(v2100) = v2099 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2102 = C::zero_offset(ctx);
                                    let v2103 = &constructor_lower_address(ctx, v2094, v2096.0, v2102);
                                    let v2104 = constructor_atomic_rmw_and(ctx, v644, v2101, v2103);
                                    let v2105 = constructor_output_reg(ctx, v2104);
                                    let v2106 = Some(v2105);
                                    // Rule at src\isa\s390x\lower.isle line 2960.
                                    return v2106;
                                }
                                let v2107 = C::littleendian(ctx, v2094);
                                if let Some(v2108) = v2107 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2109 = constructor_bswap_reg(ctx, v644, v2101);
                                    let v2110 = C::zero_offset(ctx);
                                    let v2111 = &constructor_lower_address(ctx, v2094, v2096.0, v2110);
                                    let v2112 = constructor_atomic_rmw_and(ctx, v644, v2109, v2111);
                                    let v2113 = constructor_bswap_reg(ctx, v644, v2112);
                                    let v2114 = constructor_output_reg(ctx, v2113);
                                    let v2115 = Some(v2114);
                                    // Rule at src\isa\s390x\lower.isle line 2966.
                                    return v2115;
                                }
                            }
                            &AtomicRmwOp::Or => {
                                let v2099 = C::bigendian(ctx, v2094);
                                if let Some(v2100) = v2099 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2102 = C::zero_offset(ctx);
                                    let v2103 = &constructor_lower_address(ctx, v2094, v2096.0, v2102);
                                    let v2116 = constructor_atomic_rmw_or(ctx, v644, v2101, v2103);
                                    let v2117 = constructor_output_reg(ctx, v2116);
                                    let v2118 = Some(v2117);
                                    // Rule at src\isa\s390x\lower.isle line 2972.
                                    return v2118;
                                }
                                let v2107 = C::littleendian(ctx, v2094);
                                if let Some(v2108) = v2107 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2109 = constructor_bswap_reg(ctx, v644, v2101);
                                    let v2110 = C::zero_offset(ctx);
                                    let v2111 = &constructor_lower_address(ctx, v2094, v2096.0, v2110);
                                    let v2119 = constructor_atomic_rmw_or(ctx, v644, v2109, v2111);
                                    let v2120 = constructor_bswap_reg(ctx, v644, v2119);
                                    let v2121 = constructor_output_reg(ctx, v2120);
                                    let v2122 = Some(v2121);
                                    // Rule at src\isa\s390x\lower.isle line 2978.
                                    return v2122;
                                }
                            }
                            &AtomicRmwOp::Sub => {
                                let v2099 = C::bigendian(ctx, v2094);
                                if let Some(v2100) = v2099 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2133 = constructor_neg_reg(ctx, v644, v2101);
                                    let v2110 = C::zero_offset(ctx);
                                    let v2111 = &constructor_lower_address(ctx, v2094, v2096.0, v2110);
                                    let v2134 = constructor_atomic_rmw_add(ctx, v644, v2133, v2111);
                                    let v2135 = constructor_output_reg(ctx, v2134);
                                    let v2136 = Some(v2135);
                                    // Rule at src\isa\s390x\lower.isle line 3002.
                                    return v2136;
                                }
                            }
                            &AtomicRmwOp::Xor => {
                                let v2099 = C::bigendian(ctx, v2094);
                                if let Some(v2100) = v2099 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2102 = C::zero_offset(ctx);
                                    let v2103 = &constructor_lower_address(ctx, v2094, v2096.0, v2102);
                                    let v2123 = constructor_atomic_rmw_xor(ctx, v644, v2101, v2103);
                                    let v2124 = constructor_output_reg(ctx, v2123);
                                    let v2125 = Some(v2124);
                                    // Rule at src\isa\s390x\lower.isle line 2984.
                                    return v2125;
                                }
                                let v2107 = C::littleendian(ctx, v2094);
                                if let Some(v2108) = v2107 {
                                    let v2096 = C::unpack_value_array_2(ctx, v2093);
                                    let v2101 = C::put_in_reg(ctx, v2096.1);
                                    let v2109 = constructor_bswap_reg(ctx, v644, v2101);
                                    let v2110 = C::zero_offset(ctx);
                                    let v2111 = &constructor_lower_address(ctx, v2094, v2096.0, v2110);
                                    let v2126 = constructor_atomic_rmw_xor(ctx, v644, v2109, v2111);
                                    let v2127 = constructor_bswap_reg(ctx, v644, v2126);
                                    let v2128 = constructor_output_reg(ctx, v2127);
                                    let v2129 = Some(v2128);
                                    // Rule at src\isa\s390x\lower.isle line 2990.
                                    return v2129;
                                }
                            }
                            _ => {}
                        }
                        let v2096 = C::unpack_value_array_2(ctx, v2093);
                        let v2101 = C::put_in_reg(ctx, v2096.1);
                        let v2137 = C::put_in_reg(ctx, v2096.0);
                        let v2138 = &C::inst_builder_new(ctx);
                        let v2139 = constructor_casloop_val_reg(ctx);
                        let v2141 = constructor_casloop_tmp_reg(ctx);
                        let v2140 = C::writable_reg_to_reg(ctx, v2139);
                        let v2142 = constructor_atomic_rmw_body(ctx, v2138, v644, v2094, v2095, v2141, v2140, v2101);
                        let v2143 = constructor_casloop(ctx, v2138, v644, v2094, v2137, v2142);
                        let v2144 = constructor_output_reg(ctx, v2143);
                        let v2145 = Some(v2144);
                        // Rule at src\isa\s390x\lower.isle line 3011.
                        return v2145;
                    }
                    let v469 = C::ty_8_or_16(ctx, v3);
                    if let Some(v470) = v469 {
                        let v2096 = C::unpack_value_array_2(ctx, v2093);
                        let v2101 = C::put_in_reg(ctx, v2096.1);
                        let v2137 = C::put_in_reg(ctx, v2096.0);
                        let v2146 = constructor_casloop_bitshift(ctx, v2137);
                        let v2147 = constructor_casloop_aligned_addr(ctx, v2137);
                        let v2148 = &C::inst_builder_new(ctx);
                        let v2149 = constructor_casloop_val_reg(ctx);
                        let v2150 = C::writable_reg_to_reg(ctx, v2149);
                        let v2151 = constructor_casloop_rotate_in(ctx, v2148, v470, v2094, v2146, v2150);
                        let v2152 = constructor_casloop_tmp_reg(ctx);
                        let v2153 = constructor_atomic_rmw_body(ctx, v2148, v470, v2094, v2095, v2152, v2151, v2101);
                        let v2154 = constructor_casloop_rotate_out(ctx, v2148, v470, v2094, v2146, v2153);
                        let v2155 = constructor_casloop_subword(ctx, v2148, v470, v2094, v2147, v2146, v2154);
                        let v2156 = constructor_output_reg(ctx, v2155);
                        let v2157 = Some(v2156);
                        // Rule at src\isa\s390x\lower.isle line 3023.
                        return v2157;
                    }
                }
            }
        }
        &InstructionData::Binary {
            opcode: ref v53,
            args: ref v54,
        } => {
            match v53 {
                &Opcode::Swizzle => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v1854 = &C::lane_order(ctx);
                            match v1854 {
                                &LaneOrder::LittleEndian => {
                                    let v1862 = constructor_vec_imm(ctx, v183, 0x0_u128);
                                    let v55 = C::unpack_value_array_2(ctx, v54);
                                    let v59 = C::put_in_reg(ctx, v55.0);
                                    let v1864 = constructor_vec_imm_splat(ctx, I8X16, 0xef_u64);
                                    let v501 = C::put_in_reg(ctx, v55.1);
                                    let v1865 = constructor_vec_not(ctx, I8X16, v501);
                                    let v1866 = constructor_vec_umax(ctx, I8X16, v1864, v1865);
                                    let v1867 = constructor_vec_permute(ctx, v183, v1862, v59, v1866);
                                    let v1868 = constructor_output_reg(ctx, v1867);
                                    let v1869 = Some(v1868);
                                    // Rule at src\isa\s390x\lower.isle line 2287.
                                    return v1869;
                                }
                                &LaneOrder::BigEndian => {
                                    let v55 = C::unpack_value_array_2(ctx, v54);
                                    let v80 = C::put_in_reg(ctx, v55.0);
                                    let v1855 = constructor_vec_imm(ctx, v183, 0x0_u128);
                                    let v1857 = constructor_vec_imm_splat(ctx, I8X16, 0x10_u64);
                                    let v501 = C::put_in_reg(ctx, v55.1);
                                    let v1858 = constructor_vec_umin(ctx, I8X16, v1857, v501);
                                    let v1859 = constructor_vec_permute(ctx, v183, v80, v1855, v1858);
                                    let v1860 = constructor_output_reg(ctx, v1859);
                                    let v1861 = Some(v1860);
                                    // Rule at src\isa\s390x\lower.isle line 2268.
                                    return v1861;
                                }
                                _ => {}
                            }
                        }
                    }
                }
                &Opcode::Smin => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v373 = constructor_put_in_reg_sext32(ctx, v55.0);
                            let v374 = constructor_put_in_reg_sext32(ctx, v55.1);
                            let v345 = constructor_ty_ext32(ctx, v79);
                            let v375 = &constructor_icmps_reg(ctx, v345, v373, v374);
                            let v390 = &C::intcc_as_cond(ctx, &IntCC::SignedGreaterThan);
                            let v391 = &constructor_bool(ctx, v375, v390);
                            let v392 = constructor_select_bool_reg(ctx, v79, v391, v374, v373);
                            let v393 = constructor_output_reg(ctx, v392);
                            let v394 = Some(v393);
                            // Rule at src\isa\s390x\lower.isle line 321.
                            return v394;
                        }
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v395 = &constructor_vec_int128_scmphi(ctx, v80, v81);
                            let v396 = constructor_select_bool_reg(ctx, I128, v395, v81, v80);
                            let v397 = constructor_output_reg(ctx, v396);
                            let v398 = Some(v397);
                            // Rule at src\isa\s390x\lower.isle line 329.
                            return v398;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v399 = constructor_vec_smin(ctx, v183, v80, v81);
                            let v400 = constructor_output_reg(ctx, v399);
                            let v401 = Some(v400);
                            // Rule at src\isa\s390x\lower.isle line 336.
                            return v401;
                        }
                    }
                }
                &Opcode::Umin => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v344 = constructor_put_in_reg_zext32(ctx, v55.1);
                            let v345 = constructor_ty_ext32(ctx, v79);
                            let v346 = &constructor_icmpu_reg(ctx, v345, v343, v344);
                            let v361 = &C::intcc_as_cond(ctx, &IntCC::UnsignedGreaterThan);
                            let v362 = &constructor_bool(ctx, v346, v361);
                            let v363 = constructor_select_bool_reg(ctx, v79, v362, v344, v343);
                            let v364 = constructor_output_reg(ctx, v363);
                            let v365 = Some(v364);
                            // Rule at src\isa\s390x\lower.isle line 277.
                            return v365;
                        }
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v366 = &constructor_vec_int128_ucmphi(ctx, v80, v81);
                            let v367 = constructor_select_bool_reg(ctx, I128, v366, v81, v80);
                            let v368 = constructor_output_reg(ctx, v367);
                            let v369 = Some(v368);
                            // Rule at src\isa\s390x\lower.isle line 285.
                            return v369;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v370 = constructor_vec_umin(ctx, v183, v80, v81);
                            let v371 = constructor_output_reg(ctx, v370);
                            let v372 = Some(v371);
                            // Rule at src\isa\s390x\lower.isle line 292.
                            return v372;
                        }
                    }
                }
                &Opcode::Smax => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v373 = constructor_put_in_reg_sext32(ctx, v55.0);
                            let v374 = constructor_put_in_reg_sext32(ctx, v55.1);
                            let v345 = constructor_ty_ext32(ctx, v79);
                            let v375 = &constructor_icmps_reg(ctx, v345, v373, v374);
                            let v377 = &C::intcc_as_cond(ctx, &IntCC::SignedLessThan);
                            let v378 = &constructor_bool(ctx, v375, v377);
                            let v379 = constructor_select_bool_reg(ctx, v79, v378, v374, v373);
                            let v380 = constructor_output_reg(ctx, v379);
                            let v381 = Some(v380);
                            // Rule at src\isa\s390x\lower.isle line 299.
                            return v381;
                        }
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v382 = &constructor_vec_int128_scmphi(ctx, v81, v80);
                            let v383 = constructor_select_bool_reg(ctx, I128, v382, v81, v80);
                            let v384 = constructor_output_reg(ctx, v383);
                            let v385 = Some(v384);
                            // Rule at src\isa\s390x\lower.isle line 307.
                            return v385;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v386 = constructor_vec_smax(ctx, v183, v80, v81);
                            let v387 = constructor_output_reg(ctx, v386);
                            let v388 = Some(v387);
                            // Rule at src\isa\s390x\lower.isle line 314.
                            return v388;
                        }
                    }
                }
                &Opcode::Umax => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v344 = constructor_put_in_reg_zext32(ctx, v55.1);
                            let v345 = constructor_ty_ext32(ctx, v79);
                            let v346 = &constructor_icmpu_reg(ctx, v345, v343, v344);
                            let v348 = &C::intcc_as_cond(ctx, &IntCC::UnsignedLessThan);
                            let v349 = &constructor_bool(ctx, v346, v348);
                            let v350 = constructor_select_bool_reg(ctx, v79, v349, v344, v343);
                            let v351 = constructor_output_reg(ctx, v350);
                            let v352 = Some(v351);
                            // Rule at src\isa\s390x\lower.isle line 255.
                            return v352;
                        }
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v353 = &constructor_vec_int128_ucmphi(ctx, v81, v80);
                            let v354 = constructor_select_bool_reg(ctx, I128, v353, v81, v80);
                            let v355 = constructor_output_reg(ctx, v354);
                            let v356 = Some(v355);
                            // Rule at src\isa\s390x\lower.isle line 263.
                            return v356;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v357 = constructor_vec_umax(ctx, v183, v80, v81);
                            let v358 = constructor_output_reg(ctx, v357);
                            let v359 = Some(v358);
                            // Rule at src\isa\s390x\lower.isle line 270.
                            return v359;
                        }
                    }
                }
                &Opcode::AvgRound => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v402 = constructor_vec_uavg(ctx, v183, v80, v81);
                            let v403 = constructor_output_reg(ctx, v402);
                            let v404 = Some(v403);
                            // Rule at src\isa\s390x\lower.isle line 343.
                            return v404;
                        }
                    }
                }
                &Opcode::UaddSat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v184 = constructor_vec_add(ctx, v183, v80, v81);
                            let v185 = C::put_in_reg(ctx, v55.0);
                            let v186 = constructor_vec_cmphl(ctx, v183, v185, v184);
                            let v187 = constructor_vec_or(ctx, v183, v184, v186);
                            let v188 = constructor_output_reg(ctx, v187);
                            let v189 = Some(v188);
                            // Rule at src\isa\s390x\lower.isle line 121.
                            return v189;
                        }
                    }
                }
                &Opcode::SaddSat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v190 = constructor_vec_widen_type(ctx, v183);
                            let v191 = constructor_vec_widen_type(ctx, v183);
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v192 = C::put_in_reg(ctx, v55.0);
                            let v193 = constructor_vec_unpacks_high(ctx, v183, v192);
                            let v194 = C::put_in_reg(ctx, v55.1);
                            let v195 = constructor_vec_unpacks_high(ctx, v183, v194);
                            let v196 = constructor_vec_add(ctx, v191, v193, v195);
                            let v197 = constructor_vec_widen_type(ctx, v183);
                            let v198 = C::put_in_reg(ctx, v55.0);
                            let v199 = constructor_vec_unpacks_low(ctx, v183, v198);
                            let v200 = C::put_in_reg(ctx, v55.1);
                            let v201 = constructor_vec_unpacks_low(ctx, v183, v200);
                            let v202 = constructor_vec_add(ctx, v197, v199, v201);
                            let v203 = constructor_vec_pack_ssat(ctx, v190, v196, v202);
                            let v204 = constructor_output_reg(ctx, v203);
                            let v205 = Some(v204);
                            // Rule at src\isa\s390x\lower.isle line 129.
                            return v205;
                        }
                    }
                }
                &Opcode::UsubSat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v294 = constructor_vec_sub(ctx, v183, v80, v81);
                            let v185 = C::put_in_reg(ctx, v55.0);
                            let v194 = C::put_in_reg(ctx, v55.1);
                            let v295 = constructor_vec_cmphl(ctx, v183, v185, v194);
                            let v296 = constructor_vec_and(ctx, v183, v294, v295);
                            let v297 = constructor_output_reg(ctx, v296);
                            let v298 = Some(v297);
                            // Rule at src\isa\s390x\lower.isle line 193.
                            return v298;
                        }
                    }
                }
                &Opcode::SsubSat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v190 = constructor_vec_widen_type(ctx, v183);
                            let v191 = constructor_vec_widen_type(ctx, v183);
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v192 = C::put_in_reg(ctx, v55.0);
                            let v193 = constructor_vec_unpacks_high(ctx, v183, v192);
                            let v194 = C::put_in_reg(ctx, v55.1);
                            let v195 = constructor_vec_unpacks_high(ctx, v183, v194);
                            let v299 = constructor_vec_sub(ctx, v191, v193, v195);
                            let v197 = constructor_vec_widen_type(ctx, v183);
                            let v198 = C::put_in_reg(ctx, v55.0);
                            let v199 = constructor_vec_unpacks_low(ctx, v183, v198);
                            let v200 = C::put_in_reg(ctx, v55.1);
                            let v201 = constructor_vec_unpacks_low(ctx, v183, v200);
                            let v300 = constructor_vec_sub(ctx, v197, v199, v201);
                            let v301 = constructor_vec_pack_ssat(ctx, v190, v299, v300);
                            let v302 = constructor_output_reg(ctx, v301);
                            let v303 = Some(v302);
                            // Rule at src\isa\s390x\lower.isle line 200.
                            return v303;
                        }
                    }
                }
                &Opcode::Iadd => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v95 = C::def_inst(ctx, v55.0);
                            if let Some(v96) = v95 {
                                let v97 = &C::inst_data_value(ctx, v96);
                                if let &InstructionData::Unary {
                                    opcode: ref v98,
                                    arg: v99,
                                } = v97 {
                                    if let &Opcode::Sextend = v98 {
                                        let v100 = C::value_type(ctx, v99);
                                        if v100 == I32 {
                                            let v58 = C::put_in_reg(ctx, v55.1);
                                            let v101 = C::put_in_reg(ctx, v99);
                                            let v102 = constructor_add_reg_sext32(ctx, v79, v58, v101);
                                            let v103 = constructor_output_reg(ctx, v102);
                                            let v104 = Some(v103);
                                            // Rule at src\isa\s390x\lower.isle line 78.
                                            return v104;
                                        }
                                    }
                                }
                            }
                            let v110 = C::i16_from_value(ctx, v55.0);
                            if let Some(v111) = v110 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v112 = constructor_add_simm16(ctx, v79, v58, v111);
                                let v113 = constructor_output_reg(ctx, v112);
                                let v114 = Some(v113);
                                // Rule at src\isa\s390x\lower.isle line 84.
                                return v114;
                            }
                            let v120 = C::i32_from_value(ctx, v55.0);
                            if let Some(v121) = v120 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v122 = constructor_add_simm32(ctx, v79, v58, v121);
                                let v123 = constructor_output_reg(ctx, v122);
                                let v124 = Some(v123);
                                // Rule at src\isa\s390x\lower.isle line 88.
                                return v124;
                            }
                            let v144 = C::sinkable_inst(ctx, v55.0);
                            if let Some(v145) = v144 {
                                let v146 = &C::inst_data_value(ctx, v145);
                                if let &InstructionData::Load {
                                    opcode: ref v147,
                                    arg: v148,
                                    flags: v149,
                                    offset: v150,
                                } = v146 {
                                    match v147 {
                                        &Opcode::Load => {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v141 = C::value_type(ctx, v55.0);
                                                let v142 = C::ty_32_or_64(ctx, v141);
                                                if let Some(v143) = v142 {
                                                    let v58 = C::put_in_reg(ctx, v55.1);
                                                    let v153 = &constructor_sink_load(ctx, v145);
                                                    let v154 = constructor_add_mem(ctx, v79, v58, v153);
                                                    let v155 = constructor_output_reg(ctx, v154);
                                                    let v156 = Some(v155);
                                                    // Rule at src\isa\s390x\lower.isle line 94.
                                                    return v156;
                                                }
                                                if v141 == I16 {
                                                    let v58 = C::put_in_reg(ctx, v55.1);
                                                    let v153 = &constructor_sink_load(ctx, v145);
                                                    let v160 = constructor_add_mem_sext16(ctx, v79, v58, v153);
                                                    let v161 = constructor_output_reg(ctx, v160);
                                                    let v162 = Some(v161);
                                                    // Rule at src\isa\s390x\lower.isle line 100.
                                                    return v162;
                                                }
                                            }
                                        }
                                        &Opcode::Sload16 => {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v167 = &constructor_sink_sload16(ctx, v145);
                                                let v168 = constructor_add_mem_sext16(ctx, v79, v58, v167);
                                                let v169 = constructor_output_reg(ctx, v168);
                                                let v170 = Some(v169);
                                                // Rule at src\isa\s390x\lower.isle line 106.
                                                return v170;
                                            }
                                        }
                                        &Opcode::Sload32 => {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v175 = &constructor_sink_sload32(ctx, v145);
                                                let v176 = constructor_add_mem_sext32(ctx, v79, v58, v175);
                                                let v177 = constructor_output_reg(ctx, v176);
                                                let v178 = Some(v177);
                                                // Rule at src\isa\s390x\lower.isle line 110.
                                                return v178;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            let v85 = C::def_inst(ctx, v55.1);
                            if let Some(v86) = v85 {
                                let v87 = &C::inst_data_value(ctx, v86);
                                if let &InstructionData::Unary {
                                    opcode: ref v88,
                                    arg: v89,
                                } = v87 {
                                    if let &Opcode::Sextend = v88 {
                                        let v90 = C::value_type(ctx, v89);
                                        if v90 == I32 {
                                            let v80 = C::put_in_reg(ctx, v55.0);
                                            let v91 = C::put_in_reg(ctx, v89);
                                            let v92 = constructor_add_reg_sext32(ctx, v79, v80, v91);
                                            let v93 = constructor_output_reg(ctx, v92);
                                            let v94 = Some(v93);
                                            // Rule at src\isa\s390x\lower.isle line 76.
                                            return v94;
                                        }
                                    }
                                }
                            }
                            let v105 = C::i16_from_value(ctx, v55.1);
                            if let Some(v106) = v105 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v107 = constructor_add_simm16(ctx, v79, v80, v106);
                                let v108 = constructor_output_reg(ctx, v107);
                                let v109 = Some(v108);
                                // Rule at src\isa\s390x\lower.isle line 82.
                                return v109;
                            }
                            let v115 = C::i32_from_value(ctx, v55.1);
                            if let Some(v116) = v115 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v117 = constructor_add_simm32(ctx, v79, v80, v116);
                                let v118 = constructor_output_reg(ctx, v117);
                                let v119 = Some(v118);
                                // Rule at src\isa\s390x\lower.isle line 86.
                                return v119;
                            }
                            let v128 = C::sinkable_inst(ctx, v55.1);
                            if let Some(v129) = v128 {
                                let v130 = &C::inst_data_value(ctx, v129);
                                if let &InstructionData::Load {
                                    opcode: ref v131,
                                    arg: v132,
                                    flags: v133,
                                    offset: v134,
                                } = v130 {
                                    match v131 {
                                        &Opcode::Load => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v125 = C::value_type(ctx, v55.1);
                                                let v126 = C::ty_32_or_64(ctx, v125);
                                                if let Some(v127) = v126 {
                                                    let v80 = C::put_in_reg(ctx, v55.0);
                                                    let v137 = &constructor_sink_load(ctx, v129);
                                                    let v138 = constructor_add_mem(ctx, v79, v80, v137);
                                                    let v139 = constructor_output_reg(ctx, v138);
                                                    let v140 = Some(v139);
                                                    // Rule at src\isa\s390x\lower.isle line 92.
                                                    return v140;
                                                }
                                                if v125 == I16 {
                                                    let v80 = C::put_in_reg(ctx, v55.0);
                                                    let v137 = &constructor_sink_load(ctx, v129);
                                                    let v157 = constructor_add_mem_sext16(ctx, v79, v80, v137);
                                                    let v158 = constructor_output_reg(ctx, v157);
                                                    let v159 = Some(v158);
                                                    // Rule at src\isa\s390x\lower.isle line 98.
                                                    return v159;
                                                }
                                            }
                                        }
                                        &Opcode::Sload16 => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v163 = &constructor_sink_sload16(ctx, v129);
                                                let v164 = constructor_add_mem_sext16(ctx, v79, v80, v163);
                                                let v165 = constructor_output_reg(ctx, v164);
                                                let v166 = Some(v165);
                                                // Rule at src\isa\s390x\lower.isle line 104.
                                                return v166;
                                            }
                                        }
                                        &Opcode::Sload32 => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v171 = &constructor_sink_sload32(ctx, v129);
                                                let v172 = constructor_add_mem_sext32(ctx, v79, v80, v171);
                                                let v173 = constructor_output_reg(ctx, v172);
                                                let v174 = Some(v173);
                                                // Rule at src\isa\s390x\lower.isle line 108.
                                                return v174;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v179 = constructor_vec_add(ctx, v52, v80, v81);
                            let v180 = constructor_output_reg(ctx, v179);
                            let v181 = Some(v180);
                            // Rule at src\isa\s390x\lower.isle line 114.
                            return v181;
                        }
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v82 = constructor_add_reg(ctx, v79, v80, v81);
                            let v83 = constructor_output_reg(ctx, v82);
                            let v84 = Some(v83);
                            // Rule at src\isa\s390x\lower.isle line 72.
                            return v84;
                        }
                    }
                }
                &Opcode::Isub => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v85 = C::def_inst(ctx, v55.1);
                            if let Some(v86) = v85 {
                                let v87 = &C::inst_data_value(ctx, v86);
                                if let &InstructionData::Unary {
                                    opcode: ref v88,
                                    arg: v89,
                                } = v87 {
                                    if let &Opcode::Sextend = v88 {
                                        let v90 = C::value_type(ctx, v89);
                                        if v90 == I32 {
                                            let v80 = C::put_in_reg(ctx, v55.0);
                                            let v91 = C::put_in_reg(ctx, v89);
                                            let v266 = constructor_sub_reg_sext32(ctx, v79, v80, v91);
                                            let v267 = constructor_output_reg(ctx, v266);
                                            let v268 = Some(v267);
                                            // Rule at src\isa\s390x\lower.isle line 162.
                                            return v268;
                                        }
                                    }
                                }
                            }
                            let v269 = C::i16_from_negated_value(ctx, v55.1);
                            if let Some(v270) = v269 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v271 = constructor_add_simm16(ctx, v79, v80, v270);
                                let v272 = constructor_output_reg(ctx, v271);
                                let v273 = Some(v272);
                                // Rule at src\isa\s390x\lower.isle line 166.
                                return v273;
                            }
                            let v274 = C::i32_from_negated_value(ctx, v55.1);
                            if let Some(v275) = v274 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v276 = constructor_add_simm32(ctx, v79, v80, v275);
                                let v277 = constructor_output_reg(ctx, v276);
                                let v278 = Some(v277);
                                // Rule at src\isa\s390x\lower.isle line 168.
                                return v278;
                            }
                            let v128 = C::sinkable_inst(ctx, v55.1);
                            if let Some(v129) = v128 {
                                let v130 = &C::inst_data_value(ctx, v129);
                                if let &InstructionData::Load {
                                    opcode: ref v131,
                                    arg: v132,
                                    flags: v133,
                                    offset: v134,
                                } = v130 {
                                    match v131 {
                                        &Opcode::Load => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v125 = C::value_type(ctx, v55.1);
                                                let v126 = C::ty_32_or_64(ctx, v125);
                                                if let Some(v127) = v126 {
                                                    let v80 = C::put_in_reg(ctx, v55.0);
                                                    let v137 = &constructor_sink_load(ctx, v129);
                                                    let v279 = constructor_sub_mem(ctx, v79, v80, v137);
                                                    let v280 = constructor_output_reg(ctx, v279);
                                                    let v281 = Some(v280);
                                                    // Rule at src\isa\s390x\lower.isle line 172.
                                                    return v281;
                                                }
                                                if v125 == I16 {
                                                    let v80 = C::put_in_reg(ctx, v55.0);
                                                    let v137 = &constructor_sink_load(ctx, v129);
                                                    let v282 = constructor_sub_mem_sext16(ctx, v79, v80, v137);
                                                    let v283 = constructor_output_reg(ctx, v282);
                                                    let v284 = Some(v283);
                                                    // Rule at src\isa\s390x\lower.isle line 176.
                                                    return v284;
                                                }
                                            }
                                        }
                                        &Opcode::Sload16 => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v163 = &constructor_sink_sload16(ctx, v129);
                                                let v285 = constructor_sub_mem_sext16(ctx, v79, v80, v163);
                                                let v286 = constructor_output_reg(ctx, v285);
                                                let v287 = Some(v286);
                                                // Rule at src\isa\s390x\lower.isle line 180.
                                                return v287;
                                            }
                                        }
                                        &Opcode::Sload32 => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v171 = &constructor_sink_sload32(ctx, v129);
                                                let v288 = constructor_sub_mem_sext32(ctx, v79, v80, v171);
                                                let v289 = constructor_output_reg(ctx, v288);
                                                let v290 = Some(v289);
                                                // Rule at src\isa\s390x\lower.isle line 182.
                                                return v290;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v291 = constructor_vec_sub(ctx, v52, v80, v81);
                            let v292 = constructor_output_reg(ctx, v291);
                            let v293 = Some(v292);
                            // Rule at src\isa\s390x\lower.isle line 186.
                            return v293;
                        }
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v263 = constructor_sub_reg(ctx, v79, v80, v81);
                            let v264 = constructor_output_reg(ctx, v263);
                            let v265 = Some(v264);
                            // Rule at src\isa\s390x\lower.isle line 158.
                            return v265;
                        }
                    }
                }
                &Opcode::Imul => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v95 = C::def_inst(ctx, v55.0);
                        if let Some(v96) = v95 {
                            let v97 = &C::inst_data_value(ctx, v96);
                            if let &InstructionData::Unary {
                                opcode: ref v98,
                                arg: v99,
                            } = v97 {
                                match v98 {
                                    &Opcode::Uextend => {
                                        let v3 = C::value_type(ctx, v2);
                                        if v3 == I128 {
                                            let v85 = C::def_inst(ctx, v55.1);
                                            if let Some(v86) = v85 {
                                                let v87 = &C::inst_data_value(ctx, v86);
                                                if let &InstructionData::Unary {
                                                    opcode: ref v88,
                                                    arg: v89,
                                                } = v87 {
                                                    if let &Opcode::Uextend = v88 {
                                                        let v453 = constructor_put_in_reg_zext64(ctx, v99);
                                                        let v454 = constructor_put_in_reg_zext64(ctx, v89);
                                                        let v455 = constructor_umul_wide(ctx, v453, v454);
                                                        let v456 = C::regpair_hi(ctx, v455);
                                                        let v457 = C::regpair_lo(ctx, v455);
                                                        let v458 = constructor_mov_to_vec128(ctx, I64X2, v456, v457);
                                                        let v459 = constructor_output_reg(ctx, v458);
                                                        let v460 = Some(v459);
                                                        // Rule at src\isa\s390x\lower.isle line 425.
                                                        return v460;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    &Opcode::Sextend => {
                                        let v3 = C::value_type(ctx, v2);
                                        if v3 == I128 {
                                            let v85 = C::def_inst(ctx, v55.1);
                                            if let Some(v86) = v85 {
                                                let v87 = &C::inst_data_value(ctx, v86);
                                                if let &InstructionData::Unary {
                                                    opcode: ref v88,
                                                    arg: v89,
                                                } = v87 {
                                                    if let &Opcode::Sextend = v88 {
                                                        let v461 = constructor_put_in_reg_sext64(ctx, v99);
                                                        let v462 = constructor_put_in_reg_sext64(ctx, v89);
                                                        let v463 = constructor_smul_wide(ctx, v461, v462);
                                                        let v464 = C::regpair_hi(ctx, v463);
                                                        let v465 = C::regpair_lo(ctx, v463);
                                                        let v466 = constructor_mov_to_vec128(ctx, I64X2, v464, v465);
                                                        let v467 = constructor_output_reg(ctx, v466);
                                                        let v468 = Some(v467);
                                                        // Rule at src\isa\s390x\lower.isle line 429.
                                                        return v468;
                                                    }
                                                }
                                            }
                                        }
                                        let v78 = C::fits_in_64(ctx, v3);
                                        if let Some(v79) = v78 {
                                            let v100 = C::value_type(ctx, v99);
                                            if v100 == I32 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v101 = C::put_in_reg(ctx, v99);
                                                let v411 = constructor_mul_reg_sext32(ctx, v79, v58, v101);
                                                let v412 = constructor_output_reg(ctx, v411);
                                                let v413 = Some(v412);
                                                // Rule at src\isa\s390x\lower.isle line 356.
                                                return v413;
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v110 = C::i16_from_value(ctx, v55.0);
                            if let Some(v111) = v110 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v417 = constructor_mul_simm16(ctx, v79, v58, v111);
                                let v418 = constructor_output_reg(ctx, v417);
                                let v419 = Some(v418);
                                // Rule at src\isa\s390x\lower.isle line 362.
                                return v419;
                            }
                            let v120 = C::i32_from_value(ctx, v55.0);
                            if let Some(v121) = v120 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v423 = constructor_mul_simm32(ctx, v79, v58, v121);
                                let v424 = constructor_output_reg(ctx, v423);
                                let v425 = Some(v424);
                                // Rule at src\isa\s390x\lower.isle line 366.
                                return v425;
                            }
                            let v144 = C::sinkable_inst(ctx, v55.0);
                            if let Some(v145) = v144 {
                                let v146 = &C::inst_data_value(ctx, v145);
                                if let &InstructionData::Load {
                                    opcode: ref v147,
                                    arg: v148,
                                    flags: v149,
                                    offset: v150,
                                } = v146 {
                                    match v147 {
                                        &Opcode::Load => {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v141 = C::value_type(ctx, v55.0);
                                                let v142 = C::ty_32_or_64(ctx, v141);
                                                if let Some(v143) = v142 {
                                                    let v58 = C::put_in_reg(ctx, v55.1);
                                                    let v153 = &constructor_sink_load(ctx, v145);
                                                    let v429 = constructor_mul_mem(ctx, v79, v58, v153);
                                                    let v430 = constructor_output_reg(ctx, v429);
                                                    let v431 = Some(v430);
                                                    // Rule at src\isa\s390x\lower.isle line 372.
                                                    return v431;
                                                }
                                                if v141 == I16 {
                                                    let v58 = C::put_in_reg(ctx, v55.1);
                                                    let v153 = &constructor_sink_load(ctx, v145);
                                                    let v435 = constructor_mul_mem_sext16(ctx, v79, v58, v153);
                                                    let v436 = constructor_output_reg(ctx, v435);
                                                    let v437 = Some(v436);
                                                    // Rule at src\isa\s390x\lower.isle line 378.
                                                    return v437;
                                                }
                                            }
                                        }
                                        &Opcode::Sload16 => {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v167 = &constructor_sink_sload16(ctx, v145);
                                                let v441 = constructor_mul_mem_sext16(ctx, v79, v58, v167);
                                                let v442 = constructor_output_reg(ctx, v441);
                                                let v443 = Some(v442);
                                                // Rule at src\isa\s390x\lower.isle line 384.
                                                return v443;
                                            }
                                        }
                                        &Opcode::Sload32 => {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v175 = &constructor_sink_sload32(ctx, v145);
                                                let v447 = constructor_mul_mem_sext32(ctx, v79, v58, v175);
                                                let v448 = constructor_output_reg(ctx, v447);
                                                let v449 = Some(v448);
                                                // Rule at src\isa\s390x\lower.isle line 388.
                                                return v449;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            let v85 = C::def_inst(ctx, v55.1);
                            if let Some(v86) = v85 {
                                let v87 = &C::inst_data_value(ctx, v86);
                                if let &InstructionData::Unary {
                                    opcode: ref v88,
                                    arg: v89,
                                } = v87 {
                                    if let &Opcode::Sextend = v88 {
                                        let v90 = C::value_type(ctx, v89);
                                        if v90 == I32 {
                                            let v80 = C::put_in_reg(ctx, v55.0);
                                            let v91 = C::put_in_reg(ctx, v89);
                                            let v408 = constructor_mul_reg_sext32(ctx, v79, v80, v91);
                                            let v409 = constructor_output_reg(ctx, v408);
                                            let v410 = Some(v409);
                                            // Rule at src\isa\s390x\lower.isle line 354.
                                            return v410;
                                        }
                                    }
                                }
                            }
                            let v105 = C::i16_from_value(ctx, v55.1);
                            if let Some(v106) = v105 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v414 = constructor_mul_simm16(ctx, v79, v80, v106);
                                let v415 = constructor_output_reg(ctx, v414);
                                let v416 = Some(v415);
                                // Rule at src\isa\s390x\lower.isle line 360.
                                return v416;
                            }
                            let v115 = C::i32_from_value(ctx, v55.1);
                            if let Some(v116) = v115 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v420 = constructor_mul_simm32(ctx, v79, v80, v116);
                                let v421 = constructor_output_reg(ctx, v420);
                                let v422 = Some(v421);
                                // Rule at src\isa\s390x\lower.isle line 364.
                                return v422;
                            }
                            let v128 = C::sinkable_inst(ctx, v55.1);
                            if let Some(v129) = v128 {
                                let v130 = &C::inst_data_value(ctx, v129);
                                if let &InstructionData::Load {
                                    opcode: ref v131,
                                    arg: v132,
                                    flags: v133,
                                    offset: v134,
                                } = v130 {
                                    match v131 {
                                        &Opcode::Load => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v125 = C::value_type(ctx, v55.1);
                                                let v126 = C::ty_32_or_64(ctx, v125);
                                                if let Some(v127) = v126 {
                                                    let v80 = C::put_in_reg(ctx, v55.0);
                                                    let v137 = &constructor_sink_load(ctx, v129);
                                                    let v426 = constructor_mul_mem(ctx, v79, v80, v137);
                                                    let v427 = constructor_output_reg(ctx, v426);
                                                    let v428 = Some(v427);
                                                    // Rule at src\isa\s390x\lower.isle line 370.
                                                    return v428;
                                                }
                                                if v125 == I16 {
                                                    let v80 = C::put_in_reg(ctx, v55.0);
                                                    let v137 = &constructor_sink_load(ctx, v129);
                                                    let v432 = constructor_mul_mem_sext16(ctx, v79, v80, v137);
                                                    let v433 = constructor_output_reg(ctx, v432);
                                                    let v434 = Some(v433);
                                                    // Rule at src\isa\s390x\lower.isle line 376.
                                                    return v434;
                                                }
                                            }
                                        }
                                        &Opcode::Sload16 => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v163 = &constructor_sink_sload16(ctx, v129);
                                                let v438 = constructor_mul_mem_sext16(ctx, v79, v80, v163);
                                                let v439 = constructor_output_reg(ctx, v438);
                                                let v440 = Some(v439);
                                                // Rule at src\isa\s390x\lower.isle line 382.
                                                return v440;
                                            }
                                        }
                                        &Opcode::Sload32 => {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v171 = &constructor_sink_sload32(ctx, v129);
                                                let v444 = constructor_mul_mem_sext32(ctx, v79, v80, v171);
                                                let v445 = constructor_output_reg(ctx, v444);
                                                let v446 = Some(v445);
                                                // Rule at src\isa\s390x\lower.isle line 386.
                                                return v446;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v450 = constructor_vec_mul_impl(ctx, v52, v80, v81);
                            let v451 = constructor_output_reg(ctx, v450);
                            let v452 = Some(v451);
                            // Rule at src\isa\s390x\lower.isle line 393.
                            return v452;
                        }
                        if let Some(v79) = v78 {
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v405 = constructor_mul_reg(ctx, v79, v80, v81);
                            let v406 = constructor_output_reg(ctx, v405);
                            let v407 = Some(v406);
                            // Rule at src\isa\s390x\lower.isle line 350.
                            return v407;
                        }
                    }
                }
                &Opcode::Umulhi => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            I32 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v477 = constructor_put_in_reg_zext64(ctx, v55.0);
                                let v478 = constructor_put_in_reg_zext64(ctx, v55.1);
                                let v480 = constructor_mul_reg(ctx, I64, v477, v478);
                                let v482 = constructor_lshr_imm(ctx, I64, v480, 0x20_u8);
                                let v483 = constructor_output_reg(ctx, v482);
                                let v484 = Some(v483);
                                // Rule at src\isa\s390x\lower.isle line 443.
                                return v484;
                            }
                            I64 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v485 = constructor_umul_wide(ctx, v80, v81);
                                let v486 = C::regpair_hi(ctx, v485);
                                let v487 = constructor_output_reg(ctx, v486);
                                let v488 = Some(v487);
                                // Rule at src\isa\s390x\lower.isle line 450.
                                return v488;
                            }
                            I8X16 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v489 = constructor_vec_umulhi(ctx, I8X16, v80, v81);
                                let v490 = constructor_output_reg(ctx, v489);
                                let v491 = Some(v490);
                                // Rule at src\isa\s390x\lower.isle line 455.
                                return v491;
                            }
                            I16X8 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v493 = constructor_vec_umulhi(ctx, I16X8, v80, v81);
                                let v494 = constructor_output_reg(ctx, v493);
                                let v495 = Some(v494);
                                // Rule at src\isa\s390x\lower.isle line 456.
                                return v495;
                            }
                            I32X4 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v497 = constructor_vec_umulhi(ctx, I32X4, v80, v81);
                                let v498 = constructor_output_reg(ctx, v497);
                                let v499 = Some(v498);
                                // Rule at src\isa\s390x\lower.isle line 457.
                                return v499;
                            }
                            I64X2 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v69 = C::zero_reg(ctx);
                                let v500 = constructor_vec_extract_lane(ctx, I64X2, v80, 0x0_u8, v69);
                                let v501 = C::put_in_reg(ctx, v55.1);
                                let v502 = C::zero_reg(ctx);
                                let v503 = constructor_vec_extract_lane(ctx, I64X2, v501, 0x0_u8, v502);
                                let v504 = constructor_umul_wide(ctx, v500, v503);
                                let v505 = C::regpair_hi(ctx, v504);
                                let v198 = C::put_in_reg(ctx, v55.0);
                                let v506 = C::zero_reg(ctx);
                                let v507 = constructor_vec_extract_lane(ctx, I64X2, v198, 0x1_u8, v506);
                                let v508 = C::put_in_reg(ctx, v55.1);
                                let v509 = C::zero_reg(ctx);
                                let v510 = constructor_vec_extract_lane(ctx, I64X2, v508, 0x1_u8, v509);
                                let v511 = constructor_umul_wide(ctx, v507, v510);
                                let v512 = C::regpair_hi(ctx, v511);
                                let v513 = constructor_mov_to_vec128(ctx, I64X2, v505, v512);
                                let v514 = constructor_output_reg(ctx, v513);
                                let v515 = Some(v514);
                                // Rule at src\isa\s390x\lower.isle line 461.
                                return v515;
                            }
                            _ => {}
                        }
                        let v469 = C::ty_8_or_16(ctx, v3);
                        if let Some(v470) = v469 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v344 = constructor_put_in_reg_zext32(ctx, v55.1);
                            let v472 = constructor_mul_reg(ctx, I32, v343, v344);
                            let v473 = C::ty_bits(ctx, v470);
                            let v474 = constructor_lshr_imm(ctx, I32, v472, v473);
                            let v475 = constructor_output_reg(ctx, v474);
                            let v476 = Some(v475);
                            // Rule at src\isa\s390x\lower.isle line 436.
                            return v476;
                        }
                    }
                }
                &Opcode::Smulhi => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            I32 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v520 = constructor_put_in_reg_sext64(ctx, v55.0);
                                let v521 = constructor_put_in_reg_sext64(ctx, v55.1);
                                let v522 = constructor_mul_reg(ctx, I64, v520, v521);
                                let v523 = constructor_ashr_imm(ctx, I64, v522, 0x20_u8);
                                let v524 = constructor_output_reg(ctx, v523);
                                let v525 = Some(v524);
                                // Rule at src\isa\s390x\lower.isle line 481.
                                return v525;
                            }
                            I64 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v526 = constructor_smul_wide(ctx, v80, v81);
                                let v527 = C::regpair_hi(ctx, v526);
                                let v528 = constructor_output_reg(ctx, v527);
                                let v529 = Some(v528);
                                // Rule at src\isa\s390x\lower.isle line 488.
                                return v529;
                            }
                            I8X16 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v530 = constructor_vec_smulhi(ctx, I8X16, v80, v81);
                                let v531 = constructor_output_reg(ctx, v530);
                                let v532 = Some(v531);
                                // Rule at src\isa\s390x\lower.isle line 493.
                                return v532;
                            }
                            I16X8 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v533 = constructor_vec_smulhi(ctx, I16X8, v80, v81);
                                let v534 = constructor_output_reg(ctx, v533);
                                let v535 = Some(v534);
                                // Rule at src\isa\s390x\lower.isle line 494.
                                return v535;
                            }
                            I32X4 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v536 = constructor_vec_smulhi(ctx, I32X4, v80, v81);
                                let v537 = constructor_output_reg(ctx, v536);
                                let v538 = Some(v537);
                                // Rule at src\isa\s390x\lower.isle line 495.
                                return v538;
                            }
                            I64X2 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v69 = C::zero_reg(ctx);
                                let v500 = constructor_vec_extract_lane(ctx, I64X2, v80, 0x0_u8, v69);
                                let v501 = C::put_in_reg(ctx, v55.1);
                                let v502 = C::zero_reg(ctx);
                                let v503 = constructor_vec_extract_lane(ctx, I64X2, v501, 0x0_u8, v502);
                                let v539 = constructor_smul_wide(ctx, v500, v503);
                                let v540 = C::regpair_hi(ctx, v539);
                                let v541 = constructor_copy_reg(ctx, I64, v540);
                                let v542 = C::put_in_reg(ctx, v55.0);
                                let v543 = C::zero_reg(ctx);
                                let v544 = constructor_vec_extract_lane(ctx, I64X2, v542, 0x1_u8, v543);
                                let v545 = C::put_in_reg(ctx, v55.1);
                                let v546 = C::zero_reg(ctx);
                                let v547 = constructor_vec_extract_lane(ctx, I64X2, v545, 0x1_u8, v546);
                                let v548 = constructor_smul_wide(ctx, v544, v547);
                                let v549 = C::regpair_hi(ctx, v548);
                                let v550 = constructor_mov_to_vec128(ctx, I64X2, v541, v549);
                                let v551 = constructor_output_reg(ctx, v550);
                                let v552 = Some(v551);
                                // Rule at src\isa\s390x\lower.isle line 499.
                                return v552;
                            }
                            _ => {}
                        }
                        let v469 = C::ty_8_or_16(ctx, v3);
                        if let Some(v470) = v469 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v373 = constructor_put_in_reg_sext32(ctx, v55.0);
                            let v374 = constructor_put_in_reg_sext32(ctx, v55.1);
                            let v516 = constructor_mul_reg(ctx, I32, v373, v374);
                            let v473 = C::ty_bits(ctx, v470);
                            let v517 = constructor_ashr_imm(ctx, I32, v516, v473);
                            let v518 = constructor_output_reg(ctx, v517);
                            let v519 = Some(v518);
                            // Rule at src\isa\s390x\lower.isle line 474.
                            return v519;
                        }
                    }
                }
                &Opcode::SqmulRoundSat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v190 = constructor_vec_widen_type(ctx, v183);
                            let v191 = constructor_vec_widen_type(ctx, v183);
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v192 = C::put_in_reg(ctx, v55.0);
                            let v193 = constructor_vec_unpacks_high(ctx, v183, v192);
                            let v194 = C::put_in_reg(ctx, v55.1);
                            let v195 = constructor_vec_unpacks_high(ctx, v183, v194);
                            let v553 = constructor_sqmul_impl(ctx, v191, v193, v195);
                            let v197 = constructor_vec_widen_type(ctx, v183);
                            let v198 = C::put_in_reg(ctx, v55.0);
                            let v199 = constructor_vec_unpacks_low(ctx, v183, v198);
                            let v200 = C::put_in_reg(ctx, v55.1);
                            let v201 = constructor_vec_unpacks_low(ctx, v183, v200);
                            let v554 = constructor_sqmul_impl(ctx, v197, v199, v201);
                            let v555 = constructor_vec_pack_ssat(ctx, v190, v553, v554);
                            let v556 = constructor_output_reg(ctx, v555);
                            let v557 = Some(v556);
                            // Rule at src\isa\s390x\lower.isle line 512.
                            return v557;
                        }
                    }
                }
                &Opcode::Udiv => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v304 = constructor_ty_ext32(ctx, v79);
                            let v559 = constructor_imm(ctx, v304, 0x0_u64);
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v560 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v561 = C::regpair(ctx, v559, v560);
                            let v562 = constructor_put_in_reg_zext32(ctx, v55.1);
                            let v563 = constructor_ty_ext32(ctx, v79);
                            let v564 = constructor_udivmod(ctx, v563, v561, v562);
                            let v565 = C::regpair_lo(ctx, v564);
                            let v566 = constructor_output_reg(ctx, v565);
                            let v567 = Some(v566);
                            // Rule at src\isa\s390x\lower.isle line 550.
                            return v567;
                        }
                    }
                }
                &Opcode::Sdiv => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v571 = constructor_div_overflow_check_needed(ctx, v55.1);
                            let v572 = constructor_put_in_reg_sext64(ctx, v55.0);
                            let v573 = constructor_put_in_reg_sext32(ctx, v55.1);
                            let v574 = constructor_ty_ext32(ctx, v79);
                            let v575 = constructor_maybe_trap_if_sdiv_overflow(ctx, v571, v574, v79, v572, v573);
                            let v576 = constructor_sdivmod(ctx, v574, v572, v573);
                            let v577 = C::regpair_lo(ctx, v576);
                            let v578 = constructor_output_reg(ctx, v577);
                            let v579 = Some(v578);
                            // Rule at src\isa\s390x\lower.isle line 595.
                            return v579;
                        }
                    }
                }
                &Opcode::Urem => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v304 = constructor_ty_ext32(ctx, v79);
                            let v559 = constructor_imm(ctx, v304, 0x0_u64);
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v560 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v561 = C::regpair(ctx, v559, v560);
                            let v562 = constructor_put_in_reg_zext32(ctx, v55.1);
                            let v563 = constructor_ty_ext32(ctx, v79);
                            let v564 = constructor_udivmod(ctx, v563, v561, v562);
                            let v568 = C::regpair_hi(ctx, v564);
                            let v569 = constructor_output_reg(ctx, v568);
                            let v570 = Some(v569);
                            // Rule at src\isa\s390x\lower.isle line 569.
                            return v570;
                        }
                    }
                }
                &Opcode::Srem => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v571 = constructor_div_overflow_check_needed(ctx, v55.1);
                            let v572 = constructor_put_in_reg_sext64(ctx, v55.0);
                            let v573 = constructor_put_in_reg_sext32(ctx, v55.1);
                            let v574 = constructor_ty_ext32(ctx, v79);
                            let v580 = constructor_maybe_avoid_srem_overflow(ctx, v571, v574, v572, v573);
                            let v581 = constructor_sdivmod(ctx, v574, v580, v573);
                            let v582 = C::regpair_hi(ctx, v581);
                            let v583 = constructor_output_reg(ctx, v582);
                            let v584 = Some(v583);
                            // Rule at src\isa\s390x\lower.isle line 615.
                            return v584;
                        }
                    }
                }
                &Opcode::UaddOverflow => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v643 = C::ty_32_or_64(ctx, v3);
                        if let Some(v644) = v643 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v2562 = constructor_add_reg(ctx, v644, v80, v81);
                            let v185 = C::put_in_reg(ctx, v55.0);
                            let v2563 = &constructor_icmpu_reg(ctx, v644, v2562, v185);
                            let v2564 = &C::intcc_as_cond(ctx, &IntCC::UnsignedLessThan);
                            let v2565 = &constructor_bool(ctx, v2563, v2564);
                            let v2566 = constructor_lower_bool(ctx, I8, v2565);
                            let v2567 = C::value_reg(ctx, v2562);
                            let v2568 = C::value_reg(ctx, v2566);
                            let v2569 = C::output_pair(ctx, v2567, v2568);
                            let v2570 = Some(v2569);
                            // Rule at src\isa\s390x\lower.isle line 3952.
                            return v2570;
                        }
                    }
                }
                &Opcode::Band => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v95 = C::def_inst(ctx, v55.0);
                            if let Some(v96) = v95 {
                                let v97 = &C::inst_data_value(ctx, v96);
                                if let &InstructionData::Unary {
                                    opcode: ref v98,
                                    arg: v99,
                                } = v97 {
                                    if let &Opcode::Bnot = v98 {
                                        let v58 = C::put_in_reg(ctx, v55.1);
                                        let v101 = C::put_in_reg(ctx, v99);
                                        let v859 = constructor_vec_and_not(ctx, v52, v58, v101);
                                        let v860 = constructor_output_reg(ctx, v859);
                                        let v861 = Some(v860);
                                        // Rule at src\isa\s390x\lower.isle line 1048.
                                        return v861;
                                    }
                                }
                            }
                            let v85 = C::def_inst(ctx, v55.1);
                            if let Some(v86) = v85 {
                                let v87 = &C::inst_data_value(ctx, v86);
                                if let &InstructionData::Unary {
                                    opcode: ref v88,
                                    arg: v89,
                                } = v87 {
                                    if let &Opcode::Bnot = v88 {
                                        let v80 = C::put_in_reg(ctx, v55.0);
                                        let v91 = C::put_in_reg(ctx, v89);
                                        let v856 = constructor_vec_and_not(ctx, v52, v80, v91);
                                        let v857 = constructor_output_reg(ctx, v856);
                                        let v858 = Some(v857);
                                        // Rule at src\isa\s390x\lower.isle line 1046.
                                        return v858;
                                    }
                                }
                            }
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v792 = C::mie3_enabled(ctx, v3);
                            if let Some(v793) = v792 {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v95 = C::def_inst(ctx, v55.0);
                                if let Some(v96) = v95 {
                                    let v97 = &C::inst_data_value(ctx, v96);
                                    if let &InstructionData::Unary {
                                        opcode: ref v98,
                                        arg: v99,
                                    } = v97 {
                                        if let &Opcode::Bnot = v98 {
                                            let v58 = C::put_in_reg(ctx, v55.1);
                                            let v101 = C::put_in_reg(ctx, v99);
                                            let v853 = constructor_and_not_reg(ctx, v79, v58, v101);
                                            let v854 = constructor_output_reg(ctx, v853);
                                            let v855 = Some(v854);
                                            // Rule at src\isa\s390x\lower.isle line 1042.
                                            return v855;
                                        }
                                    }
                                }
                                let v85 = C::def_inst(ctx, v55.1);
                                if let Some(v86) = v85 {
                                    let v87 = &C::inst_data_value(ctx, v86);
                                    if let &InstructionData::Unary {
                                        opcode: ref v88,
                                        arg: v89,
                                    } = v87 {
                                        if let &Opcode::Bnot = v88 {
                                            let v80 = C::put_in_reg(ctx, v55.0);
                                            let v91 = C::put_in_reg(ctx, v89);
                                            let v850 = constructor_and_not_reg(ctx, v79, v80, v91);
                                            let v851 = constructor_output_reg(ctx, v850);
                                            let v852 = Some(v851);
                                            // Rule at src\isa\s390x\lower.isle line 1040.
                                            return v852;
                                        }
                                    }
                                }
                            }
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v826 = C::uimm16shifted_from_inverted_value(ctx, v55.0);
                            if let Some(v827) = v826 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v828 = constructor_and_uimm16shifted(ctx, v79, v58, v827);
                                let v829 = constructor_output_reg(ctx, v828);
                                let v830 = Some(v829);
                                // Rule at src\isa\s390x\lower.isle line 1018.
                                return v830;
                            }
                            let v821 = C::uimm16shifted_from_inverted_value(ctx, v55.1);
                            if let Some(v822) = v821 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v823 = constructor_and_uimm16shifted(ctx, v79, v80, v822);
                                let v824 = constructor_output_reg(ctx, v823);
                                let v825 = Some(v824);
                                // Rule at src\isa\s390x\lower.isle line 1016.
                                return v825;
                            }
                            let v836 = C::uimm32shifted_from_inverted_value(ctx, v55.0);
                            if let Some(v837) = v836 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v838 = constructor_and_uimm32shifted(ctx, v79, v58, v837);
                                let v839 = constructor_output_reg(ctx, v838);
                                let v840 = Some(v839);
                                // Rule at src\isa\s390x\lower.isle line 1022.
                                return v840;
                            }
                            let v831 = C::uimm32shifted_from_inverted_value(ctx, v55.1);
                            if let Some(v832) = v831 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v833 = constructor_and_uimm32shifted(ctx, v79, v80, v832);
                                let v834 = constructor_output_reg(ctx, v833);
                                let v835 = Some(v834);
                                // Rule at src\isa\s390x\lower.isle line 1020.
                                return v835;
                            }
                            let v141 = C::value_type(ctx, v55.0);
                            let v142 = C::ty_32_or_64(ctx, v141);
                            if let Some(v143) = v142 {
                                let v144 = C::sinkable_inst(ctx, v55.0);
                                if let Some(v145) = v144 {
                                    let v146 = &C::inst_data_value(ctx, v145);
                                    if let &InstructionData::Load {
                                        opcode: ref v147,
                                        arg: v148,
                                        flags: v149,
                                        offset: v150,
                                    } = v146 {
                                        if let &Opcode::Load = v147 {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v153 = &constructor_sink_load(ctx, v145);
                                                let v844 = constructor_and_mem(ctx, v79, v58, v153);
                                                let v845 = constructor_output_reg(ctx, v844);
                                                let v846 = Some(v845);
                                                // Rule at src\isa\s390x\lower.isle line 1028.
                                                return v846;
                                            }
                                        }
                                    }
                                }
                            }
                            let v125 = C::value_type(ctx, v55.1);
                            let v126 = C::ty_32_or_64(ctx, v125);
                            if let Some(v127) = v126 {
                                let v128 = C::sinkable_inst(ctx, v55.1);
                                if let Some(v129) = v128 {
                                    let v130 = &C::inst_data_value(ctx, v129);
                                    if let &InstructionData::Load {
                                        opcode: ref v131,
                                        arg: v132,
                                        flags: v133,
                                        offset: v134,
                                    } = v130 {
                                        if let &Opcode::Load = v131 {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v137 = &constructor_sink_load(ctx, v129);
                                                let v841 = constructor_and_mem(ctx, v79, v80, v137);
                                                let v842 = constructor_output_reg(ctx, v841);
                                                let v843 = Some(v842);
                                                // Rule at src\isa\s390x\lower.isle line 1026.
                                                return v843;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v847 = constructor_vec_and(ctx, v52, v80, v81);
                            let v848 = constructor_output_reg(ctx, v847);
                            let v849 = Some(v848);
                            // Rule at src\isa\s390x\lower.isle line 1032.
                            return v849;
                        }
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v818 = constructor_and_reg(ctx, v79, v80, v81);
                            let v819 = constructor_output_reg(ctx, v818);
                            let v820 = Some(v819);
                            // Rule at src\isa\s390x\lower.isle line 1012.
                            return v820;
                        }
                    }
                }
                &Opcode::Bor => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v95 = C::def_inst(ctx, v55.0);
                            if let Some(v96) = v95 {
                                let v97 = &C::inst_data_value(ctx, v96);
                                if let &InstructionData::Unary {
                                    opcode: ref v98,
                                    arg: v99,
                                } = v97 {
                                    if let &Opcode::Bnot = v98 {
                                        let v58 = C::put_in_reg(ctx, v55.1);
                                        let v101 = C::put_in_reg(ctx, v99);
                                        let v903 = constructor_vec_or_not(ctx, v52, v58, v101);
                                        let v904 = constructor_output_reg(ctx, v903);
                                        let v905 = Some(v904);
                                        // Rule at src\isa\s390x\lower.isle line 1090.
                                        return v905;
                                    }
                                }
                            }
                            let v85 = C::def_inst(ctx, v55.1);
                            if let Some(v86) = v85 {
                                let v87 = &C::inst_data_value(ctx, v86);
                                if let &InstructionData::Unary {
                                    opcode: ref v88,
                                    arg: v89,
                                } = v87 {
                                    if let &Opcode::Bnot = v88 {
                                        let v80 = C::put_in_reg(ctx, v55.0);
                                        let v91 = C::put_in_reg(ctx, v89);
                                        let v900 = constructor_vec_or_not(ctx, v52, v80, v91);
                                        let v901 = constructor_output_reg(ctx, v900);
                                        let v902 = Some(v901);
                                        // Rule at src\isa\s390x\lower.isle line 1088.
                                        return v902;
                                    }
                                }
                            }
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v792 = C::mie3_enabled(ctx, v3);
                            if let Some(v793) = v792 {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v95 = C::def_inst(ctx, v55.0);
                                if let Some(v96) = v95 {
                                    let v97 = &C::inst_data_value(ctx, v96);
                                    if let &InstructionData::Unary {
                                        opcode: ref v98,
                                        arg: v99,
                                    } = v97 {
                                        if let &Opcode::Bnot = v98 {
                                            let v58 = C::put_in_reg(ctx, v55.1);
                                            let v101 = C::put_in_reg(ctx, v99);
                                            let v897 = constructor_or_not_reg(ctx, v79, v58, v101);
                                            let v898 = constructor_output_reg(ctx, v897);
                                            let v899 = Some(v898);
                                            // Rule at src\isa\s390x\lower.isle line 1084.
                                            return v899;
                                        }
                                    }
                                }
                                let v85 = C::def_inst(ctx, v55.1);
                                if let Some(v86) = v85 {
                                    let v87 = &C::inst_data_value(ctx, v86);
                                    if let &InstructionData::Unary {
                                        opcode: ref v88,
                                        arg: v89,
                                    } = v87 {
                                        if let &Opcode::Bnot = v88 {
                                            let v80 = C::put_in_reg(ctx, v55.0);
                                            let v91 = C::put_in_reg(ctx, v89);
                                            let v894 = constructor_or_not_reg(ctx, v79, v80, v91);
                                            let v895 = constructor_output_reg(ctx, v894);
                                            let v896 = Some(v895);
                                            // Rule at src\isa\s390x\lower.isle line 1082.
                                            return v896;
                                        }
                                    }
                                }
                            }
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v870 = C::uimm16shifted_from_value(ctx, v55.0);
                            if let Some(v871) = v870 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v872 = constructor_or_uimm16shifted(ctx, v79, v58, v871);
                                let v873 = constructor_output_reg(ctx, v872);
                                let v874 = Some(v873);
                                // Rule at src\isa\s390x\lower.isle line 1060.
                                return v874;
                            }
                            let v865 = C::uimm16shifted_from_value(ctx, v55.1);
                            if let Some(v866) = v865 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v867 = constructor_or_uimm16shifted(ctx, v79, v80, v866);
                                let v868 = constructor_output_reg(ctx, v867);
                                let v869 = Some(v868);
                                // Rule at src\isa\s390x\lower.isle line 1058.
                                return v869;
                            }
                            let v880 = C::uimm32shifted_from_value(ctx, v55.0);
                            if let Some(v881) = v880 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v882 = constructor_or_uimm32shifted(ctx, v79, v58, v881);
                                let v883 = constructor_output_reg(ctx, v882);
                                let v884 = Some(v883);
                                // Rule at src\isa\s390x\lower.isle line 1064.
                                return v884;
                            }
                            let v875 = C::uimm32shifted_from_value(ctx, v55.1);
                            if let Some(v876) = v875 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v877 = constructor_or_uimm32shifted(ctx, v79, v80, v876);
                                let v878 = constructor_output_reg(ctx, v877);
                                let v879 = Some(v878);
                                // Rule at src\isa\s390x\lower.isle line 1062.
                                return v879;
                            }
                            let v141 = C::value_type(ctx, v55.0);
                            let v142 = C::ty_32_or_64(ctx, v141);
                            if let Some(v143) = v142 {
                                let v144 = C::sinkable_inst(ctx, v55.0);
                                if let Some(v145) = v144 {
                                    let v146 = &C::inst_data_value(ctx, v145);
                                    if let &InstructionData::Load {
                                        opcode: ref v147,
                                        arg: v148,
                                        flags: v149,
                                        offset: v150,
                                    } = v146 {
                                        if let &Opcode::Load = v147 {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v153 = &constructor_sink_load(ctx, v145);
                                                let v888 = constructor_or_mem(ctx, v79, v58, v153);
                                                let v889 = constructor_output_reg(ctx, v888);
                                                let v890 = Some(v889);
                                                // Rule at src\isa\s390x\lower.isle line 1070.
                                                return v890;
                                            }
                                        }
                                    }
                                }
                            }
                            let v125 = C::value_type(ctx, v55.1);
                            let v126 = C::ty_32_or_64(ctx, v125);
                            if let Some(v127) = v126 {
                                let v128 = C::sinkable_inst(ctx, v55.1);
                                if let Some(v129) = v128 {
                                    let v130 = &C::inst_data_value(ctx, v129);
                                    if let &InstructionData::Load {
                                        opcode: ref v131,
                                        arg: v132,
                                        flags: v133,
                                        offset: v134,
                                    } = v130 {
                                        if let &Opcode::Load = v131 {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v137 = &constructor_sink_load(ctx, v129);
                                                let v885 = constructor_or_mem(ctx, v79, v80, v137);
                                                let v886 = constructor_output_reg(ctx, v885);
                                                let v887 = Some(v886);
                                                // Rule at src\isa\s390x\lower.isle line 1068.
                                                return v887;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v891 = constructor_vec_or(ctx, v52, v80, v81);
                            let v892 = constructor_output_reg(ctx, v891);
                            let v893 = Some(v892);
                            // Rule at src\isa\s390x\lower.isle line 1074.
                            return v893;
                        }
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v862 = constructor_or_reg(ctx, v79, v80, v81);
                            let v863 = constructor_output_reg(ctx, v862);
                            let v864 = Some(v863);
                            // Rule at src\isa\s390x\lower.isle line 1054.
                            return v864;
                        }
                    }
                }
                &Opcode::Bxor => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v95 = C::def_inst(ctx, v55.0);
                            if let Some(v96) = v95 {
                                let v97 = &C::inst_data_value(ctx, v96);
                                if let &InstructionData::Unary {
                                    opcode: ref v98,
                                    arg: v99,
                                } = v97 {
                                    if let &Opcode::Bnot = v98 {
                                        let v58 = C::put_in_reg(ctx, v55.1);
                                        let v101 = C::put_in_reg(ctx, v99);
                                        let v933 = constructor_vec_not_xor(ctx, v52, v58, v101);
                                        let v934 = constructor_output_reg(ctx, v933);
                                        let v935 = Some(v934);
                                        // Rule at src\isa\s390x\lower.isle line 1129.
                                        return v935;
                                    }
                                }
                            }
                            let v85 = C::def_inst(ctx, v55.1);
                            if let Some(v86) = v85 {
                                let v87 = &C::inst_data_value(ctx, v86);
                                if let &InstructionData::Unary {
                                    opcode: ref v88,
                                    arg: v89,
                                } = v87 {
                                    if let &Opcode::Bnot = v88 {
                                        let v80 = C::put_in_reg(ctx, v55.0);
                                        let v91 = C::put_in_reg(ctx, v89);
                                        let v930 = constructor_vec_not_xor(ctx, v52, v80, v91);
                                        let v931 = constructor_output_reg(ctx, v930);
                                        let v932 = Some(v931);
                                        // Rule at src\isa\s390x\lower.isle line 1127.
                                        return v932;
                                    }
                                }
                            }
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v792 = C::mie3_enabled(ctx, v3);
                            if let Some(v793) = v792 {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v95 = C::def_inst(ctx, v55.0);
                                if let Some(v96) = v95 {
                                    let v97 = &C::inst_data_value(ctx, v96);
                                    if let &InstructionData::Unary {
                                        opcode: ref v98,
                                        arg: v99,
                                    } = v97 {
                                        if let &Opcode::Bnot = v98 {
                                            let v58 = C::put_in_reg(ctx, v55.1);
                                            let v101 = C::put_in_reg(ctx, v99);
                                            let v927 = constructor_not_xor_reg(ctx, v79, v58, v101);
                                            let v928 = constructor_output_reg(ctx, v927);
                                            let v929 = Some(v928);
                                            // Rule at src\isa\s390x\lower.isle line 1123.
                                            return v929;
                                        }
                                    }
                                }
                                let v85 = C::def_inst(ctx, v55.1);
                                if let Some(v86) = v85 {
                                    let v87 = &C::inst_data_value(ctx, v86);
                                    if let &InstructionData::Unary {
                                        opcode: ref v88,
                                        arg: v89,
                                    } = v87 {
                                        if let &Opcode::Bnot = v88 {
                                            let v80 = C::put_in_reg(ctx, v55.0);
                                            let v91 = C::put_in_reg(ctx, v89);
                                            let v924 = constructor_not_xor_reg(ctx, v79, v80, v91);
                                            let v925 = constructor_output_reg(ctx, v924);
                                            let v926 = Some(v925);
                                            // Rule at src\isa\s390x\lower.isle line 1121.
                                            return v926;
                                        }
                                    }
                                }
                            }
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v880 = C::uimm32shifted_from_value(ctx, v55.0);
                            if let Some(v881) = v880 {
                                let v58 = C::put_in_reg(ctx, v55.1);
                                let v912 = constructor_xor_uimm32shifted(ctx, v79, v58, v881);
                                let v913 = constructor_output_reg(ctx, v912);
                                let v914 = Some(v913);
                                // Rule at src\isa\s390x\lower.isle line 1103.
                                return v914;
                            }
                            let v875 = C::uimm32shifted_from_value(ctx, v55.1);
                            if let Some(v876) = v875 {
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v909 = constructor_xor_uimm32shifted(ctx, v79, v80, v876);
                                let v910 = constructor_output_reg(ctx, v909);
                                let v911 = Some(v910);
                                // Rule at src\isa\s390x\lower.isle line 1101.
                                return v911;
                            }
                            let v141 = C::value_type(ctx, v55.0);
                            let v142 = C::ty_32_or_64(ctx, v141);
                            if let Some(v143) = v142 {
                                let v144 = C::sinkable_inst(ctx, v55.0);
                                if let Some(v145) = v144 {
                                    let v146 = &C::inst_data_value(ctx, v145);
                                    if let &InstructionData::Load {
                                        opcode: ref v147,
                                        arg: v148,
                                        flags: v149,
                                        offset: v150,
                                    } = v146 {
                                        if let &Opcode::Load = v147 {
                                            let v151 = C::bigendian(ctx, v149);
                                            if let Some(v152) = v151 {
                                                let v58 = C::put_in_reg(ctx, v55.1);
                                                let v153 = &constructor_sink_load(ctx, v145);
                                                let v918 = constructor_xor_mem(ctx, v79, v58, v153);
                                                let v919 = constructor_output_reg(ctx, v918);
                                                let v920 = Some(v919);
                                                // Rule at src\isa\s390x\lower.isle line 1109.
                                                return v920;
                                            }
                                        }
                                    }
                                }
                            }
                            let v125 = C::value_type(ctx, v55.1);
                            let v126 = C::ty_32_or_64(ctx, v125);
                            if let Some(v127) = v126 {
                                let v128 = C::sinkable_inst(ctx, v55.1);
                                if let Some(v129) = v128 {
                                    let v130 = &C::inst_data_value(ctx, v129);
                                    if let &InstructionData::Load {
                                        opcode: ref v131,
                                        arg: v132,
                                        flags: v133,
                                        offset: v134,
                                    } = v130 {
                                        if let &Opcode::Load = v131 {
                                            let v135 = C::bigendian(ctx, v133);
                                            if let Some(v136) = v135 {
                                                let v80 = C::put_in_reg(ctx, v55.0);
                                                let v137 = &constructor_sink_load(ctx, v129);
                                                let v915 = constructor_xor_mem(ctx, v79, v80, v137);
                                                let v916 = constructor_output_reg(ctx, v915);
                                                let v917 = Some(v916);
                                                // Rule at src\isa\s390x\lower.isle line 1107.
                                                return v917;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v921 = constructor_vec_xor(ctx, v52, v80, v81);
                            let v922 = constructor_output_reg(ctx, v921);
                            let v923 = Some(v922);
                            // Rule at src\isa\s390x\lower.isle line 1113.
                            return v923;
                        }
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v81 = C::put_in_reg(ctx, v55.1);
                            let v906 = constructor_xor_reg(ctx, v79, v80, v81);
                            let v907 = constructor_output_reg(ctx, v906);
                            let v908 = Some(v907);
                            // Rule at src\isa\s390x\lower.isle line 1097.
                            return v908;
                        }
                    }
                }
                &Opcode::Rotl => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v677 = constructor_amt_vr(ctx, v55.1);
                            let v678 = constructor_vec_neg(ctx, I8X16, v677);
                            let v679 = constructor_vec_lshl_by_byte(ctx, v80, v677);
                            let v680 = constructor_vec_lshl_by_bit(ctx, v679, v677);
                            let v681 = constructor_vec_lshr_by_byte(ctx, v80, v678);
                            let v682 = constructor_vec_lshr_by_bit(ctx, v681, v678);
                            let v683 = constructor_vec_or(ctx, I128, v680, v682);
                            let v684 = constructor_output_reg(ctx, v683);
                            let v685 = Some(v684);
                            // Rule at src\isa\s390x\lower.isle line 824.
                            return v685;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v600 = C::mask_amt_imm(ctx, v183, v591);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v674 = constructor_vec_rot_imm(ctx, v183, v59, v600);
                                let v675 = constructor_output_reg(ctx, v674);
                                let v676 = Some(v675);
                                // Rule at src\isa\s390x\lower.isle line 818.
                                return v676;
                            }
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v596 = constructor_amt_reg(ctx, v55.1);
                            let v671 = constructor_vec_rot_reg(ctx, v183, v80, v596);
                            let v672 = constructor_output_reg(ctx, v671);
                            let v673 = Some(v672);
                            // Rule at src\isa\s390x\lower.isle line 814.
                            return v673;
                        }
                        let v469 = C::ty_8_or_16(ctx, v3);
                        if let Some(v470) = v469 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v662 = C::i64_from_negated_value(ctx, v55.1);
                                if let Some(v663) = v662 {
                                    let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                                    let v652 = constructor_ty_ext32(ctx, v470);
                                    let v664 = C::mask_amt_imm(ctx, v470, v591);
                                    let v665 = C::mask_amt_imm(ctx, v470, v663);
                                    let v666 = constructor_lshl_imm(ctx, v652, v343, v664);
                                    let v667 = constructor_lshr_imm(ctx, v652, v343, v665);
                                    let v668 = constructor_or_reg(ctx, v470, v666, v667);
                                    let v669 = constructor_output_reg(ctx, v668);
                                    let v670 = Some(v669);
                                    // Rule at src\isa\s390x\lower.isle line 804.
                                    return v670;
                                }
                            }
                            let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v652 = constructor_ty_ext32(ctx, v470);
                            let v653 = constructor_amt_reg(ctx, v55.1);
                            let v654 = constructor_neg_reg(ctx, I32, v653);
                            let v655 = constructor_mask_amt_reg(ctx, v470, v653);
                            let v656 = constructor_mask_amt_reg(ctx, v470, v654);
                            let v657 = constructor_lshl_reg(ctx, v652, v343, v655);
                            let v658 = constructor_lshr_reg(ctx, v652, v343, v656);
                            let v659 = constructor_or_reg(ctx, v470, v657, v658);
                            let v660 = constructor_output_reg(ctx, v659);
                            let v661 = Some(v660);
                            // Rule at src\isa\s390x\lower.isle line 792.
                            return v661;
                        }
                        let v643 = C::ty_32_or_64(ctx, v3);
                        if let Some(v644) = v643 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v648 = C::mask_amt_imm(ctx, v644, v591);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v649 = constructor_rot_imm(ctx, v644, v59, v648);
                                let v650 = constructor_output_reg(ctx, v649);
                                let v651 = Some(v650);
                                // Rule at src\isa\s390x\lower.isle line 786.
                                return v651;
                            }
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v596 = constructor_amt_reg(ctx, v55.1);
                            let v645 = constructor_rot_reg(ctx, v644, v80, v596);
                            let v646 = constructor_output_reg(ctx, v645);
                            let v647 = Some(v646);
                            // Rule at src\isa\s390x\lower.isle line 782.
                            return v647;
                        }
                    }
                }
                &Opcode::Rotr => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v677 = constructor_amt_vr(ctx, v55.1);
                            let v678 = constructor_vec_neg(ctx, I8X16, v677);
                            let v711 = constructor_vec_lshl_by_byte(ctx, v80, v678);
                            let v712 = constructor_vec_lshl_by_bit(ctx, v711, v678);
                            let v713 = constructor_vec_lshr_by_byte(ctx, v80, v677);
                            let v714 = constructor_vec_lshr_by_bit(ctx, v713, v677);
                            let v715 = constructor_vec_or(ctx, I128, v712, v714);
                            let v716 = constructor_output_reg(ctx, v715);
                            let v717 = Some(v716);
                            // Rule at src\isa\s390x\lower.isle line 884.
                            return v717;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v662 = C::i64_from_negated_value(ctx, v55.1);
                            if let Some(v663) = v662 {
                                let v707 = C::mask_amt_imm(ctx, v183, v663);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v708 = constructor_vec_rot_imm(ctx, v183, v59, v707);
                                let v709 = constructor_output_reg(ctx, v708);
                                let v710 = Some(v709);
                                // Rule at src\isa\s390x\lower.isle line 878.
                                return v710;
                            }
                            let v585 = constructor_amt_reg(ctx, v55.1);
                            let v686 = constructor_neg_reg(ctx, I32, v585);
                            let v192 = C::put_in_reg(ctx, v55.0);
                            let v704 = constructor_vec_rot_reg(ctx, v183, v192, v686);
                            let v705 = constructor_output_reg(ctx, v704);
                            let v706 = Some(v705);
                            // Rule at src\isa\s390x\lower.isle line 872.
                            return v706;
                        }
                        let v469 = C::ty_8_or_16(ctx, v3);
                        if let Some(v470) = v469 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v662 = C::i64_from_negated_value(ctx, v55.1);
                                if let Some(v663) = v662 {
                                    let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                                    let v652 = constructor_ty_ext32(ctx, v470);
                                    let v664 = C::mask_amt_imm(ctx, v470, v591);
                                    let v665 = C::mask_amt_imm(ctx, v470, v663);
                                    let v699 = constructor_lshl_imm(ctx, v652, v343, v665);
                                    let v700 = constructor_lshr_imm(ctx, v652, v343, v664);
                                    let v701 = constructor_or_reg(ctx, v470, v699, v700);
                                    let v702 = constructor_output_reg(ctx, v701);
                                    let v703 = Some(v702);
                                    // Rule at src\isa\s390x\lower.isle line 861.
                                    return v703;
                                }
                            }
                            let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v652 = constructor_ty_ext32(ctx, v470);
                            let v653 = constructor_amt_reg(ctx, v55.1);
                            let v654 = constructor_neg_reg(ctx, I32, v653);
                            let v655 = constructor_mask_amt_reg(ctx, v470, v653);
                            let v656 = constructor_mask_amt_reg(ctx, v470, v654);
                            let v694 = constructor_lshl_reg(ctx, v652, v343, v656);
                            let v695 = constructor_lshr_reg(ctx, v652, v343, v655);
                            let v696 = constructor_or_reg(ctx, v470, v694, v695);
                            let v697 = constructor_output_reg(ctx, v696);
                            let v698 = Some(v697);
                            // Rule at src\isa\s390x\lower.isle line 849.
                            return v698;
                        }
                        let v643 = C::ty_32_or_64(ctx, v3);
                        if let Some(v644) = v643 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v662 = C::i64_from_negated_value(ctx, v55.1);
                            if let Some(v663) = v662 {
                                let v690 = C::mask_amt_imm(ctx, v644, v663);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v691 = constructor_rot_imm(ctx, v644, v59, v690);
                                let v692 = constructor_output_reg(ctx, v691);
                                let v693 = Some(v692);
                                // Rule at src\isa\s390x\lower.isle line 843.
                                return v693;
                            }
                            let v585 = constructor_amt_reg(ctx, v55.1);
                            let v686 = constructor_neg_reg(ctx, I32, v585);
                            let v192 = C::put_in_reg(ctx, v55.0);
                            let v687 = constructor_rot_reg(ctx, v644, v192, v686);
                            let v688 = constructor_output_reg(ctx, v687);
                            let v689 = Some(v688);
                            // Rule at src\isa\s390x\lower.isle line 837.
                            return v689;
                        }
                    }
                }
                &Opcode::Ishl => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v604 = constructor_amt_vr(ctx, v55.1);
                            let v59 = C::put_in_reg(ctx, v55.0);
                            let v605 = constructor_vec_lshl_by_byte(ctx, v59, v604);
                            let v606 = constructor_vec_lshl_by_bit(ctx, v605, v604);
                            let v607 = constructor_output_reg(ctx, v606);
                            let v608 = Some(v607);
                            // Rule at src\isa\s390x\lower.isle line 712.
                            return v608;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v600 = C::mask_amt_imm(ctx, v183, v591);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v601 = constructor_vec_lshl_imm(ctx, v183, v59, v600);
                                let v602 = constructor_output_reg(ctx, v601);
                                let v603 = Some(v602);
                                // Rule at src\isa\s390x\lower.isle line 707.
                                return v603;
                            }
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v596 = constructor_amt_reg(ctx, v55.1);
                            let v597 = constructor_vec_lshl_reg(ctx, v183, v80, v596);
                            let v598 = constructor_output_reg(ctx, v597);
                            let v599 = Some(v598);
                            // Rule at src\isa\s390x\lower.isle line 703.
                            return v599;
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v592 = C::mask_amt_imm(ctx, v79, v591);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v593 = constructor_lshl_imm(ctx, v79, v59, v592);
                                let v594 = constructor_output_reg(ctx, v593);
                                let v595 = Some(v594);
                                // Rule at src\isa\s390x\lower.isle line 698.
                                return v595;
                            }
                            let v585 = constructor_amt_reg(ctx, v55.1);
                            let v586 = constructor_mask_amt_reg(ctx, v79, v585);
                            let v192 = C::put_in_reg(ctx, v55.0);
                            let v587 = constructor_lshl_reg(ctx, v79, v192, v586);
                            let v588 = constructor_output_reg(ctx, v587);
                            let v589 = Some(v588);
                            // Rule at src\isa\s390x\lower.isle line 693.
                            return v589;
                        }
                    }
                }
                &Opcode::Ushr => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v604 = constructor_amt_vr(ctx, v55.1);
                            let v59 = C::put_in_reg(ctx, v55.0);
                            let v623 = constructor_vec_lshr_by_byte(ctx, v59, v604);
                            let v624 = constructor_vec_lshr_by_bit(ctx, v623, v604);
                            let v625 = constructor_output_reg(ctx, v624);
                            let v626 = Some(v625);
                            // Rule at src\isa\s390x\lower.isle line 743.
                            return v626;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v600 = C::mask_amt_imm(ctx, v183, v591);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v620 = constructor_vec_lshr_imm(ctx, v183, v59, v600);
                                let v621 = constructor_output_reg(ctx, v620);
                                let v622 = Some(v621);
                                // Rule at src\isa\s390x\lower.isle line 738.
                                return v622;
                            }
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v596 = constructor_amt_reg(ctx, v55.1);
                            let v617 = constructor_vec_lshr_reg(ctx, v183, v80, v596);
                            let v618 = constructor_output_reg(ctx, v617);
                            let v619 = Some(v618);
                            // Rule at src\isa\s390x\lower.isle line 734.
                            return v619;
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                                let v613 = C::mask_amt_imm(ctx, v79, v591);
                                let v345 = constructor_ty_ext32(ctx, v79);
                                let v614 = constructor_lshr_imm(ctx, v345, v343, v613);
                                let v615 = constructor_output_reg(ctx, v614);
                                let v616 = Some(v615);
                                // Rule at src\isa\s390x\lower.isle line 728.
                                return v616;
                            }
                            let v343 = constructor_put_in_reg_zext32(ctx, v55.0);
                            let v596 = constructor_amt_reg(ctx, v55.1);
                            let v609 = constructor_mask_amt_reg(ctx, v79, v596);
                            let v574 = constructor_ty_ext32(ctx, v79);
                            let v610 = constructor_lshr_reg(ctx, v574, v343, v609);
                            let v611 = constructor_output_reg(ctx, v610);
                            let v612 = Some(v611);
                            // Rule at src\isa\s390x\lower.isle line 721.
                            return v612;
                        }
                    }
                }
                &Opcode::Sshr => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I128 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v604 = constructor_amt_vr(ctx, v55.1);
                            let v59 = C::put_in_reg(ctx, v55.0);
                            let v639 = constructor_vec_ashr_by_byte(ctx, v59, v604);
                            let v640 = constructor_vec_ashr_by_bit(ctx, v639, v604);
                            let v641 = constructor_output_reg(ctx, v640);
                            let v642 = Some(v641);
                            // Rule at src\isa\s390x\lower.isle line 774.
                            return v642;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v600 = C::mask_amt_imm(ctx, v183, v591);
                                let v59 = C::put_in_reg(ctx, v55.0);
                                let v636 = constructor_vec_ashr_imm(ctx, v183, v59, v600);
                                let v637 = constructor_output_reg(ctx, v636);
                                let v638 = Some(v637);
                                // Rule at src\isa\s390x\lower.isle line 769.
                                return v638;
                            }
                            let v80 = C::put_in_reg(ctx, v55.0);
                            let v596 = constructor_amt_reg(ctx, v55.1);
                            let v633 = constructor_vec_ashr_reg(ctx, v183, v80, v596);
                            let v634 = constructor_output_reg(ctx, v633);
                            let v635 = Some(v634);
                            // Rule at src\isa\s390x\lower.isle line 765.
                            return v635;
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v590 = C::i64_from_value(ctx, v55.1);
                            if let Some(v591) = v590 {
                                let v373 = constructor_put_in_reg_sext32(ctx, v55.0);
                                let v613 = C::mask_amt_imm(ctx, v79, v591);
                                let v345 = constructor_ty_ext32(ctx, v79);
                                let v630 = constructor_ashr_imm(ctx, v345, v373, v613);
                                let v631 = constructor_output_reg(ctx, v630);
                                let v632 = Some(v631);
                                // Rule at src\isa\s390x\lower.isle line 759.
                                return v632;
                            }
                            let v373 = constructor_put_in_reg_sext32(ctx, v55.0);
                            let v596 = constructor_amt_reg(ctx, v55.1);
                            let v609 = constructor_mask_amt_reg(ctx, v79, v596);
                            let v574 = constructor_ty_ext32(ctx, v79);
                            let v627 = constructor_ashr_reg(ctx, v574, v373, v609);
                            let v628 = constructor_output_reg(ctx, v627);
                            let v629 = Some(v628);
                            // Rule at src\isa\s390x\lower.isle line 752.
                            return v629;
                        }
                    }
                }
                &Opcode::Fadd => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v3 = C::value_type(ctx, v2);
                        let v1109 = constructor_fadd_reg(ctx, v3, v80, v81);
                        let v1110 = constructor_output_reg(ctx, v1109);
                        let v1111 = Some(v1110);
                        // Rule at src\isa\s390x\lower.isle line 1376.
                        return v1111;
                    }
                }
                &Opcode::Fsub => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v3 = C::value_type(ctx, v2);
                        let v1112 = constructor_fsub_reg(ctx, v3, v80, v81);
                        let v1113 = constructor_output_reg(ctx, v1112);
                        let v1114 = Some(v1113);
                        // Rule at src\isa\s390x\lower.isle line 1383.
                        return v1114;
                    }
                }
                &Opcode::Fmul => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v3 = C::value_type(ctx, v2);
                        let v1115 = constructor_fmul_reg(ctx, v3, v80, v81);
                        let v1116 = constructor_output_reg(ctx, v1115);
                        let v1117 = Some(v1116);
                        // Rule at src\isa\s390x\lower.isle line 1390.
                        return v1117;
                    }
                }
                &Opcode::Fdiv => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v3 = C::value_type(ctx, v2);
                        let v1118 = constructor_fdiv_reg(ctx, v3, v80, v81);
                        let v1119 = constructor_output_reg(ctx, v1118);
                        let v1120 = Some(v1119);
                        // Rule at src\isa\s390x\lower.isle line 1397.
                        return v1120;
                    }
                }
                &Opcode::Fcopysign => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            F32 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v1128 = constructor_imm(ctx, F32, 0x7fffffff_u64);
                                let v1129 = constructor_vec_select(ctx, F32, v80, v81, v1128);
                                let v1130 = constructor_output_reg(ctx, v1129);
                                let v1131 = Some(v1130);
                                // Rule at src\isa\s390x\lower.isle line 1418.
                                return v1131;
                            }
                            F64 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v1133 = constructor_imm(ctx, F64, 0x7fffffffffffffff_u64);
                                let v1134 = constructor_vec_select(ctx, F64, v80, v81, v1133);
                                let v1135 = constructor_output_reg(ctx, v1134);
                                let v1136 = Some(v1135);
                                // Rule at src\isa\s390x\lower.isle line 1420.
                                return v1136;
                            }
                            F128 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v1139 = constructor_imm8x16(ctx, 0x7f_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8, 0xff_u8);
                                let v1140 = constructor_vec_imm(ctx, F128, v1139);
                                let v1141 = constructor_vec_select(ctx, F128, v80, v81, v1140);
                                let v1142 = constructor_output_reg(ctx, v1141);
                                let v1143 = Some(v1142);
                                // Rule at src\isa\s390x\lower.isle line 1422.
                                return v1143;
                            }
                            F32X4 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v1146 = constructor_vec_imm_bit_mask(ctx, F32X4, 0x1_u8, 0x1f_u8);
                                let v1147 = constructor_vec_select(ctx, F32X4, v80, v81, v1146);
                                let v1148 = constructor_output_reg(ctx, v1147);
                                let v1149 = Some(v1148);
                                // Rule at src\isa\s390x\lower.isle line 1425.
                                return v1149;
                            }
                            F64X2 => {
                                let v55 = C::unpack_value_array_2(ctx, v54);
                                let v80 = C::put_in_reg(ctx, v55.0);
                                let v81 = C::put_in_reg(ctx, v55.1);
                                let v1151 = constructor_vec_imm_bit_mask(ctx, F64X2, 0x1_u8, 0x3f_u8);
                                let v1152 = constructor_vec_select(ctx, F64X2, v80, v81, v1151);
                                let v1153 = constructor_output_reg(ctx, v1152);
                                let v1154 = Some(v1153);
                                // Rule at src\isa\s390x\lower.isle line 1427.
                                return v1154;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fmin => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v3 = C::value_type(ctx, v2);
                        let v1121 = constructor_fmin_reg(ctx, v3, v80, v81);
                        let v1122 = constructor_output_reg(ctx, v1121);
                        let v1123 = Some(v1122);
                        // Rule at src\isa\s390x\lower.isle line 1404.
                        return v1123;
                    }
                }
                &Opcode::Fmax => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v3 = C::value_type(ctx, v2);
                        let v1124 = constructor_fmax_reg(ctx, v3, v80, v81);
                        let v1125 = constructor_output_reg(ctx, v1124);
                        let v1126 = Some(v1125);
                        // Rule at src\isa\s390x\lower.isle line 1411.
                        return v1126;
                    }
                }
                &Opcode::Snarrow => {
                    let v55 = C::unpack_value_array_2(ctx, v54);
                    let v141 = C::value_type(ctx, v55.0);
                    let v764 = C::ty_vec128(ctx, v141);
                    if let Some(v765) = v764 {
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v766 = constructor_vec_pack_ssat_lane_order(ctx, v765, v80, v81);
                        let v767 = constructor_output_reg(ctx, v766);
                        let v768 = Some(v767);
                        // Rule at src\isa\s390x\lower.isle line 943.
                        return v768;
                    }
                }
                &Opcode::Unarrow => {
                    let v55 = C::unpack_value_array_2(ctx, v54);
                    let v141 = C::value_type(ctx, v55.0);
                    let v764 = C::ty_vec128(ctx, v141);
                    if let Some(v765) = v764 {
                        let v772 = constructor_vec_imm(ctx, v765, 0x0_u128);
                        let v59 = C::put_in_reg(ctx, v55.0);
                        let v773 = constructor_vec_smax(ctx, v765, v59, v772);
                        let v501 = C::put_in_reg(ctx, v55.1);
                        let v774 = constructor_vec_smax(ctx, v765, v501, v772);
                        let v775 = constructor_vec_pack_usat_lane_order(ctx, v765, v773, v774);
                        let v776 = constructor_output_reg(ctx, v775);
                        let v777 = Some(v776);
                        // Rule at src\isa\s390x\lower.isle line 955.
                        return v777;
                    }
                }
                &Opcode::Uunarrow => {
                    let v55 = C::unpack_value_array_2(ctx, v54);
                    let v141 = C::value_type(ctx, v55.0);
                    let v764 = C::ty_vec128(ctx, v141);
                    if let Some(v765) = v764 {
                        let v80 = C::put_in_reg(ctx, v55.0);
                        let v81 = C::put_in_reg(ctx, v55.1);
                        let v769 = constructor_vec_pack_usat_lane_order(ctx, v765, v80, v81);
                        let v770 = constructor_output_reg(ctx, v769);
                        let v771 = Some(v770);
                        // Rule at src\isa\s390x\lower.isle line 949.
                        return v771;
                    }
                }
                &Opcode::IaddPairwise => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v55 = C::unpack_value_array_2(ctx, v54);
                        let v85 = C::def_inst(ctx, v55.1);
                        if let Some(v86) = v85 {
                            let v87 = &C::inst_data_value(ctx, v86);
                            if let &InstructionData::Binary {
                                opcode: ref v239,
                                args: ref v240,
                            } = v87 {
                                if let &Opcode::Imul = v239 {
                                    let v95 = C::def_inst(ctx, v55.0);
                                    if let Some(v96) = v95 {
                                        let v97 = &C::inst_data_value(ctx, v96);
                                        if let &InstructionData::Binary {
                                            opcode: ref v223,
                                            args: ref v224,
                                        } = v97 {
                                            if let &Opcode::Imul = v223 {
                                                let v225 = C::unpack_value_array_2(ctx, v224);
                                                let v228 = C::def_inst(ctx, v225.0);
                                                if let Some(v229) = v228 {
                                                    let v230 = &C::inst_data_value(ctx, v229);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v231,
                                                        arg: v232,
                                                    } = v230 {
                                                        if let &Opcode::SwidenLow = v231 {
                                                            let v234 = C::def_inst(ctx, v225.1);
                                                            if let Some(v235) = v234 {
                                                                let v236 = &C::inst_data_value(ctx, v235);
                                                                if let &InstructionData::Unary {
                                                                    opcode: ref v237,
                                                                    arg: v238,
                                                                } = v236 {
                                                                    if let &Opcode::SwidenLow = v237 {
                                                                        let v241 = C::unpack_value_array_2(ctx, v240);
                                                                        let v244 = C::def_inst(ctx, v241.0);
                                                                        if let Some(v245) = v244 {
                                                                            let v246 = &C::inst_data_value(ctx, v245);
                                                                            if let &InstructionData::Unary {
                                                                                opcode: ref v247,
                                                                                arg: v248,
                                                                            } = v246 {
                                                                                if let &Opcode::SwidenHigh = v247 {
                                                                                    if v232 == v248 {
                                                                                        let v249 = C::def_inst(ctx, v241.1);
                                                                                        if let Some(v250) = v249 {
                                                                                            let v251 = &C::inst_data_value(ctx, v250);
                                                                                            if let &InstructionData::Unary {
                                                                                                opcode: ref v252,
                                                                                                arg: v253,
                                                                                            } = v251 {
                                                                                                if let &Opcode::SwidenHigh = v252 {
                                                                                                    if v238 == v253 {
                                                                                                        let v254 = C::put_in_reg(ctx, v232);
                                                                                                        let v255 = C::put_in_reg(ctx, v238);
                                                                                                        let v233 = C::value_type(ctx, v232);
                                                                                                        let v256 = constructor_vec_smul_even(ctx, v233, v254, v255);
                                                                                                        let v257 = C::put_in_reg(ctx, v232);
                                                                                                        let v258 = C::put_in_reg(ctx, v238);
                                                                                                        let v259 = constructor_vec_smul_odd(ctx, v233, v257, v258);
                                                                                                        let v3 = C::value_type(ctx, v2);
                                                                                                        let v260 = constructor_vec_add(ctx, v3, v256, v259);
                                                                                                        let v261 = constructor_output_reg(ctx, v260);
                                                                                                        let v262 = Some(v261);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 147.
                                                                                                        return v262;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        let v3 = C::value_type(ctx, v2);
                        let v206 = C::multi_lane(ctx, v3);
                        if let Some(v207) = v206 {
                            let v211 = C::u32_into_u64(ctx, v207.0);
                            let v212 = constructor_vec_imm_splat(ctx, I8X16, v211);
                            let v213 = constructor_vec_widen_type(ctx, v3);
                            let v192 = C::put_in_reg(ctx, v55.0);
                            let v185 = C::put_in_reg(ctx, v55.0);
                            let v214 = constructor_vec_lshr_by_byte(ctx, v185, v212);
                            let v215 = constructor_vec_add(ctx, v3, v192, v214);
                            let v216 = C::put_in_reg(ctx, v55.1);
                            let v217 = C::put_in_reg(ctx, v55.1);
                            let v218 = constructor_vec_lshr_by_byte(ctx, v217, v212);
                            let v219 = constructor_vec_add(ctx, v3, v216, v218);
                            let v220 = constructor_vec_pack_lane_order(ctx, v213, v215, v219);
                            let v221 = constructor_output_reg(ctx, v220);
                            let v222 = Some(v221);
                            // Rule at src\isa\s390x\lower.isle line 140.
                            return v222;
                        }
                    }
                }
                &Opcode::Iconcat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v55 = C::unpack_value_array_2(ctx, v54);
                            let v58 = C::put_in_reg(ctx, v55.1);
                            let v59 = C::put_in_reg(ctx, v55.0);
                            let v60 = constructor_mov_to_vec128(ctx, v52, v58, v59);
                            let v61 = constructor_output_reg(ctx, v60);
                            let v62 = Some(v61);
                            // Rule at src\isa\s390x\lower.isle line 56.
                            return v62;
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::BinaryImm8 {
            opcode: ref v1480,
            arg: v1481,
            imm: v1482,
        } => {
            if let &Opcode::Extractlane = v1480 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    let v3 = C::value_type(ctx, v2);
                    let v1485 = C::ty_int_ref_scalar_64(ctx, v3);
                    if let Some(v1486) = v1485 {
                        let v1487 = C::put_in_reg(ctx, v1481);
                        let v1483 = C::value_type(ctx, v1481);
                        let v1484 = C::u8_from_uimm8(ctx, v1482);
                        let v1488 = C::be_lane_idx(ctx, v1483, v1484);
                        let v738 = C::zero_reg(ctx);
                        let v1489 = constructor_vec_extract_lane(ctx, v1483, v1487, v1488, v738);
                        let v1490 = constructor_output_reg(ctx, v1489);
                        let v1491 = Some(v1490);
                        // Rule at src\isa\s390x\lower.isle line 1942.
                        return v1491;
                    }
                    let v1406 = C::ty_scalar_float(ctx, v3);
                    if let Some(v1407) = v1406 {
                        let v1487 = C::put_in_reg(ctx, v1481);
                        let v1483 = C::value_type(ctx, v1481);
                        let v1484 = C::u8_from_uimm8(ctx, v1482);
                        let v1488 = C::be_lane_idx(ctx, v1483, v1484);
                        let v1492 = constructor_vec_replicate_lane(ctx, v1483, v1487, v1488);
                        let v1493 = constructor_output_reg(ctx, v1492);
                        let v1494 = Some(v1493);
                        // Rule at src\isa\s390x\lower.isle line 1948.
                        return v1494;
                    }
                }
            }
        }
        &InstructionData::Call {
            opcode: ref v2576,
            args: v2577,
            func_ref: v2578,
        } => {
            match v2576 {
                &Opcode::Call => {
                    let v2580 = C::func_ref_data(ctx, v2578);
                    if let &RelocDistance::Near = &v2580.2 {
                        let v2584 = &C::gen_call_output(ctx, v2580.0);
                        let v2585 = C::abi_sig(ctx, v2580.0);
                        let v2586 = C::abi_emit_call_adjust_stack(ctx, v2585);
                        let v2579 = C::value_list_slice(ctx, v2577);
                        let v2587 = &C::abi_prepare_args(ctx, v2585, v2579);
                        let v2588 = C::gen_call_args(ctx, v2585, v2587);
                        let v2589 = C::gen_call_rets(ctx, v2585, v2584);
                        let v2590 = C::call_inst_dest_direct(ctx, v2580.1);
                        let v2591 = C::try_call_none(ctx);
                        let v2592 = C::gen_call_info(ctx, v2585, v2590, v2588, v2589, v2591);
                        let v2593 = constructor_writable_link_reg(ctx);
                        let v2594 = &constructor_call_impl(ctx, v2593, v2592);
                        let v2595 = constructor_emit_side_effect(ctx, v2594);
                        let v2596 = C::output_vec(ctx, v2584);
                        let v2597 = Some(v2596);
                        // Rule at src\isa\s390x\lower.isle line 3968.
                        return v2597;
                    }
                    let v2584 = &C::gen_call_output(ctx, v2580.0);
                    let v2585 = C::abi_sig(ctx, v2580.0);
                    let v2586 = C::abi_emit_call_adjust_stack(ctx, v2585);
                    let v2579 = C::value_list_slice(ctx, v2577);
                    let v2587 = &C::abi_prepare_args(ctx, v2585, v2579);
                    let v2588 = C::gen_call_args(ctx, v2585, v2587);
                    let v2589 = C::gen_call_rets(ctx, v2585, v2584);
                    let v2598 = SymbolReloc::Absolute {
                        name: v2580.1,
                        offset: 0_i64,
                    };
                    let v2599 = constructor_load_symbol_reloc(ctx, &v2598);
                    let v2600 = C::call_inst_dest_indirect(ctx, v2599);
                    let v2601 = C::try_call_none(ctx);
                    let v2602 = C::gen_call_info(ctx, v2585, v2600, v2588, v2589, v2601);
                    let v2603 = constructor_writable_link_reg(ctx);
                    let v2604 = &constructor_call_impl(ctx, v2603, v2602);
                    let v2605 = constructor_emit_side_effect(ctx, v2604);
                    let v2606 = C::output_vec(ctx, v2584);
                    let v2607 = Some(v2606);
                    // Rule at src\isa\s390x\lower.isle line 3979.
                    return v2607;
                }
                &Opcode::ReturnCall => {
                    let v2580 = C::func_ref_data(ctx, v2578);
                    if let &RelocDistance::Near = &v2580.2 {
                        let v2629 = C::abi_sig(ctx, v2580.0);
                        let v2642 = C::abi_emit_return_call_adjust_stack(ctx, v2629);
                        let v2579 = C::value_list_slice(ctx, v2577);
                        let v2631 = &C::abi_prepare_args(ctx, v2629, v2579);
                        let v2643 = C::gen_return_call_args(ctx, v2629, v2631);
                        let v2644 = C::call_inst_dest_direct(ctx, v2580.1);
                        let v2645 = C::gen_return_call_info(ctx, v2629, v2644, v2643);
                        let v2646 = &constructor_return_call_impl(ctx, v2645);
                        let v2647 = constructor_side_effect(ctx, v2646);
                        let v2648 = Some(v2647);
                        // Rule at src\isa\s390x\lower.isle line 4015.
                        return v2648;
                    }
                    let v2629 = C::abi_sig(ctx, v2580.0);
                    let v2642 = C::abi_emit_return_call_adjust_stack(ctx, v2629);
                    let v2579 = C::value_list_slice(ctx, v2577);
                    let v2631 = &C::abi_prepare_args(ctx, v2629, v2579);
                    let v2643 = C::gen_return_call_args(ctx, v2629, v2631);
                    let v2598 = SymbolReloc::Absolute {
                        name: v2580.1,
                        offset: 0_i64,
                    };
                    let v2649 = constructor_load_symbol_reloc(ctx, &v2598);
                    let v2650 = C::call_inst_dest_indirect(ctx, v2649);
                    let v2651 = C::gen_return_call_info(ctx, v2629, v2650, v2643);
                    let v2652 = &constructor_return_call_impl(ctx, v2651);
                    let v2653 = constructor_side_effect(ctx, v2652);
                    let v2654 = Some(v2653);
                    // Rule at src\isa\s390x\lower.isle line 4023.
                    return v2654;
                }
                &Opcode::PatchableCall => {
                    let v2580 = C::func_ref_data(ctx, v2578);
                    if let &RelocDistance::Near = &v2580.2 {
                        let v2629 = C::abi_sig(ctx, v2580.0);
                        let v2630 = C::abi_emit_call_adjust_stack(ctx, v2629);
                        let v2579 = C::value_list_slice(ctx, v2577);
                        let v2631 = &C::abi_prepare_args(ctx, v2629, v2579);
                        let v2632 = C::gen_call_args(ctx, v2629, v2631);
                        let v2633 = C::gen_patchable_call_rets(ctx);
                        let v2634 = C::call_inst_dest_direct(ctx, v2580.1);
                        let v2635 = C::try_call_none(ctx);
                        let v2636 = C::gen_call_info(ctx, v2629, v2634, v2632, v2633, v2635);
                        let v2637 = constructor_writable_link_reg(ctx);
                        let v2638 = &constructor_patchable_call_impl(ctx, v2637, v2636);
                        let v2639 = constructor_emit_side_effect(ctx, v2638);
                        let v2640 = C::output_none(ctx);
                        let v2641 = Some(v2640);
                        // Rule at src\isa\s390x\lower.isle line 4003.
                        return v2641;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::CallIndirect {
            opcode: ref v2608,
            args: v2609,
            sig_ref: v2610,
        } => {
            match v2608 {
                &Opcode::CallIndirect => {
                    let v2611 = C::value_list_slice(ctx, v2609);
                    let v2612 = C::value_slice_unwrap(ctx, v2611);
                    if let Some(v2613) = v2612 {
                        let v2616 = &C::gen_call_output(ctx, v2610);
                        let v2617 = C::abi_sig(ctx, v2610);
                        let v2618 = C::put_in_reg(ctx, v2613.0);
                        let v2619 = C::abi_emit_call_adjust_stack(ctx, v2617);
                        let v2620 = &C::abi_prepare_args(ctx, v2617, v2613.1);
                        let v2621 = C::gen_call_args(ctx, v2617, v2620);
                        let v2622 = C::gen_call_rets(ctx, v2617, v2616);
                        let v2623 = C::call_inst_dest_indirect(ctx, v2618);
                        let v2601 = C::try_call_none(ctx);
                        let v2624 = C::gen_call_info(ctx, v2617, v2623, v2621, v2622, v2601);
                        let v2603 = constructor_writable_link_reg(ctx);
                        let v2625 = &constructor_call_impl(ctx, v2603, v2624);
                        let v2626 = constructor_emit_side_effect(ctx, v2625);
                        let v2627 = C::output_vec(ctx, v2616);
                        let v2628 = Some(v2627);
                        // Rule at src\isa\s390x\lower.isle line 3991.
                        return v2628;
                    }
                }
                &Opcode::ReturnCallIndirect => {
                    let v2611 = C::value_list_slice(ctx, v2609);
                    let v2612 = C::value_slice_unwrap(ctx, v2611);
                    if let Some(v2613) = v2612 {
                        let v2655 = C::abi_sig(ctx, v2610);
                        let v2656 = C::put_in_reg(ctx, v2613.0);
                        let v2657 = C::abi_emit_return_call_adjust_stack(ctx, v2655);
                        let v2658 = &C::abi_prepare_args(ctx, v2655, v2613.1);
                        let v2659 = C::gen_return_call_args(ctx, v2655, v2658);
                        let v2660 = C::call_inst_dest_indirect(ctx, v2656);
                        let v2661 = C::gen_return_call_info(ctx, v2655, v2660, v2659);
                        let v2662 = &constructor_return_call_impl(ctx, v2661);
                        let v2663 = constructor_side_effect(ctx, v2662);
                        let v2664 = Some(v2663);
                        // Rule at src\isa\s390x\lower.isle line 4032.
                        return v2664;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::CondTrap {
            opcode: ref v2453,
            arg: v2454,
            code: ref v2455,
        } => {
            match v2453 {
                &Opcode::Trapz => {
                    let v2456 = &constructor_value_nonzero(ctx, v2454);
                    let v2457 = &constructor_invert_bool(ctx, v2456);
                    let v2458 = &constructor_trap_if_bool(ctx, v2457, v2455);
                    let v2459 = constructor_side_effect(ctx, v2458);
                    let v2460 = Some(v2459);
                    // Rule at src\isa\s390x\lower.isle line 3866.
                    return v2460;
                }
                &Opcode::Trapnz => {
                    let v2456 = &constructor_value_nonzero(ctx, v2454);
                    let v2461 = &constructor_trap_if_bool(ctx, v2456, v2455);
                    let v2462 = constructor_side_effect(ctx, v2461);
                    let v2463 = Some(v2462);
                    // Rule at src\isa\s390x\lower.isle line 3872.
                    return v2463;
                }
                _ => {}
            }
        }
        &InstructionData::ExceptionHandlerAddress {
            opcode: ref v2676,
            block: ref v2677,
            imm: v2678,
        } => {
            if let &Opcode::GetExceptionHandlerAddress = v2676 {
                let v2679 = C::u64_from_imm64(ctx, v2678);
                let v2680 = C::block_exn_successor_label(ctx, v2677, v2679);
                let v2681 = constructor_s390x_label_address(ctx, v2680);
                let v2682 = constructor_output_reg(ctx, v2681);
                let v2683 = Some(v2682);
                // Rule at src\isa\s390x\lower.isle line 4090.
                return v2683;
            }
        }
        &InstructionData::FloatCompare {
            opcode: ref v2291,
            args: ref v2292,
            cond: ref v2293,
        } => {
            if let &Opcode::Fcmp = v2291 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    match v2293 {
                        &FloatCC::Equal => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2303 = constructor_vec_fcmpeq(ctx, v183, v2301, v2302);
                                let v2304 = constructor_output_reg(ctx, v2303);
                                let v2305 = Some(v2304);
                                // Rule at src\isa\s390x\lower.isle line 3536.
                                return v2305;
                            }
                        }
                        &FloatCC::GreaterThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2309 = constructor_vec_fcmph(ctx, v183, v2301, v2302);
                                let v2310 = constructor_output_reg(ctx, v2309);
                                let v2311 = Some(v2310);
                                // Rule at src\isa\s390x\lower.isle line 3540.
                                return v2311;
                            }
                        }
                        &FloatCC::GreaterThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2315 = constructor_vec_fcmphe(ctx, v183, v2301, v2302);
                                let v2316 = constructor_output_reg(ctx, v2315);
                                let v2317 = Some(v2316);
                                // Rule at src\isa\s390x\lower.isle line 3544.
                                return v2317;
                            }
                        }
                        &FloatCC::LessThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2321 = C::put_in_reg(ctx, v2294.1);
                                let v2322 = C::put_in_reg(ctx, v2294.0);
                                let v2323 = constructor_vec_fcmph(ctx, v183, v2321, v2322);
                                let v2324 = constructor_output_reg(ctx, v2323);
                                let v2325 = Some(v2324);
                                // Rule at src\isa\s390x\lower.isle line 3548.
                                return v2325;
                            }
                        }
                        &FloatCC::LessThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2321 = C::put_in_reg(ctx, v2294.1);
                                let v2322 = C::put_in_reg(ctx, v2294.0);
                                let v2329 = constructor_vec_fcmphe(ctx, v183, v2321, v2322);
                                let v2330 = constructor_output_reg(ctx, v2329);
                                let v2331 = Some(v2330);
                                // Rule at src\isa\s390x\lower.isle line 3552.
                                return v2331;
                            }
                        }
                        &FloatCC::NotEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2303 = constructor_vec_fcmpeq(ctx, v183, v2301, v2302);
                                let v2306 = constructor_vec_not(ctx, v183, v2303);
                                let v2307 = constructor_output_reg(ctx, v2306);
                                let v2308 = Some(v2307);
                                // Rule at src\isa\s390x\lower.isle line 3538.
                                return v2308;
                            }
                        }
                        &FloatCC::Ordered => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2315 = constructor_vec_fcmphe(ctx, v183, v2301, v2302);
                                let v2335 = C::put_in_reg(ctx, v2294.1);
                                let v2336 = C::put_in_reg(ctx, v2294.0);
                                let v2337 = constructor_vec_fcmphe(ctx, v183, v2335, v2336);
                                let v2338 = constructor_vec_or(ctx, v183, v2315, v2337);
                                let v2339 = constructor_output_reg(ctx, v2338);
                                let v2340 = Some(v2339);
                                // Rule at src\isa\s390x\lower.isle line 3556.
                                return v2340;
                            }
                        }
                        &FloatCC::OrderedNotEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2309 = constructor_vec_fcmph(ctx, v183, v2301, v2302);
                                let v2335 = C::put_in_reg(ctx, v2294.1);
                                let v2336 = C::put_in_reg(ctx, v2294.0);
                                let v2344 = constructor_vec_fcmph(ctx, v183, v2335, v2336);
                                let v2345 = constructor_vec_or(ctx, v183, v2309, v2344);
                                let v2346 = constructor_output_reg(ctx, v2345);
                                let v2347 = Some(v2346);
                                // Rule at src\isa\s390x\lower.isle line 3560.
                                return v2347;
                            }
                        }
                        &FloatCC::Unordered => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2315 = constructor_vec_fcmphe(ctx, v183, v2301, v2302);
                                let v2335 = C::put_in_reg(ctx, v2294.1);
                                let v2336 = C::put_in_reg(ctx, v2294.0);
                                let v2337 = constructor_vec_fcmphe(ctx, v183, v2335, v2336);
                                let v2341 = constructor_vec_not_or(ctx, v183, v2315, v2337);
                                let v2342 = constructor_output_reg(ctx, v2341);
                                let v2343 = Some(v2342);
                                // Rule at src\isa\s390x\lower.isle line 3558.
                                return v2343;
                            }
                        }
                        &FloatCC::UnorderedOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2309 = constructor_vec_fcmph(ctx, v183, v2301, v2302);
                                let v2335 = C::put_in_reg(ctx, v2294.1);
                                let v2336 = C::put_in_reg(ctx, v2294.0);
                                let v2344 = constructor_vec_fcmph(ctx, v183, v2335, v2336);
                                let v2348 = constructor_vec_not_or(ctx, v183, v2309, v2344);
                                let v2349 = constructor_output_reg(ctx, v2348);
                                let v2350 = Some(v2349);
                                // Rule at src\isa\s390x\lower.isle line 3562.
                                return v2350;
                            }
                        }
                        &FloatCC::UnorderedOrGreaterThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2321 = C::put_in_reg(ctx, v2294.1);
                                let v2322 = C::put_in_reg(ctx, v2294.0);
                                let v2329 = constructor_vec_fcmphe(ctx, v183, v2321, v2322);
                                let v2332 = constructor_vec_not(ctx, v183, v2329);
                                let v2333 = constructor_output_reg(ctx, v2332);
                                let v2334 = Some(v2333);
                                // Rule at src\isa\s390x\lower.isle line 3554.
                                return v2334;
                            }
                        }
                        &FloatCC::UnorderedOrGreaterThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2321 = C::put_in_reg(ctx, v2294.1);
                                let v2322 = C::put_in_reg(ctx, v2294.0);
                                let v2323 = constructor_vec_fcmph(ctx, v183, v2321, v2322);
                                let v2326 = constructor_vec_not(ctx, v183, v2323);
                                let v2327 = constructor_output_reg(ctx, v2326);
                                let v2328 = Some(v2327);
                                // Rule at src\isa\s390x\lower.isle line 3550.
                                return v2328;
                            }
                        }
                        &FloatCC::UnorderedOrLessThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2315 = constructor_vec_fcmphe(ctx, v183, v2301, v2302);
                                let v2318 = constructor_vec_not(ctx, v183, v2315);
                                let v2319 = constructor_output_reg(ctx, v2318);
                                let v2320 = Some(v2319);
                                // Rule at src\isa\s390x\lower.isle line 3546.
                                return v2320;
                            }
                        }
                        &FloatCC::UnorderedOrLessThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2294 = C::unpack_value_array_2(ctx, v2292);
                                let v2301 = C::put_in_reg(ctx, v2294.0);
                                let v2302 = C::put_in_reg(ctx, v2294.1);
                                let v2309 = constructor_vec_fcmph(ctx, v183, v2301, v2302);
                                let v2312 = constructor_vec_not(ctx, v183, v2309);
                                let v2313 = constructor_output_reg(ctx, v2312);
                                let v2314 = Some(v2313);
                                // Rule at src\isa\s390x\lower.isle line 3542.
                                return v2314;
                            }
                        }
                        _ => {}
                    }
                    let v3 = C::value_type(ctx, v2);
                    let v78 = C::fits_in_64(ctx, v3);
                    if let Some(v79) = v78 {
                        let v2294 = C::unpack_value_array_2(ctx, v2292);
                        let v2297 = &constructor_fcmp_val(ctx, v2293, v2294.0, v2294.1);
                        let v2298 = constructor_lower_bool(ctx, v79, v2297);
                        let v2299 = constructor_output_reg(ctx, v2298);
                        let v2300 = Some(v2299);
                        // Rule at src\isa\s390x\lower.isle line 3524.
                        return v2300;
                    }
                }
            }
        }
        &InstructionData::FuncAddr {
            opcode: ref v1876,
            func_ref: v1877,
        } => {
            if let &Opcode::FuncAddr = v1876 {
                let v1878 = C::func_ref_data(ctx, v1877);
                if let &RelocDistance::Near = &v1878.2 {
                    let v1883 = C::memflags_trusted(ctx);
                    let v1884 = &C::memarg_symbol(ctx, v1878.1, 0_i32, v1883);
                    let v1885 = constructor_load_addr(ctx, v1884);
                    let v1886 = constructor_output_reg(ctx, v1885);
                    let v1887 = Some(v1886);
                    // Rule at src\isa\s390x\lower.isle line 2304.
                    return v1887;
                }
                let v1889 = SymbolReloc::Absolute {
                    name: v1878.1,
                    offset: 0_i64,
                };
                let v1890 = constructor_load_symbol_reloc(ctx, &v1889);
                let v1891 = constructor_output_reg(ctx, v1890);
                let v1892 = Some(v1891);
                // Rule at src\isa\s390x\lower.isle line 2308.
                return v1892;
            }
        }
        &InstructionData::IntAddTrap {
            opcode: ref v2467,
            args: ref v2468,
            code: ref v2469,
        } => {
            if let &Opcode::UaddOverflowTrap = v2467 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    let v3 = C::value_type(ctx, v2);
                    let v78 = C::fits_in_64(ctx, v3);
                    if let Some(v79) = v78 {
                        let v2470 = C::unpack_value_array_2(ctx, v2468);
                        let v2492 = C::def_inst(ctx, v2470.0);
                        if let Some(v2493) = v2492 {
                            let v2494 = &C::inst_data_value(ctx, v2493);
                            if let &InstructionData::Unary {
                                opcode: ref v2495,
                                arg: v2496,
                            } = v2494 {
                                if let &Opcode::Uextend = v2495 {
                                    let v2497 = C::value_type(ctx, v2496);
                                    if v2497 == I32 {
                                        let v2498 = C::put_in_reg(ctx, v2470.1);
                                        let v2499 = C::put_in_reg(ctx, v2496);
                                        let v2500 = &constructor_add_logical_reg_zext32_with_flags_paired(ctx, v79, v2498, v2499);
                                        let v2476 = &C::mask_as_cond(ctx, 0x3_u8);
                                        let v2477 = &constructor_trap_if_impl(ctx, v2476, v2469);
                                        let v2501 = constructor_with_flags(ctx, v2500, v2477);
                                        let v2502 = C::output(ctx, v2501);
                                        let v2503 = Some(v2502);
                                        // Rule at src\isa\s390x\lower.isle line 3908.
                                        return v2503;
                                    }
                                }
                            }
                        }
                        let v2512 = C::u32_from_value(ctx, v2470.0);
                        if let Some(v2513) = v2512 {
                            let v2498 = C::put_in_reg(ctx, v2470.1);
                            let v2514 = &constructor_add_logical_zimm32_with_flags_paired(ctx, v79, v2498, v2513);
                            let v2507 = &C::mask_as_cond(ctx, 0x3_u8);
                            let v2508 = &constructor_trap_if_impl(ctx, v2507, v2469);
                            let v2515 = constructor_with_flags(ctx, v2514, v2508);
                            let v2516 = C::output(ctx, v2515);
                            let v2517 = Some(v2516);
                            // Rule at src\isa\s390x\lower.isle line 3920.
                            return v2517;
                        }
                        let v2538 = C::sinkable_inst(ctx, v2470.0);
                        if let Some(v2539) = v2538 {
                            let v2540 = &C::inst_data_value(ctx, v2539);
                            if let &InstructionData::Load {
                                opcode: ref v2541,
                                arg: v2542,
                                flags: v2543,
                                offset: v2544,
                            } = v2540 {
                                match v2541 {
                                    &Opcode::Load => {
                                        let v2535 = C::value_type(ctx, v2470.0);
                                        let v2536 = C::ty_32_or_64(ctx, v2535);
                                        if let Some(v2537) = v2536 {
                                            let v2545 = C::bigendian(ctx, v2543);
                                            if let Some(v2546) = v2545 {
                                                let v2498 = C::put_in_reg(ctx, v2470.1);
                                                let v2547 = &constructor_sink_load(ctx, v2539);
                                                let v2548 = &constructor_add_logical_mem_with_flags_paired(ctx, v79, v2498, v2547);
                                                let v2476 = &C::mask_as_cond(ctx, 0x3_u8);
                                                let v2477 = &constructor_trap_if_impl(ctx, v2476, v2469);
                                                let v2549 = constructor_with_flags(ctx, v2548, v2477);
                                                let v2550 = C::output(ctx, v2549);
                                                let v2551 = Some(v2550);
                                                // Rule at src\isa\s390x\lower.isle line 3932.
                                                return v2551;
                                            }
                                        }
                                    }
                                    &Opcode::Uload32 => {
                                        let v2545 = C::bigendian(ctx, v2543);
                                        if let Some(v2546) = v2545 {
                                            let v2498 = C::put_in_reg(ctx, v2470.1);
                                            let v2557 = &constructor_sink_uload32(ctx, v2539);
                                            let v2558 = &constructor_add_logical_mem_zext32_with_flags_paired(ctx, v79, v2498, v2557);
                                            let v2476 = &C::mask_as_cond(ctx, 0x3_u8);
                                            let v2477 = &constructor_trap_if_impl(ctx, v2476, v2469);
                                            let v2559 = constructor_with_flags(ctx, v2558, v2477);
                                            let v2560 = C::output(ctx, v2559);
                                            let v2561 = Some(v2560);
                                            // Rule at src\isa\s390x\lower.isle line 3944.
                                            return v2561;
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                        let v2481 = C::def_inst(ctx, v2470.1);
                        if let Some(v2482) = v2481 {
                            let v2483 = &C::inst_data_value(ctx, v2482);
                            if let &InstructionData::Unary {
                                opcode: ref v2484,
                                arg: v2485,
                            } = v2483 {
                                if let &Opcode::Uextend = v2484 {
                                    let v2486 = C::value_type(ctx, v2485);
                                    if v2486 == I32 {
                                        let v2473 = C::put_in_reg(ctx, v2470.0);
                                        let v2487 = C::put_in_reg(ctx, v2485);
                                        let v2488 = &constructor_add_logical_reg_zext32_with_flags_paired(ctx, v79, v2473, v2487);
                                        let v2476 = &C::mask_as_cond(ctx, 0x3_u8);
                                        let v2477 = &constructor_trap_if_impl(ctx, v2476, v2469);
                                        let v2489 = constructor_with_flags(ctx, v2488, v2477);
                                        let v2490 = C::output(ctx, v2489);
                                        let v2491 = Some(v2490);
                                        // Rule at src\isa\s390x\lower.isle line 3903.
                                        return v2491;
                                    }
                                }
                            }
                        }
                        let v2504 = C::u32_from_value(ctx, v2470.1);
                        if let Some(v2505) = v2504 {
                            let v2473 = C::put_in_reg(ctx, v2470.0);
                            let v2506 = &constructor_add_logical_zimm32_with_flags_paired(ctx, v79, v2473, v2505);
                            let v2507 = &C::mask_as_cond(ctx, 0x3_u8);
                            let v2508 = &constructor_trap_if_impl(ctx, v2507, v2469);
                            let v2509 = constructor_with_flags(ctx, v2506, v2508);
                            let v2510 = C::output(ctx, v2509);
                            let v2511 = Some(v2510);
                            // Rule at src\isa\s390x\lower.isle line 3915.
                            return v2511;
                        }
                        let v2521 = C::sinkable_inst(ctx, v2470.1);
                        if let Some(v2522) = v2521 {
                            let v2523 = &C::inst_data_value(ctx, v2522);
                            if let &InstructionData::Load {
                                opcode: ref v2524,
                                arg: v2525,
                                flags: v2526,
                                offset: v2527,
                            } = v2523 {
                                match v2524 {
                                    &Opcode::Load => {
                                        let v2518 = C::value_type(ctx, v2470.1);
                                        let v2519 = C::ty_32_or_64(ctx, v2518);
                                        if let Some(v2520) = v2519 {
                                            let v2528 = C::bigendian(ctx, v2526);
                                            if let Some(v2529) = v2528 {
                                                let v2473 = C::put_in_reg(ctx, v2470.0);
                                                let v2530 = &constructor_sink_load(ctx, v2522);
                                                let v2531 = &constructor_add_logical_mem_with_flags_paired(ctx, v79, v2473, v2530);
                                                let v2476 = &C::mask_as_cond(ctx, 0x3_u8);
                                                let v2477 = &constructor_trap_if_impl(ctx, v2476, v2469);
                                                let v2532 = constructor_with_flags(ctx, v2531, v2477);
                                                let v2533 = C::output(ctx, v2532);
                                                let v2534 = Some(v2533);
                                                // Rule at src\isa\s390x\lower.isle line 3927.
                                                return v2534;
                                            }
                                        }
                                    }
                                    &Opcode::Uload32 => {
                                        let v2528 = C::bigendian(ctx, v2526);
                                        if let Some(v2529) = v2528 {
                                            let v2473 = C::put_in_reg(ctx, v2470.0);
                                            let v2552 = &constructor_sink_uload32(ctx, v2522);
                                            let v2553 = &constructor_add_logical_mem_zext32_with_flags_paired(ctx, v79, v2473, v2552);
                                            let v2476 = &C::mask_as_cond(ctx, 0x3_u8);
                                            let v2477 = &constructor_trap_if_impl(ctx, v2476, v2469);
                                            let v2554 = constructor_with_flags(ctx, v2553, v2477);
                                            let v2555 = C::output(ctx, v2554);
                                            let v2556 = Some(v2555);
                                            // Rule at src\isa\s390x\lower.isle line 3939.
                                            return v2556;
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                        let v2473 = C::put_in_reg(ctx, v2470.0);
                        let v2474 = C::put_in_reg(ctx, v2470.1);
                        let v2475 = &constructor_add_logical_reg_with_flags_paired(ctx, v79, v2473, v2474);
                        let v2476 = &C::mask_as_cond(ctx, 0x3_u8);
                        let v2477 = &constructor_trap_if_impl(ctx, v2476, v2469);
                        let v2478 = constructor_with_flags(ctx, v2475, v2477);
                        let v2479 = C::output(ctx, v2478);
                        let v2480 = Some(v2479);
                        // Rule at src\isa\s390x\lower.isle line 3897.
                        return v2480;
                    }
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref v2246,
            args: ref v2247,
            cond: ref v2248,
        } => {
            if let &Opcode::Icmp = v2246 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    match v2248 {
                        &IntCC::Equal => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2257 = C::put_in_reg(ctx, v2249.0);
                                let v2258 = C::put_in_reg(ctx, v2249.1);
                                let v2259 = constructor_vec_cmpeq(ctx, v183, v2257, v2258);
                                let v2260 = constructor_output_reg(ctx, v2259);
                                let v2261 = Some(v2260);
                                // Rule at src\isa\s390x\lower.isle line 3498.
                                return v2261;
                            }
                        }
                        &IntCC::NotEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2257 = C::put_in_reg(ctx, v2249.0);
                                let v2258 = C::put_in_reg(ctx, v2249.1);
                                let v2259 = constructor_vec_cmpeq(ctx, v183, v2257, v2258);
                                let v2262 = constructor_vec_not(ctx, v183, v2259);
                                let v2263 = constructor_output_reg(ctx, v2262);
                                let v2264 = Some(v2263);
                                // Rule at src\isa\s390x\lower.isle line 3500.
                                return v2264;
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2257 = C::put_in_reg(ctx, v2249.0);
                                let v2258 = C::put_in_reg(ctx, v2249.1);
                                let v2265 = constructor_vec_cmph(ctx, v183, v2257, v2258);
                                let v2266 = constructor_output_reg(ctx, v2265);
                                let v2267 = Some(v2266);
                                // Rule at src\isa\s390x\lower.isle line 3502.
                                return v2267;
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2271 = C::put_in_reg(ctx, v2249.1);
                                let v2272 = C::put_in_reg(ctx, v2249.0);
                                let v2273 = constructor_vec_cmph(ctx, v183, v2271, v2272);
                                let v2276 = constructor_vec_not(ctx, v183, v2273);
                                let v2277 = constructor_output_reg(ctx, v2276);
                                let v2278 = Some(v2277);
                                // Rule at src\isa\s390x\lower.isle line 3508.
                                return v2278;
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2271 = C::put_in_reg(ctx, v2249.1);
                                let v2272 = C::put_in_reg(ctx, v2249.0);
                                let v2273 = constructor_vec_cmph(ctx, v183, v2271, v2272);
                                let v2274 = constructor_output_reg(ctx, v2273);
                                let v2275 = Some(v2274);
                                // Rule at src\isa\s390x\lower.isle line 3506.
                                return v2275;
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2257 = C::put_in_reg(ctx, v2249.0);
                                let v2258 = C::put_in_reg(ctx, v2249.1);
                                let v2265 = constructor_vec_cmph(ctx, v183, v2257, v2258);
                                let v2268 = constructor_vec_not(ctx, v183, v2265);
                                let v2269 = constructor_output_reg(ctx, v2268);
                                let v2270 = Some(v2269);
                                // Rule at src\isa\s390x\lower.isle line 3504.
                                return v2270;
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2257 = C::put_in_reg(ctx, v2249.0);
                                let v2258 = C::put_in_reg(ctx, v2249.1);
                                let v2279 = constructor_vec_cmphl(ctx, v183, v2257, v2258);
                                let v2280 = constructor_output_reg(ctx, v2279);
                                let v2281 = Some(v2280);
                                // Rule at src\isa\s390x\lower.isle line 3510.
                                return v2281;
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2271 = C::put_in_reg(ctx, v2249.1);
                                let v2272 = C::put_in_reg(ctx, v2249.0);
                                let v2285 = constructor_vec_cmphl(ctx, v183, v2271, v2272);
                                let v2288 = constructor_vec_not(ctx, v183, v2285);
                                let v2289 = constructor_output_reg(ctx, v2288);
                                let v2290 = Some(v2289);
                                // Rule at src\isa\s390x\lower.isle line 3516.
                                return v2290;
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2271 = C::put_in_reg(ctx, v2249.1);
                                let v2272 = C::put_in_reg(ctx, v2249.0);
                                let v2285 = constructor_vec_cmphl(ctx, v183, v2271, v2272);
                                let v2286 = constructor_output_reg(ctx, v2285);
                                let v2287 = Some(v2286);
                                // Rule at src\isa\s390x\lower.isle line 3514.
                                return v2287;
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v3 = C::value_type(ctx, v2);
                            let v182 = C::ty_vec128(ctx, v3);
                            if let Some(v183) = v182 {
                                let v2249 = C::unpack_value_array_2(ctx, v2247);
                                let v2257 = C::put_in_reg(ctx, v2249.0);
                                let v2258 = C::put_in_reg(ctx, v2249.1);
                                let v2279 = constructor_vec_cmphl(ctx, v183, v2257, v2258);
                                let v2282 = constructor_vec_not(ctx, v183, v2279);
                                let v2283 = constructor_output_reg(ctx, v2282);
                                let v2284 = Some(v2283);
                                // Rule at src\isa\s390x\lower.isle line 3512.
                                return v2284;
                            }
                        }
                        _ => {}
                    }
                    let v3 = C::value_type(ctx, v2);
                    let v78 = C::fits_in_64(ctx, v3);
                    if let Some(v79) = v78 {
                        let v2252 = true;
                        let v2249 = C::unpack_value_array_2(ctx, v2247);
                        let v2253 = &constructor_icmp_val(ctx, v2252, v2248, v2249.0, v2249.1);
                        let v2254 = constructor_lower_bool(ctx, v79, v2253);
                        let v2255 = constructor_output_reg(ctx, v2254);
                        let v2256 = Some(v2255);
                        // Rule at src\isa\s390x\lower.isle line 3376.
                        return v2256;
                    }
                }
            }
        }
        &InstructionData::Load {
            opcode: ref v1921,
            arg: v1922,
            flags: v1923,
            offset: v1924,
        } => {
            match v1921 {
                &Opcode::Load => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v1854 = &C::lane_order(ctx);
                            match v1854 {
                                &LaneOrder::LittleEndian => {
                                    let v1930 = C::bigendian(ctx, v1923);
                                    if let Some(v1931) = v1930 {
                                        let v1977 = constructor_vec_load_elt_rev(ctx, v52, v1923, v1922, v1924);
                                        let v1978 = constructor_output_reg(ctx, v1977);
                                        let v1979 = Some(v1978);
                                        // Rule at src\isa\s390x\lower.isle line 2418.
                                        return v1979;
                                    }
                                    let v1936 = C::littleendian(ctx, v1923);
                                    if let Some(v1937) = v1936 {
                                        let v1980 = constructor_vec_load_full_rev(ctx, v52, v1923, v1922, v1924);
                                        let v1981 = constructor_output_reg(ctx, v1980);
                                        let v1982 = Some(v1981);
                                        // Rule at src\isa\s390x\lower.isle line 2423.
                                        return v1982;
                                    }
                                }
                                &LaneOrder::BigEndian => {
                                    let v1930 = C::bigendian(ctx, v1923);
                                    if let Some(v1931) = v1930 {
                                        let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                        let v1971 = constructor_vec_load(ctx, v52, v1926);
                                        let v1972 = constructor_output_reg(ctx, v1971);
                                        let v1973 = Some(v1972);
                                        // Rule at src\isa\s390x\lower.isle line 2408.
                                        return v1973;
                                    }
                                    let v1936 = C::littleendian(ctx, v1923);
                                    if let Some(v1937) = v1936 {
                                        let v1974 = constructor_vec_load_byte_rev(ctx, v52, v1923, v1922, v1924);
                                        let v1975 = constructor_output_reg(ctx, v1974);
                                        let v1976 = Some(v1975);
                                        // Rule at src\isa\s390x\lower.isle line 2413.
                                        return v1976;
                                    }
                                }
                                _ => {}
                            }
                        }
                        match v3 {
                            I8 => {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1927 = constructor_zext32_mem(ctx, I8, v1926);
                                let v1928 = constructor_output_reg(ctx, v1927);
                                let v1929 = Some(v1928);
                                // Rule at src\isa\s390x\lower.isle line 2356.
                                return v1929;
                            }
                            I16 => {
                                let v1930 = C::bigendian(ctx, v1923);
                                if let Some(v1931) = v1930 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1933 = constructor_zext32_mem(ctx, I16, v1926);
                                    let v1934 = constructor_output_reg(ctx, v1933);
                                    let v1935 = Some(v1934);
                                    // Rule at src\isa\s390x\lower.isle line 2360.
                                    return v1935;
                                }
                                let v1936 = C::littleendian(ctx, v1923);
                                if let Some(v1937) = v1936 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1938 = constructor_loadrev16(ctx, v1926);
                                    let v1939 = constructor_output_reg(ctx, v1938);
                                    let v1940 = Some(v1939);
                                    // Rule at src\isa\s390x\lower.isle line 2364.
                                    return v1940;
                                }
                            }
                            I32 => {
                                let v1930 = C::bigendian(ctx, v1923);
                                if let Some(v1931) = v1930 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1941 = constructor_load32(ctx, v1926);
                                    let v1942 = constructor_output_reg(ctx, v1941);
                                    let v1943 = Some(v1942);
                                    // Rule at src\isa\s390x\lower.isle line 2368.
                                    return v1943;
                                }
                                let v1936 = C::littleendian(ctx, v1923);
                                if let Some(v1937) = v1936 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1944 = constructor_loadrev32(ctx, v1926);
                                    let v1945 = constructor_output_reg(ctx, v1944);
                                    let v1946 = Some(v1945);
                                    // Rule at src\isa\s390x\lower.isle line 2372.
                                    return v1946;
                                }
                            }
                            I64 => {
                                let v1930 = C::bigendian(ctx, v1923);
                                if let Some(v1931) = v1930 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1947 = constructor_load64(ctx, v1926);
                                    let v1948 = constructor_output_reg(ctx, v1947);
                                    let v1949 = Some(v1948);
                                    // Rule at src\isa\s390x\lower.isle line 2376.
                                    return v1949;
                                }
                                let v1936 = C::littleendian(ctx, v1923);
                                if let Some(v1937) = v1936 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1950 = constructor_loadrev64(ctx, v1926);
                                    let v1951 = constructor_output_reg(ctx, v1950);
                                    let v1952 = Some(v1951);
                                    // Rule at src\isa\s390x\lower.isle line 2380.
                                    return v1952;
                                }
                            }
                            F16 => {
                                let v1930 = C::bigendian(ctx, v1923);
                                if let Some(v1931) = v1930 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1953 = constructor_vec_load_lane_undef(ctx, F16X8, v1926, 0x0_u8);
                                    let v1954 = constructor_output_reg(ctx, v1953);
                                    let v1955 = Some(v1954);
                                    // Rule at src\isa\s390x\lower.isle line 2384.
                                    return v1955;
                                }
                                let v1936 = C::littleendian(ctx, v1923);
                                if let Some(v1937) = v1936 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1956 = constructor_vec_load_lane_little_undef(ctx, F16X8, v1926, 0x0_u8);
                                    let v1957 = constructor_output_reg(ctx, v1956);
                                    let v1958 = Some(v1957);
                                    // Rule at src\isa\s390x\lower.isle line 2388.
                                    return v1958;
                                }
                            }
                            F32 => {
                                let v1930 = C::bigendian(ctx, v1923);
                                if let Some(v1931) = v1930 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1959 = constructor_vec_load_lane_undef(ctx, F32X4, v1926, 0x0_u8);
                                    let v1960 = constructor_output_reg(ctx, v1959);
                                    let v1961 = Some(v1960);
                                    // Rule at src\isa\s390x\lower.isle line 2392.
                                    return v1961;
                                }
                                let v1936 = C::littleendian(ctx, v1923);
                                if let Some(v1937) = v1936 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1962 = constructor_vec_load_lane_little_undef(ctx, F32X4, v1926, 0x0_u8);
                                    let v1963 = constructor_output_reg(ctx, v1962);
                                    let v1964 = Some(v1963);
                                    // Rule at src\isa\s390x\lower.isle line 2396.
                                    return v1964;
                                }
                            }
                            F64 => {
                                let v1930 = C::bigendian(ctx, v1923);
                                if let Some(v1931) = v1930 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1965 = constructor_vec_load_lane_undef(ctx, F64X2, v1926, 0x0_u8);
                                    let v1966 = constructor_output_reg(ctx, v1965);
                                    let v1967 = Some(v1966);
                                    // Rule at src\isa\s390x\lower.isle line 2400.
                                    return v1967;
                                }
                                let v1936 = C::littleendian(ctx, v1923);
                                if let Some(v1937) = v1936 {
                                    let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                    let v1968 = constructor_vec_load_lane_little_undef(ctx, F64X2, v1926, 0x0_u8);
                                    let v1969 = constructor_output_reg(ctx, v1968);
                                    let v1970 = Some(v1969);
                                    // Rule at src\isa\s390x\lower.isle line 2404.
                                    return v1970;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Uload8 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                            let v1983 = constructor_zext64_mem(ctx, I8, v1926);
                            let v1984 = constructor_output_reg(ctx, v1983);
                            let v1985 = Some(v1984);
                            // Rule at src\isa\s390x\lower.isle line 2528.
                            return v1985;
                        }
                        let v727 = C::gpr32_ty(ctx, v3);
                        if let Some(v728) = v727 {
                            let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                            let v1927 = constructor_zext32_mem(ctx, I8, v1926);
                            let v1928 = constructor_output_reg(ctx, v1927);
                            let v1929 = Some(v1928);
                            // Rule at src\isa\s390x\lower.isle line 2524.
                            return v1929;
                        }
                    }
                }
                &Opcode::Sload8 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                            let v1989 = constructor_sext64_mem(ctx, I8, v1926);
                            let v1990 = constructor_output_reg(ctx, v1989);
                            let v1991 = Some(v1990);
                            // Rule at src\isa\s390x\lower.isle line 2539.
                            return v1991;
                        }
                        let v727 = C::gpr32_ty(ctx, v3);
                        if let Some(v728) = v727 {
                            let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                            let v1986 = constructor_sext32_mem(ctx, I8, v1926);
                            let v1987 = constructor_output_reg(ctx, v1986);
                            let v1988 = Some(v1987);
                            // Rule at src\isa\s390x\lower.isle line 2535.
                            return v1988;
                        }
                    }
                }
                &Opcode::Uload16 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v1930 = C::bigendian(ctx, v1923);
                        if let Some(v1931) = v1930 {
                            let v3 = C::value_type(ctx, v2);
                            let v732 = C::gpr64_ty(ctx, v3);
                            if let Some(v733) = v732 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1995 = constructor_zext64_mem(ctx, I16, v1926);
                                let v1996 = constructor_output_reg(ctx, v1995);
                                let v1997 = Some(v1996);
                                // Rule at src\isa\s390x\lower.isle line 2557.
                                return v1997;
                            }
                            let v727 = C::gpr32_ty(ctx, v3);
                            if let Some(v728) = v727 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1933 = constructor_zext32_mem(ctx, I16, v1926);
                                let v1934 = constructor_output_reg(ctx, v1933);
                                let v1935 = Some(v1934);
                                // Rule at src\isa\s390x\lower.isle line 2546.
                                return v1935;
                            }
                        }
                        let v1936 = C::littleendian(ctx, v1923);
                        if let Some(v1937) = v1936 {
                            let v3 = C::value_type(ctx, v2);
                            let v732 = C::gpr64_ty(ctx, v3);
                            if let Some(v733) = v732 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1938 = constructor_loadrev16(ctx, v1926);
                                let v1998 = constructor_zext64_reg(ctx, I16, v1938);
                                let v1999 = constructor_output_reg(ctx, v1998);
                                let v2000 = Some(v1999);
                                // Rule at src\isa\s390x\lower.isle line 2562.
                                return v2000;
                            }
                            let v727 = C::gpr32_ty(ctx, v3);
                            if let Some(v728) = v727 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1938 = constructor_loadrev16(ctx, v1926);
                                let v1992 = constructor_zext32_reg(ctx, I16, v1938);
                                let v1993 = constructor_output_reg(ctx, v1992);
                                let v1994 = Some(v1993);
                                // Rule at src\isa\s390x\lower.isle line 2551.
                                return v1994;
                            }
                        }
                    }
                }
                &Opcode::Sload16 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v1930 = C::bigendian(ctx, v1923);
                        if let Some(v1931) = v1930 {
                            let v3 = C::value_type(ctx, v2);
                            let v732 = C::gpr64_ty(ctx, v3);
                            if let Some(v733) = v732 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v2007 = constructor_sext64_mem(ctx, I16, v1926);
                                let v2008 = constructor_output_reg(ctx, v2007);
                                let v2009 = Some(v2008);
                                // Rule at src\isa\s390x\lower.isle line 2582.
                                return v2009;
                            }
                            let v727 = C::gpr32_ty(ctx, v3);
                            if let Some(v728) = v727 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v2001 = constructor_sext32_mem(ctx, I16, v1926);
                                let v2002 = constructor_output_reg(ctx, v2001);
                                let v2003 = Some(v2002);
                                // Rule at src\isa\s390x\lower.isle line 2571.
                                return v2003;
                            }
                        }
                        let v1936 = C::littleendian(ctx, v1923);
                        if let Some(v1937) = v1936 {
                            let v3 = C::value_type(ctx, v2);
                            let v732 = C::gpr64_ty(ctx, v3);
                            if let Some(v733) = v732 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1938 = constructor_loadrev16(ctx, v1926);
                                let v2010 = constructor_sext64_reg(ctx, I16, v1938);
                                let v2011 = constructor_output_reg(ctx, v2010);
                                let v2012 = Some(v2011);
                                // Rule at src\isa\s390x\lower.isle line 2587.
                                return v2012;
                            }
                            let v727 = C::gpr32_ty(ctx, v3);
                            if let Some(v728) = v727 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1938 = constructor_loadrev16(ctx, v1926);
                                let v2004 = constructor_sext32_reg(ctx, I16, v1938);
                                let v2005 = constructor_output_reg(ctx, v2004);
                                let v2006 = Some(v2005);
                                // Rule at src\isa\s390x\lower.isle line 2576.
                                return v2006;
                            }
                        }
                    }
                }
                &Opcode::Uload32 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v1930 = C::bigendian(ctx, v1923);
                            if let Some(v1931) = v1930 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v2013 = constructor_zext64_mem(ctx, I32, v1926);
                                let v2014 = constructor_output_reg(ctx, v2013);
                                let v2015 = Some(v2014);
                                // Rule at src\isa\s390x\lower.isle line 2596.
                                return v2015;
                            }
                            let v1936 = C::littleendian(ctx, v1923);
                            if let Some(v1937) = v1936 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1944 = constructor_loadrev32(ctx, v1926);
                                let v2016 = constructor_zext64_reg(ctx, I32, v1944);
                                let v2017 = constructor_output_reg(ctx, v2016);
                                let v2018 = Some(v2017);
                                // Rule at src\isa\s390x\lower.isle line 2601.
                                return v2018;
                            }
                        }
                    }
                }
                &Opcode::Sload32 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v1930 = C::bigendian(ctx, v1923);
                            if let Some(v1931) = v1930 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v2019 = constructor_sext64_mem(ctx, I32, v1926);
                                let v2020 = constructor_output_reg(ctx, v2019);
                                let v2021 = Some(v2020);
                                // Rule at src\isa\s390x\lower.isle line 2610.
                                return v2021;
                            }
                            let v1936 = C::littleendian(ctx, v1923);
                            if let Some(v1937) = v1936 {
                                let v1926 = &constructor_lower_address(ctx, v1923, v1922, v1924);
                                let v1944 = constructor_loadrev32(ctx, v1926);
                                let v2022 = constructor_sext64_reg(ctx, I32, v1944);
                                let v2023 = constructor_output_reg(ctx, v2022);
                                let v2024 = Some(v2023);
                                // Rule at src\isa\s390x\lower.isle line 2615.
                                return v2024;
                            }
                        }
                    }
                }
                &Opcode::Uload8x8 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I16X8 {
                            let v2025 = constructor_load_v64(ctx, I8X16, v1923, v1922, v1924);
                            let v2026 = constructor_vec_unpacku_high(ctx, I8X16, v2025);
                            let v2027 = constructor_output_reg(ctx, v2026);
                            let v2028 = Some(v2027);
                            // Rule at src\isa\s390x\lower.isle line 2624.
                            return v2028;
                        }
                    }
                }
                &Opcode::Sload8x8 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I16X8 {
                            let v2025 = constructor_load_v64(ctx, I8X16, v1923, v1922, v1924);
                            let v2029 = constructor_vec_unpacks_high(ctx, I8X16, v2025);
                            let v2030 = constructor_output_reg(ctx, v2029);
                            let v2031 = Some(v2030);
                            // Rule at src\isa\s390x\lower.isle line 2628.
                            return v2031;
                        }
                    }
                }
                &Opcode::Uload16x4 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I32X4 {
                            let v2032 = constructor_load_v64(ctx, I16X8, v1923, v1922, v1924);
                            let v2033 = constructor_vec_unpacku_high(ctx, I16X8, v2032);
                            let v2034 = constructor_output_reg(ctx, v2033);
                            let v2035 = Some(v2034);
                            // Rule at src\isa\s390x\lower.isle line 2632.
                            return v2035;
                        }
                    }
                }
                &Opcode::Sload16x4 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I32X4 {
                            let v2032 = constructor_load_v64(ctx, I16X8, v1923, v1922, v1924);
                            let v2036 = constructor_vec_unpacks_high(ctx, I16X8, v2032);
                            let v2037 = constructor_output_reg(ctx, v2036);
                            let v2038 = Some(v2037);
                            // Rule at src\isa\s390x\lower.isle line 2636.
                            return v2038;
                        }
                    }
                }
                &Opcode::Uload32x2 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I64X2 {
                            let v2039 = constructor_load_v64(ctx, I32X4, v1923, v1922, v1924);
                            let v2040 = constructor_vec_unpacku_high(ctx, I32X4, v2039);
                            let v2041 = constructor_output_reg(ctx, v2040);
                            let v2042 = Some(v2041);
                            // Rule at src\isa\s390x\lower.isle line 2640.
                            return v2042;
                        }
                    }
                }
                &Opcode::Sload32x2 => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == I64X2 {
                            let v2039 = constructor_load_v64(ctx, I32X4, v1923, v1922, v1924);
                            let v2043 = constructor_vec_unpacks_high(ctx, I32X4, v2039);
                            let v2044 = constructor_output_reg(ctx, v2043);
                            let v2045 = Some(v2044);
                            // Rule at src\isa\s390x\lower.isle line 2644.
                            return v2045;
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::LoadNoOffset {
            opcode: ref v1376,
            arg: v1377,
            flags: v1378,
        } => {
            match v1376 {
                &Opcode::Bitcast => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v206 = C::multi_lane(ctx, v3);
                        if let Some(v207) = v206 {
                            let v1379 = C::value_type(ctx, v1377);
                            let v1410 = C::multi_lane(ctx, v1379);
                            if let Some(v1411) = v1410 {
                                if v207.0 == v1411.0 {
                                    if v207.1 == v1411.1 {
                                        let v1402 = constructor_output_value(ctx, v1377);
                                        let v1403 = Some(v1402);
                                        // Rule at src\isa\s390x\lower.isle line 1799.
                                        return v1403;
                                    }
                                }
                            }
                        }
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v1379 = C::value_type(ctx, v1377);
                            let v1414 = C::vr128_ty(ctx, v1379);
                            if let Some(v1415) = v1414 {
                                let v1380 = C::put_in_reg(ctx, v1377);
                                let v1416 = &constructor_lane_order_from_memflags(ctx, v1378);
                                let v1417 = constructor_abi_vec_elt_rev(ctx, v1416, v1415, v1380);
                                let v1418 = constructor_abi_vec_elt_rev(ctx, v1416, v52, v1417);
                                let v1419 = constructor_output_reg(ctx, v1418);
                                let v1420 = Some(v1419);
                                // Rule at src\isa\s390x\lower.isle line 1810.
                                return v1420;
                            }
                        }
                        let v1406 = C::ty_scalar_float(ctx, v3);
                        if let Some(v1407) = v1406 {
                            let v1379 = C::value_type(ctx, v1377);
                            let v1408 = C::ty_scalar_float(ctx, v1379);
                            if let Some(v1409) = v1408 {
                                let v1402 = constructor_output_value(ctx, v1377);
                                let v1403 = Some(v1402);
                                // Rule at src\isa\s390x\lower.isle line 1794.
                                return v1403;
                            }
                        }
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v1379 = C::value_type(ctx, v1377);
                            let v1404 = C::gpr64_ty(ctx, v1379);
                            if let Some(v1405) = v1404 {
                                let v1402 = constructor_output_value(ctx, v1377);
                                let v1403 = Some(v1402);
                                // Rule at src\isa\s390x\lower.isle line 1789.
                                return v1403;
                            }
                        }
                        let v727 = C::gpr32_ty(ctx, v3);
                        if let Some(v728) = v727 {
                            let v1379 = C::value_type(ctx, v1377);
                            let v1400 = C::gpr32_ty(ctx, v1379);
                            if let Some(v1401) = v1400 {
                                let v1402 = constructor_output_value(ctx, v1377);
                                let v1403 = Some(v1402);
                                // Rule at src\isa\s390x\lower.isle line 1786.
                                return v1403;
                            }
                        }
                        match v3 {
                            I16 => {
                                let v1379 = C::value_type(ctx, v1377);
                                if v1379 == F16 {
                                    let v1380 = C::put_in_reg(ctx, v1377);
                                    let v69 = C::zero_reg(ctx);
                                    let v1397 = constructor_vec_extract_lane(ctx, F16X8, v1380, 0x0_u8, v69);
                                    let v1398 = constructor_output_reg(ctx, v1397);
                                    let v1399 = Some(v1398);
                                    // Rule at src\isa\s390x\lower.isle line 1782.
                                    return v1399;
                                }
                            }
                            I32 => {
                                let v1379 = C::value_type(ctx, v1377);
                                if v1379 == F32 {
                                    let v1380 = C::put_in_reg(ctx, v1377);
                                    let v69 = C::zero_reg(ctx);
                                    let v1390 = constructor_vec_extract_lane(ctx, F32X4, v1380, 0x0_u8, v69);
                                    let v1391 = constructor_output_reg(ctx, v1390);
                                    let v1392 = Some(v1391);
                                    // Rule at src\isa\s390x\lower.isle line 1774.
                                    return v1392;
                                }
                            }
                            I64 => {
                                let v1379 = C::value_type(ctx, v1377);
                                if v1379 == F64 {
                                    let v1380 = C::put_in_reg(ctx, v1377);
                                    let v69 = C::zero_reg(ctx);
                                    let v1384 = constructor_vec_extract_lane(ctx, F64X2, v1380, 0x0_u8, v69);
                                    let v1385 = constructor_output_reg(ctx, v1384);
                                    let v1386 = Some(v1385);
                                    // Rule at src\isa\s390x\lower.isle line 1766.
                                    return v1386;
                                }
                            }
                            F16 => {
                                let v1379 = C::value_type(ctx, v1377);
                                if v1379 == I16 {
                                    let v1380 = C::put_in_reg(ctx, v1377);
                                    let v69 = C::zero_reg(ctx);
                                    let v1394 = constructor_vec_insert_lane_undef(ctx, F16X8, v1380, 0x0_u8, v69);
                                    let v1395 = constructor_output_reg(ctx, v1394);
                                    let v1396 = Some(v1395);
                                    // Rule at src\isa\s390x\lower.isle line 1778.
                                    return v1396;
                                }
                            }
                            F32 => {
                                let v1379 = C::value_type(ctx, v1377);
                                if v1379 == I32 {
                                    let v1380 = C::put_in_reg(ctx, v1377);
                                    let v69 = C::zero_reg(ctx);
                                    let v1387 = constructor_vec_insert_lane_undef(ctx, F32X4, v1380, 0x0_u8, v69);
                                    let v1388 = constructor_output_reg(ctx, v1387);
                                    let v1389 = Some(v1388);
                                    // Rule at src\isa\s390x\lower.isle line 1770.
                                    return v1389;
                                }
                            }
                            F64 => {
                                let v1379 = C::value_type(ctx, v1377);
                                if v1379 == I64 {
                                    let v1380 = C::put_in_reg(ctx, v1377);
                                    let v69 = C::zero_reg(ctx);
                                    let v1381 = constructor_vec_insert_lane_undef(ctx, F64X2, v1380, 0x0_u8, v69);
                                    let v1382 = constructor_output_reg(ctx, v1381);
                                    let v1383 = Some(v1382);
                                    // Rule at src\isa\s390x\lower.isle line 1762.
                                    return v1383;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::AtomicLoad => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            I8 => {
                                let v2197 = C::zero_offset(ctx);
                                let v2198 = &constructor_lower_address(ctx, v1378, v1377, v2197);
                                let v2199 = constructor_zext32_mem(ctx, I8, v2198);
                                let v2200 = constructor_output_reg(ctx, v2199);
                                let v2201 = Some(v2200);
                                // Rule at src\isa\s390x\lower.isle line 3287.
                                return v2201;
                            }
                            I16 => {
                                let v2202 = C::bigendian(ctx, v1378);
                                if let Some(v2203) = v2202 {
                                    let v2197 = C::zero_offset(ctx);
                                    let v2198 = &constructor_lower_address(ctx, v1378, v1377, v2197);
                                    let v2204 = constructor_zext32_mem(ctx, I16, v2198);
                                    let v2205 = constructor_output_reg(ctx, v2204);
                                    let v2206 = Some(v2205);
                                    // Rule at src\isa\s390x\lower.isle line 3291.
                                    return v2206;
                                }
                                let v2207 = C::littleendian(ctx, v1378);
                                if let Some(v2208) = v2207 {
                                    let v2197 = C::zero_offset(ctx);
                                    let v2198 = &constructor_lower_address(ctx, v1378, v1377, v2197);
                                    let v2209 = constructor_loadrev16(ctx, v2198);
                                    let v2210 = constructor_output_reg(ctx, v2209);
                                    let v2211 = Some(v2210);
                                    // Rule at src\isa\s390x\lower.isle line 3295.
                                    return v2211;
                                }
                            }
                            I32 => {
                                let v2202 = C::bigendian(ctx, v1378);
                                if let Some(v2203) = v2202 {
                                    let v2197 = C::zero_offset(ctx);
                                    let v2198 = &constructor_lower_address(ctx, v1378, v1377, v2197);
                                    let v2212 = constructor_load32(ctx, v2198);
                                    let v2213 = constructor_output_reg(ctx, v2212);
                                    let v2214 = Some(v2213);
                                    // Rule at src\isa\s390x\lower.isle line 3299.
                                    return v2214;
                                }
                                let v2207 = C::littleendian(ctx, v1378);
                                if let Some(v2208) = v2207 {
                                    let v2197 = C::zero_offset(ctx);
                                    let v2198 = &constructor_lower_address(ctx, v1378, v1377, v2197);
                                    let v2215 = constructor_loadrev32(ctx, v2198);
                                    let v2216 = constructor_output_reg(ctx, v2215);
                                    let v2217 = Some(v2216);
                                    // Rule at src\isa\s390x\lower.isle line 3303.
                                    return v2217;
                                }
                            }
                            I64 => {
                                let v2202 = C::bigendian(ctx, v1378);
                                if let Some(v2203) = v2202 {
                                    let v2197 = C::zero_offset(ctx);
                                    let v2198 = &constructor_lower_address(ctx, v1378, v1377, v2197);
                                    let v2218 = constructor_load64(ctx, v2198);
                                    let v2219 = constructor_output_reg(ctx, v2218);
                                    let v2220 = Some(v2219);
                                    // Rule at src\isa\s390x\lower.isle line 3307.
                                    return v2220;
                                }
                                let v2207 = C::littleendian(ctx, v1378);
                                if let Some(v2208) = v2207 {
                                    let v2197 = C::zero_offset(ctx);
                                    let v2198 = &constructor_lower_address(ctx, v1378, v1377, v2197);
                                    let v2221 = constructor_loadrev64(ctx, v2198);
                                    let v2222 = constructor_output_reg(ctx, v2221);
                                    let v2223 = Some(v2222);
                                    // Rule at src\isa\s390x\lower.isle line 3311.
                                    return v2223;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::MultiAry {
            opcode: ref v2571,
            args: v2572,
        } => {
            if let &Opcode::Return = v2571 {
                let v2573 = C::value_list_slice(ctx, v2572);
                let v2574 = constructor_lower_return(ctx, v2573);
                let v2575 = Some(v2574);
                // Rule at src\isa\s390x\lower.isle line 3961.
                return v2575;
            }
        }
        &InstructionData::NullAry {
            opcode: ref v47,
        } => {
            match v47 {
                &Opcode::Debugtrap => {
                    let v2464 = &constructor_debugtrap_impl(ctx);
                    let v2465 = constructor_side_effect(ctx, v2464);
                    let v2466 = Some(v2465);
                    // Rule at src\isa\s390x\lower.isle line 3878.
                    return v2466;
                }
                &Opcode::GetFramePointer => {
                    let v2668 = &C::memarg_frame_pointer_offset(ctx);
                    let v2669 = constructor_load64(ctx, v2668);
                    let v2670 = constructor_output_reg(ctx, v2669);
                    let v2671 = Some(v2670);
                    // Rule at src\isa\s390x\lower.isle line 4082.
                    return v2671;
                }
                &Opcode::GetStackPointer => {
                    let v2665 = constructor_sp(ctx);
                    let v2666 = constructor_output_reg(ctx, v2665);
                    let v2667 = Some(v2666);
                    // Rule at src\isa\s390x\lower.isle line 4079.
                    return v2667;
                }
                &Opcode::GetReturnAddress => {
                    let v2672 = &C::memarg_return_address_offset(ctx);
                    let v2673 = constructor_load64(ctx, v2672);
                    let v2674 = constructor_output_reg(ctx, v2673);
                    let v2675 = Some(v2674);
                    // Rule at src\isa\s390x\lower.isle line 4085.
                    return v2675;
                }
                &Opcode::Nop => {
                    let v48 = C::invalid_reg(ctx);
                    let v49 = constructor_output_reg(ctx, v48);
                    let v50 = Some(v49);
                    // Rule at src\isa\s390x\lower.isle line 50.
                    return v50;
                }
                &Opcode::Fence => {
                    let v2243 = &constructor_fence_impl(ctx);
                    let v2244 = constructor_side_effect(ctx, v2243);
                    let v2245 = Some(v2244);
                    // Rule at src\isa\s390x\lower.isle line 3343.
                    return v2245;
                }
                &Opcode::SequencePoint => {
                    let v2684 = &constructor_s390x_sequence_point(ctx);
                    let v2685 = constructor_side_effect(ctx, v2684);
                    let v2686 = Some(v2685);
                    // Rule at src\isa\s390x\lower.isle line 4096.
                    return v2686;
                }
                _ => {}
            }
        }
        &InstructionData::Shuffle {
            opcode: ref v1591,
            args: ref v1592,
            imm: v1593,
        } => {
            if let &Opcode::Shuffle = v1591 {
                let v1597 = C::u128_from_immediate(ctx, v1593);
                if let Some(v1598) = v1597 {
                    let v1599 = C::shuffle_mask_from_u128(ctx, v1598);
                    match v1599.1 {
                        0xf0f_u16 => {
                            let v1616 = C::u64_pair_split(ctx, v1599.0);
                            let v1619 = C::u32_pair_split(ctx, v1616.0);
                            let v1631 = C::u16_pair_split(ctx, v1619.1);
                            let v1634 = C::u8_pair_split(ctx, v1631.0);
                            match v1634.0 {
                                0x0_u8 => {
                                    if v1634.1 == 0x1_u8 {
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0x2_u8 {
                                            if v1637.1 == 0x3_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                if v1655.0 == 0x4_u8 {
                                                    if v1655.1 == 0x5_u8 {
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0x6_u8 {
                                                            if v1658.1 == 0x7_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                let v1794 = constructor_vec_unpacku_high(ctx, I32X4, v1610);
                                                                let v1795 = constructor_output_reg(ctx, v1794);
                                                                let v1796 = Some(v1795);
                                                                // Rule at src\isa\s390x\lower.isle line 2213.
                                                                return v1796;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x8_u8 => {
                                    if v1634.1 == 0x9_u8 {
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0xa_u8 {
                                            if v1637.1 == 0xb_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                if v1655.0 == 0xc_u8 {
                                                    if v1655.1 == 0xd_u8 {
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0xe_u8 {
                                                            if v1658.1 == 0xf_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                let v1812 = constructor_vec_unpacku_low(ctx, I32X4, v1610);
                                                                let v1813 = constructor_output_reg(ctx, v1812);
                                                                let v1814 = Some(v1813);
                                                                // Rule at src\isa\s390x\lower.isle line 2227.
                                                                return v1814;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x10_u8 => {
                                    if v1634.1 == 0x11_u8 {
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0x12_u8 {
                                            if v1637.1 == 0x13_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                if v1655.0 == 0x14_u8 {
                                                    if v1655.1 == 0x15_u8 {
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0x16_u8 {
                                                            if v1658.1 == 0x17_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                let v1803 = constructor_vec_unpacku_high(ctx, I32X4, v1673);
                                                                let v1804 = constructor_output_reg(ctx, v1803);
                                                                let v1805 = Some(v1804);
                                                                // Rule at src\isa\s390x\lower.isle line 2219.
                                                                return v1805;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x18_u8 => {
                                    if v1634.1 == 0x19_u8 {
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0x1a_u8 {
                                            if v1637.1 == 0x1b_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                if v1655.0 == 0x1c_u8 {
                                                    if v1655.1 == 0x1d_u8 {
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0x1e_u8 {
                                                            if v1658.1 == 0x1f_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                let v1821 = constructor_vec_unpacku_low(ctx, I32X4, v1673);
                                                                let v1822 = constructor_output_reg(ctx, v1821);
                                                                let v1823 = Some(v1822);
                                                                // Rule at src\isa\s390x\lower.isle line 2233.
                                                                return v1823;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        0x3333_u16 => {
                            let v1616 = C::u64_pair_split(ctx, v1599.0);
                            let v1619 = C::u32_pair_split(ctx, v1616.0);
                            let v1622 = C::u16_pair_split(ctx, v1619.0);
                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                            match v1628.0 {
                                0x0_u8 => {
                                    if v1628.1 == 0x1_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0x2_u8 {
                                            if v1637.1 == 0x3_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                if v1649.0 == 0x4_u8 {
                                                    if v1649.1 == 0x5_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0x6_u8 {
                                                            if v1658.1 == 0x7_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                let v1797 = constructor_vec_unpacku_high(ctx, I16X8, v1610);
                                                                let v1798 = constructor_output_reg(ctx, v1797);
                                                                let v1799 = Some(v1798);
                                                                // Rule at src\isa\s390x\lower.isle line 2215.
                                                                return v1799;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x8_u8 => {
                                    if v1628.1 == 0x9_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0xa_u8 {
                                            if v1637.1 == 0xb_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                if v1649.0 == 0xc_u8 {
                                                    if v1649.1 == 0xd_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0xe_u8 {
                                                            if v1658.1 == 0xf_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                let v1815 = constructor_vec_unpacku_low(ctx, I16X8, v1610);
                                                                let v1816 = constructor_output_reg(ctx, v1815);
                                                                let v1817 = Some(v1816);
                                                                // Rule at src\isa\s390x\lower.isle line 2229.
                                                                return v1817;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x10_u8 => {
                                    if v1628.1 == 0x11_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0x12_u8 {
                                            if v1637.1 == 0x13_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                if v1649.0 == 0x14_u8 {
                                                    if v1649.1 == 0x15_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0x16_u8 {
                                                            if v1658.1 == 0x17_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                let v1806 = constructor_vec_unpacku_high(ctx, I16X8, v1673);
                                                                let v1807 = constructor_output_reg(ctx, v1806);
                                                                let v1808 = Some(v1807);
                                                                // Rule at src\isa\s390x\lower.isle line 2221.
                                                                return v1808;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x18_u8 => {
                                    if v1628.1 == 0x19_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                        if v1637.0 == 0x1a_u8 {
                                            if v1637.1 == 0x1b_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                if v1649.0 == 0x1c_u8 {
                                                    if v1649.1 == 0x1d_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                        if v1658.0 == 0x1e_u8 {
                                                            if v1658.1 == 0x1f_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                let v1824 = constructor_vec_unpacku_low(ctx, I16X8, v1673);
                                                                let v1825 = constructor_output_reg(ctx, v1824);
                                                                let v1826 = Some(v1825);
                                                                // Rule at src\isa\s390x\lower.isle line 2235.
                                                                return v1826;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        0x5555_u16 => {
                            let v1616 = C::u64_pair_split(ctx, v1599.0);
                            let v1619 = C::u32_pair_split(ctx, v1616.0);
                            let v1622 = C::u16_pair_split(ctx, v1619.0);
                            let v1625 = C::u8_pair_split(ctx, v1622.0);
                            match v1625.1 {
                                0x0_u8 => {
                                    let v1628 = C::u8_pair_split(ctx, v1622.1);
                                    if v1628.1 == 0x1_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                        if v1634.1 == 0x2_u8 {
                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                            if v1637.1 == 0x3_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                if v1646.1 == 0x4_u8 {
                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                    if v1649.1 == 0x5_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                        if v1655.1 == 0x6_u8 {
                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                            if v1658.1 == 0x7_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                let v1800 = constructor_vec_unpacku_high(ctx, I8X16, v1610);
                                                                let v1801 = constructor_output_reg(ctx, v1800);
                                                                let v1802 = Some(v1801);
                                                                // Rule at src\isa\s390x\lower.isle line 2217.
                                                                return v1802;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x8_u8 => {
                                    let v1628 = C::u8_pair_split(ctx, v1622.1);
                                    if v1628.1 == 0x9_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                        if v1634.1 == 0xa_u8 {
                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                            if v1637.1 == 0xb_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                if v1646.1 == 0xc_u8 {
                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                    if v1649.1 == 0xd_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                        if v1655.1 == 0xe_u8 {
                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                            if v1658.1 == 0xf_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                let v1818 = constructor_vec_unpacku_low(ctx, I8X16, v1610);
                                                                let v1819 = constructor_output_reg(ctx, v1818);
                                                                let v1820 = Some(v1819);
                                                                // Rule at src\isa\s390x\lower.isle line 2231.
                                                                return v1820;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x10_u8 => {
                                    let v1628 = C::u8_pair_split(ctx, v1622.1);
                                    if v1628.1 == 0x11_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                        if v1634.1 == 0x12_u8 {
                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                            if v1637.1 == 0x13_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                if v1646.1 == 0x14_u8 {
                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                    if v1649.1 == 0x15_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                        if v1655.1 == 0x16_u8 {
                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                            if v1658.1 == 0x17_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                let v1809 = constructor_vec_unpacku_high(ctx, I8X16, v1673);
                                                                let v1810 = constructor_output_reg(ctx, v1809);
                                                                let v1811 = Some(v1810);
                                                                // Rule at src\isa\s390x\lower.isle line 2223.
                                                                return v1811;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x18_u8 => {
                                    let v1628 = C::u8_pair_split(ctx, v1622.1);
                                    if v1628.1 == 0x19_u8 {
                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                        if v1634.1 == 0x1a_u8 {
                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                            if v1637.1 == 0x1b_u8 {
                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                if v1646.1 == 0x1c_u8 {
                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                    if v1649.1 == 0x1d_u8 {
                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                        if v1655.1 == 0x1e_u8 {
                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                            if v1658.1 == 0x1f_u8 {
                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                let v1827 = constructor_vec_unpacku_low(ctx, I8X16, v1673);
                                                                let v1828 = constructor_output_reg(ctx, v1827);
                                                                let v1829 = Some(v1828);
                                                                // Rule at src\isa\s390x\lower.isle line 2237.
                                                                return v1829;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        0xffff_u16 => {
                            let v1616 = C::u64_pair_split(ctx, v1599.0);
                            let v1619 = C::u32_pair_split(ctx, v1616.0);
                            let v1622 = C::u16_pair_split(ctx, v1619.0);
                            let v1625 = C::u8_pair_split(ctx, v1622.0);
                            match v1625.0 {
                                0x0_u8 => {
                                    match v1625.1 {
                                        0x0_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x1_u8 {
                                                if v1628.1 == 0x1_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0x2_u8 {
                                                        if v1634.1 == 0x2_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0x3_u8 {
                                                                if v1637.1 == 0x3_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0x4_u8 {
                                                                        if v1646.1 == 0x4_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x5_u8 {
                                                                                if v1649.1 == 0x5_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x6_u8 {
                                                                                        if v1655.1 == 0x6_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x7_u8 {
                                                                                                if v1658.1 == 0x7_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1695 = constructor_vec_merge_high(ctx, I8X16, v1610, v1603);
                                                                                                    let v1696 = constructor_output_reg(ctx, v1695);
                                                                                                    let v1697 = Some(v1696);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2141.
                                                                                                    return v1697;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        0x1_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            match v1628.0 {
                                                0x0_u8 => {
                                                    if v1628.1 == 0x1_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0x2_u8 {
                                                            if v1634.1 == 0x3_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0x2_u8 {
                                                                    if v1637.1 == 0x3_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0x4_u8 {
                                                                            if v1646.1 == 0x5_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0x4_u8 {
                                                                                    if v1649.1 == 0x5_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0x6_u8 {
                                                                                            if v1655.1 == 0x7_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0x6_u8 {
                                                                                                    if v1658.1 == 0x7_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1692 = constructor_vec_merge_high(ctx, I16X8, v1610, v1603);
                                                                                                        let v1693 = constructor_output_reg(ctx, v1692);
                                                                                                        let v1694 = Some(v1693);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2139.
                                                                                                        return v1694;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0x2_u8 => {
                                                    if v1628.1 == 0x3_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        match v1634.0 {
                                                            0x0_u8 => {
                                                                if v1634.1 == 0x1_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x2_u8 {
                                                                        if v1637.1 == 0x3_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0x4_u8 {
                                                                                if v1646.1 == 0x5_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0x6_u8 {
                                                                                        if v1649.1 == 0x7_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0x4_u8 {
                                                                                                if v1655.1 == 0x5_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0x6_u8 {
                                                                                                        if v1658.1 == 0x7_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1689 = constructor_vec_merge_high(ctx, I32X4, v1610, v1603);
                                                                                                            let v1690 = constructor_output_reg(ctx, v1689);
                                                                                                            let v1691 = Some(v1690);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2137.
                                                                                                            return v1691;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0x4_u8 => {
                                                                if v1634.1 == 0x5_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x6_u8 {
                                                                        if v1637.1 == 0x7_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            match v1646.0 {
                                                                                0x0_u8 => {
                                                                                    if v1646.1 == 0x1_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x2_u8 {
                                                                                            if v1649.1 == 0x3_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x4_u8 {
                                                                                                    if v1655.1 == 0x5_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x6_u8 {
                                                                                                            if v1658.1 == 0x7_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1686 = constructor_vec_merge_high(ctx, I64X2, v1610, v1603);
                                                                                                                let v1687 = constructor_output_reg(ctx, v1686);
                                                                                                                let v1688 = Some(v1687);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2135.
                                                                                                                return v1688;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x8_u8 => {
                                                                                    if v1646.1 == 0x9_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0xa_u8 {
                                                                                            if v1649.1 == 0xb_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0xc_u8 {
                                                                                                    if v1655.1 == 0xd_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0xe_u8 {
                                                                                                            if v1658.1 == 0xf_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1842 = constructor_vec_permute_dw_imm(ctx, I8X16, v1610, 0x0_u8, v1603, 0x1_u8);
                                                                                                                let v1843 = constructor_output_reg(ctx, v1842);
                                                                                                                let v1844 = Some(v1843);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2249.
                                                                                                                return v1844;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x10_u8 => {
                                                                                    if v1646.1 == 0x11_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x12_u8 {
                                                                                            if v1649.1 == 0x13_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x14_u8 {
                                                                                                    if v1655.1 == 0x15_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x16_u8 {
                                                                                                            if v1658.1 == 0x17_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1661 = constructor_vec_merge_high(ctx, I64X2, v1610, v1611);
                                                                                                                let v1662 = constructor_output_reg(ctx, v1661);
                                                                                                                let v1663 = Some(v1662);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2119.
                                                                                                                return v1663;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x18_u8 => {
                                                                                    if v1646.1 == 0x19_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x1a_u8 {
                                                                                            if v1649.1 == 0x1b_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x1c_u8 {
                                                                                                    if v1655.1 == 0x1d_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x1e_u8 {
                                                                                                            if v1658.1 == 0x1f_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1830 = constructor_vec_permute_dw_imm(ctx, I8X16, v1610, 0x0_u8, v1611, 0x1_u8);
                                                                                                                let v1831 = constructor_output_reg(ctx, v1830);
                                                                                                                let v1832 = Some(v1831);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2241.
                                                                                                                return v1832;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                _ => {}
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0x10_u8 => {
                                                                if v1634.1 == 0x11_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x12_u8 {
                                                                        if v1637.1 == 0x13_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0x4_u8 {
                                                                                if v1646.1 == 0x5_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0x6_u8 {
                                                                                        if v1649.1 == 0x7_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0x14_u8 {
                                                                                                if v1655.1 == 0x15_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0x16_u8 {
                                                                                                        if v1658.1 == 0x17_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1664 = constructor_vec_merge_high(ctx, I32X4, v1610, v1611);
                                                                                                            let v1665 = constructor_output_reg(ctx, v1664);
                                                                                                            let v1666 = Some(v1665);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2121.
                                                                                                            return v1666;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                0x10_u8 => {
                                                    if v1628.1 == 0x11_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0x2_u8 {
                                                            if v1634.1 == 0x3_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0x12_u8 {
                                                                    if v1637.1 == 0x13_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0x4_u8 {
                                                                            if v1646.1 == 0x5_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0x14_u8 {
                                                                                    if v1649.1 == 0x15_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0x6_u8 {
                                                                                            if v1655.1 == 0x7_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0x16_u8 {
                                                                                                    if v1658.1 == 0x17_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1667 = constructor_vec_merge_high(ctx, I16X8, v1610, v1611);
                                                                                                        let v1668 = constructor_output_reg(ctx, v1667);
                                                                                                        let v1669 = Some(v1668);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2123.
                                                                                                        return v1669;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        0x10_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x1_u8 {
                                                if v1628.1 == 0x11_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0x2_u8 {
                                                        if v1634.1 == 0x12_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0x3_u8 {
                                                                if v1637.1 == 0x13_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0x4_u8 {
                                                                        if v1646.1 == 0x14_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x5_u8 {
                                                                                if v1649.1 == 0x15_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x6_u8 {
                                                                                        if v1655.1 == 0x16_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x7_u8 {
                                                                                                if v1658.1 == 0x17_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1670 = constructor_vec_merge_high(ctx, I8X16, v1610, v1611);
                                                                                                    let v1671 = constructor_output_reg(ctx, v1670);
                                                                                                    let v1672 = Some(v1671);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2125.
                                                                                                    return v1672;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                0x1_u8 => {
                                    if v1625.1 == 0x3_u8 {
                                        let v1628 = C::u8_pair_split(ctx, v1622.1);
                                        if v1628.0 == 0x5_u8 {
                                            if v1628.1 == 0x7_u8 {
                                                let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                if v1634.0 == 0x9_u8 {
                                                    if v1634.1 == 0xb_u8 {
                                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                        if v1637.0 == 0xd_u8 {
                                                            if v1637.1 == 0xf_u8 {
                                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                match v1646.0 {
                                                                    0x1_u8 => {
                                                                        if v1646.1 == 0x3_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x5_u8 {
                                                                                if v1649.1 == 0x7_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x9_u8 {
                                                                                        if v1655.1 == 0xb_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xd_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1782 = constructor_vec_pack(ctx, I16X8, v1610, v1603);
                                                                                                    let v1783 = constructor_output_reg(ctx, v1782);
                                                                                                    let v1784 = Some(v1783);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2203.
                                                                                                    return v1784;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    0x11_u8 => {
                                                                        if v1646.1 == 0x13_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x15_u8 {
                                                                                if v1649.1 == 0x17_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x19_u8 {
                                                                                        if v1655.1 == 0x1b_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1d_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1764 = constructor_vec_pack(ctx, I16X8, v1610, v1611);
                                                                                                    let v1765 = constructor_output_reg(ctx, v1764);
                                                                                                    let v1766 = Some(v1765);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2191.
                                                                                                    return v1766;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x2_u8 => {
                                    if v1625.1 == 0x3_u8 {
                                        let v1628 = C::u8_pair_split(ctx, v1622.1);
                                        if v1628.0 == 0x6_u8 {
                                            if v1628.1 == 0x7_u8 {
                                                let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                if v1634.0 == 0xa_u8 {
                                                    if v1634.1 == 0xb_u8 {
                                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                        if v1637.0 == 0xe_u8 {
                                                            if v1637.1 == 0xf_u8 {
                                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                match v1646.0 {
                                                                    0x2_u8 => {
                                                                        if v1646.1 == 0x3_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x6_u8 {
                                                                                if v1649.1 == 0x7_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0xa_u8 {
                                                                                        if v1655.1 == 0xb_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xe_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1779 = constructor_vec_pack(ctx, I32X4, v1610, v1603);
                                                                                                    let v1780 = constructor_output_reg(ctx, v1779);
                                                                                                    let v1781 = Some(v1780);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2201.
                                                                                                    return v1781;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    0x12_u8 => {
                                                                        if v1646.1 == 0x13_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x16_u8 {
                                                                                if v1649.1 == 0x17_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x1a_u8 {
                                                                                        if v1655.1 == 0x1b_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1e_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1761 = constructor_vec_pack(ctx, I32X4, v1610, v1611);
                                                                                                    let v1762 = constructor_output_reg(ctx, v1761);
                                                                                                    let v1763 = Some(v1762);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2189.
                                                                                                    return v1763;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x4_u8 => {
                                    if v1625.1 == 0x5_u8 {
                                        let v1628 = C::u8_pair_split(ctx, v1622.1);
                                        if v1628.0 == 0x6_u8 {
                                            if v1628.1 == 0x7_u8 {
                                                let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                if v1634.0 == 0xc_u8 {
                                                    if v1634.1 == 0xd_u8 {
                                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                        if v1637.0 == 0xe_u8 {
                                                            if v1637.1 == 0xf_u8 {
                                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                match v1646.0 {
                                                                    0x4_u8 => {
                                                                        if v1646.1 == 0x5_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x6_u8 {
                                                                                if v1649.1 == 0x7_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0xc_u8 {
                                                                                        if v1655.1 == 0xd_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xe_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1776 = constructor_vec_pack(ctx, I64X2, v1610, v1603);
                                                                                                    let v1777 = constructor_output_reg(ctx, v1776);
                                                                                                    let v1778 = Some(v1777);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2199.
                                                                                                    return v1778;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    0x14_u8 => {
                                                                        if v1646.1 == 0x15_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x16_u8 {
                                                                                if v1649.1 == 0x17_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x1c_u8 {
                                                                                        if v1655.1 == 0x1d_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1e_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1758 = constructor_vec_pack(ctx, I64X2, v1610, v1611);
                                                                                                    let v1759 = constructor_output_reg(ctx, v1758);
                                                                                                    let v1760 = Some(v1759);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2187.
                                                                                                    return v1760;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x8_u8 => {
                                    match v1625.1 {
                                        0x8_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x9_u8 {
                                                if v1628.1 == 0x9_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0xa_u8 {
                                                        if v1634.1 == 0xa_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0xb_u8 {
                                                                if v1637.1 == 0xb_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0xc_u8 {
                                                                        if v1646.1 == 0xc_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0xd_u8 {
                                                                                if v1649.1 == 0xd_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0xe_u8 {
                                                                                        if v1655.1 == 0xe_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xf_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1743 = constructor_vec_merge_low(ctx, I8X16, v1610, v1603);
                                                                                                    let v1744 = constructor_output_reg(ctx, v1743);
                                                                                                    let v1745 = Some(v1744);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2175.
                                                                                                    return v1745;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        0x9_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            match v1628.0 {
                                                0x8_u8 => {
                                                    if v1628.1 == 0x9_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0xa_u8 {
                                                            if v1634.1 == 0xb_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0xa_u8 {
                                                                    if v1637.1 == 0xb_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0xc_u8 {
                                                                            if v1646.1 == 0xd_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0xc_u8 {
                                                                                    if v1649.1 == 0xd_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0xe_u8 {
                                                                                            if v1655.1 == 0xf_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0xe_u8 {
                                                                                                    if v1658.1 == 0xf_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1740 = constructor_vec_merge_low(ctx, I16X8, v1610, v1603);
                                                                                                        let v1741 = constructor_output_reg(ctx, v1740);
                                                                                                        let v1742 = Some(v1741);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2173.
                                                                                                        return v1742;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0xa_u8 => {
                                                    if v1628.1 == 0xb_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        match v1634.0 {
                                                            0x8_u8 => {
                                                                if v1634.1 == 0x9_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0xa_u8 {
                                                                        if v1637.1 == 0xb_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0xc_u8 {
                                                                                if v1646.1 == 0xd_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0xe_u8 {
                                                                                        if v1649.1 == 0xf_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0xc_u8 {
                                                                                                if v1655.1 == 0xd_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0xe_u8 {
                                                                                                        if v1658.1 == 0xf_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1737 = constructor_vec_merge_low(ctx, I32X4, v1610, v1603);
                                                                                                            let v1738 = constructor_output_reg(ctx, v1737);
                                                                                                            let v1739 = Some(v1738);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2171.
                                                                                                            return v1739;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0xc_u8 => {
                                                                if v1634.1 == 0xd_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0xe_u8 {
                                                                        if v1637.1 == 0xf_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            match v1646.0 {
                                                                                0x0_u8 => {
                                                                                    if v1646.1 == 0x1_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x2_u8 {
                                                                                            if v1649.1 == 0x3_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x4_u8 {
                                                                                                    if v1655.1 == 0x5_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x6_u8 {
                                                                                                            if v1658.1 == 0x7_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1845 = constructor_vec_permute_dw_imm(ctx, I8X16, v1610, 0x1_u8, v1603, 0x0_u8);
                                                                                                                let v1846 = constructor_output_reg(ctx, v1845);
                                                                                                                let v1847 = Some(v1846);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2251.
                                                                                                                return v1847;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x8_u8 => {
                                                                                    if v1646.1 == 0x9_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0xa_u8 {
                                                                                            if v1649.1 == 0xb_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0xc_u8 {
                                                                                                    if v1655.1 == 0xd_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0xe_u8 {
                                                                                                            if v1658.1 == 0xf_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1734 = constructor_vec_merge_low(ctx, I64X2, v1610, v1603);
                                                                                                                let v1735 = constructor_output_reg(ctx, v1734);
                                                                                                                let v1736 = Some(v1735);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2169.
                                                                                                                return v1736;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x10_u8 => {
                                                                                    if v1646.1 == 0x11_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x12_u8 {
                                                                                            if v1649.1 == 0x13_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x14_u8 {
                                                                                                    if v1655.1 == 0x15_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x16_u8 {
                                                                                                            if v1658.1 == 0x17_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1833 = constructor_vec_permute_dw_imm(ctx, I8X16, v1610, 0x1_u8, v1611, 0x0_u8);
                                                                                                                let v1834 = constructor_output_reg(ctx, v1833);
                                                                                                                let v1835 = Some(v1834);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2243.
                                                                                                                return v1835;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x18_u8 => {
                                                                                    if v1646.1 == 0x19_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x1a_u8 {
                                                                                            if v1649.1 == 0x1b_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x1c_u8 {
                                                                                                    if v1655.1 == 0x1d_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x1e_u8 {
                                                                                                            if v1658.1 == 0x1f_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1710 = constructor_vec_merge_low(ctx, I64X2, v1610, v1611);
                                                                                                                let v1711 = constructor_output_reg(ctx, v1710);
                                                                                                                let v1712 = Some(v1711);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2153.
                                                                                                                return v1712;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                _ => {}
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0x18_u8 => {
                                                                if v1634.1 == 0x19_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x1a_u8 {
                                                                        if v1637.1 == 0x1b_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0xc_u8 {
                                                                                if v1646.1 == 0xd_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0xe_u8 {
                                                                                        if v1649.1 == 0xf_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0x1c_u8 {
                                                                                                if v1655.1 == 0x1d_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0x1e_u8 {
                                                                                                        if v1658.1 == 0x1f_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1713 = constructor_vec_merge_low(ctx, I32X4, v1610, v1611);
                                                                                                            let v1714 = constructor_output_reg(ctx, v1713);
                                                                                                            let v1715 = Some(v1714);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2155.
                                                                                                            return v1715;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                0x18_u8 => {
                                                    if v1628.1 == 0x19_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0xa_u8 {
                                                            if v1634.1 == 0xb_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0x1a_u8 {
                                                                    if v1637.1 == 0x1b_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0xc_u8 {
                                                                            if v1646.1 == 0xd_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0x1c_u8 {
                                                                                    if v1649.1 == 0x1d_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0xe_u8 {
                                                                                            if v1655.1 == 0xf_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0x1e_u8 {
                                                                                                    if v1658.1 == 0x1f_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1716 = constructor_vec_merge_low(ctx, I16X8, v1610, v1611);
                                                                                                        let v1717 = constructor_output_reg(ctx, v1716);
                                                                                                        let v1718 = Some(v1717);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2157.
                                                                                                        return v1718;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        0x18_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x9_u8 {
                                                if v1628.1 == 0x19_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0xa_u8 {
                                                        if v1634.1 == 0x1a_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0xb_u8 {
                                                                if v1637.1 == 0x1b_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0xc_u8 {
                                                                        if v1646.1 == 0x1c_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0xd_u8 {
                                                                                if v1649.1 == 0x1d_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0xe_u8 {
                                                                                        if v1655.1 == 0x1e_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xf_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1610 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1719 = constructor_vec_merge_low(ctx, I8X16, v1610, v1611);
                                                                                                    let v1720 = constructor_output_reg(ctx, v1719);
                                                                                                    let v1721 = Some(v1720);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2159.
                                                                                                    return v1721;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                0x10_u8 => {
                                    match v1625.1 {
                                        0x0_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x11_u8 {
                                                if v1628.1 == 0x1_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0x12_u8 {
                                                        if v1634.1 == 0x2_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0x13_u8 {
                                                                if v1637.1 == 0x3_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0x14_u8 {
                                                                        if v1646.1 == 0x4_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x15_u8 {
                                                                                if v1649.1 == 0x5_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x16_u8 {
                                                                                        if v1655.1 == 0x6_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x17_u8 {
                                                                                                if v1658.1 == 0x7_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1683 = constructor_vec_merge_high(ctx, I8X16, v1673, v1603);
                                                                                                    let v1684 = constructor_output_reg(ctx, v1683);
                                                                                                    let v1685 = Some(v1684);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2133.
                                                                                                    return v1685;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        0x10_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x11_u8 {
                                                if v1628.1 == 0x11_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0x12_u8 {
                                                        if v1634.1 == 0x12_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0x13_u8 {
                                                                if v1637.1 == 0x13_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0x14_u8 {
                                                                        if v1646.1 == 0x14_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x15_u8 {
                                                                                if v1649.1 == 0x15_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x16_u8 {
                                                                                        if v1655.1 == 0x16_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x17_u8 {
                                                                                                if v1658.1 == 0x17_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1707 = constructor_vec_merge_high(ctx, I8X16, v1673, v1611);
                                                                                                    let v1708 = constructor_output_reg(ctx, v1707);
                                                                                                    let v1709 = Some(v1708);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2149.
                                                                                                    return v1709;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        0x11_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            match v1628.0 {
                                                0x0_u8 => {
                                                    if v1628.1 == 0x1_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0x12_u8 {
                                                            if v1634.1 == 0x13_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0x2_u8 {
                                                                    if v1637.1 == 0x3_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0x14_u8 {
                                                                            if v1646.1 == 0x15_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0x4_u8 {
                                                                                    if v1649.1 == 0x5_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0x16_u8 {
                                                                                            if v1655.1 == 0x17_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0x6_u8 {
                                                                                                    if v1658.1 == 0x7_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1680 = constructor_vec_merge_high(ctx, I16X8, v1673, v1603);
                                                                                                        let v1681 = constructor_output_reg(ctx, v1680);
                                                                                                        let v1682 = Some(v1681);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2131.
                                                                                                        return v1682;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0x10_u8 => {
                                                    if v1628.1 == 0x11_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0x12_u8 {
                                                            if v1634.1 == 0x13_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0x12_u8 {
                                                                    if v1637.1 == 0x13_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0x14_u8 {
                                                                            if v1646.1 == 0x15_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0x14_u8 {
                                                                                    if v1649.1 == 0x15_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0x16_u8 {
                                                                                            if v1655.1 == 0x17_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0x16_u8 {
                                                                                                    if v1658.1 == 0x17_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1704 = constructor_vec_merge_high(ctx, I16X8, v1673, v1611);
                                                                                                        let v1705 = constructor_output_reg(ctx, v1704);
                                                                                                        let v1706 = Some(v1705);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2147.
                                                                                                        return v1706;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0x12_u8 => {
                                                    if v1628.1 == 0x13_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        match v1634.0 {
                                                            0x0_u8 => {
                                                                if v1634.1 == 0x1_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x2_u8 {
                                                                        if v1637.1 == 0x3_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0x14_u8 {
                                                                                if v1646.1 == 0x15_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0x16_u8 {
                                                                                        if v1649.1 == 0x17_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0x4_u8 {
                                                                                                if v1655.1 == 0x5_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0x6_u8 {
                                                                                                        if v1658.1 == 0x7_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1677 = constructor_vec_merge_high(ctx, I32X4, v1673, v1603);
                                                                                                            let v1678 = constructor_output_reg(ctx, v1677);
                                                                                                            let v1679 = Some(v1678);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2129.
                                                                                                            return v1679;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0x10_u8 => {
                                                                if v1634.1 == 0x11_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x12_u8 {
                                                                        if v1637.1 == 0x13_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0x14_u8 {
                                                                                if v1646.1 == 0x15_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0x16_u8 {
                                                                                        if v1649.1 == 0x17_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0x14_u8 {
                                                                                                if v1655.1 == 0x15_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0x16_u8 {
                                                                                                        if v1658.1 == 0x17_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1701 = constructor_vec_merge_high(ctx, I32X4, v1673, v1611);
                                                                                                            let v1702 = constructor_output_reg(ctx, v1701);
                                                                                                            let v1703 = Some(v1702);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2145.
                                                                                                            return v1703;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0x14_u8 => {
                                                                if v1634.1 == 0x15_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x16_u8 {
                                                                        if v1637.1 == 0x17_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            match v1646.0 {
                                                                                0x0_u8 => {
                                                                                    if v1646.1 == 0x1_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x2_u8 {
                                                                                            if v1649.1 == 0x3_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x4_u8 {
                                                                                                    if v1655.1 == 0x5_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x6_u8 {
                                                                                                            if v1658.1 == 0x7_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1674 = constructor_vec_merge_high(ctx, I64X2, v1673, v1603);
                                                                                                                let v1675 = constructor_output_reg(ctx, v1674);
                                                                                                                let v1676 = Some(v1675);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2127.
                                                                                                                return v1676;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x8_u8 => {
                                                                                    if v1646.1 == 0x9_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0xa_u8 {
                                                                                            if v1649.1 == 0xb_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0xc_u8 {
                                                                                                    if v1655.1 == 0xd_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0xe_u8 {
                                                                                                            if v1658.1 == 0xf_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1836 = constructor_vec_permute_dw_imm(ctx, I8X16, v1673, 0x0_u8, v1603, 0x1_u8);
                                                                                                                let v1837 = constructor_output_reg(ctx, v1836);
                                                                                                                let v1838 = Some(v1837);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2245.
                                                                                                                return v1838;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x10_u8 => {
                                                                                    if v1646.1 == 0x11_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x12_u8 {
                                                                                            if v1649.1 == 0x13_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x14_u8 {
                                                                                                    if v1655.1 == 0x15_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x16_u8 {
                                                                                                            if v1658.1 == 0x17_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1698 = constructor_vec_merge_high(ctx, I64X2, v1673, v1611);
                                                                                                                let v1699 = constructor_output_reg(ctx, v1698);
                                                                                                                let v1700 = Some(v1699);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2143.
                                                                                                                return v1700;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x18_u8 => {
                                                                                    if v1646.1 == 0x19_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x1a_u8 {
                                                                                            if v1649.1 == 0x1b_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x1c_u8 {
                                                                                                    if v1655.1 == 0x1d_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x1e_u8 {
                                                                                                            if v1658.1 == 0x1f_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1848 = constructor_vec_permute_dw_imm(ctx, I8X16, v1673, 0x0_u8, v1611, 0x1_u8);
                                                                                                                let v1849 = constructor_output_reg(ctx, v1848);
                                                                                                                let v1850 = Some(v1849);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2253.
                                                                                                                return v1850;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                _ => {}
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                0x11_u8 => {
                                    if v1625.1 == 0x13_u8 {
                                        let v1628 = C::u8_pair_split(ctx, v1622.1);
                                        if v1628.0 == 0x15_u8 {
                                            if v1628.1 == 0x17_u8 {
                                                let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                if v1634.0 == 0x19_u8 {
                                                    if v1634.1 == 0x1b_u8 {
                                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                        if v1637.0 == 0x1d_u8 {
                                                            if v1637.1 == 0x1f_u8 {
                                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                match v1646.0 {
                                                                    0x1_u8 => {
                                                                        if v1646.1 == 0x3_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x5_u8 {
                                                                                if v1649.1 == 0x7_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x9_u8 {
                                                                                        if v1655.1 == 0xb_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xd_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1773 = constructor_vec_pack(ctx, I16X8, v1673, v1603);
                                                                                                    let v1774 = constructor_output_reg(ctx, v1773);
                                                                                                    let v1775 = Some(v1774);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2197.
                                                                                                    return v1775;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    0x11_u8 => {
                                                                        if v1646.1 == 0x13_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x15_u8 {
                                                                                if v1649.1 == 0x17_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x19_u8 {
                                                                                        if v1655.1 == 0x1b_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1d_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1791 = constructor_vec_pack(ctx, I16X8, v1673, v1611);
                                                                                                    let v1792 = constructor_output_reg(ctx, v1791);
                                                                                                    let v1793 = Some(v1792);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2209.
                                                                                                    return v1793;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x12_u8 => {
                                    if v1625.1 == 0x13_u8 {
                                        let v1628 = C::u8_pair_split(ctx, v1622.1);
                                        if v1628.0 == 0x16_u8 {
                                            if v1628.1 == 0x17_u8 {
                                                let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                if v1634.0 == 0x1a_u8 {
                                                    if v1634.1 == 0x1b_u8 {
                                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                        if v1637.0 == 0x1e_u8 {
                                                            if v1637.1 == 0x1f_u8 {
                                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                match v1646.0 {
                                                                    0x2_u8 => {
                                                                        if v1646.1 == 0x3_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x6_u8 {
                                                                                if v1649.1 == 0x7_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0xa_u8 {
                                                                                        if v1655.1 == 0xb_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xe_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1770 = constructor_vec_pack(ctx, I32X4, v1673, v1603);
                                                                                                    let v1771 = constructor_output_reg(ctx, v1770);
                                                                                                    let v1772 = Some(v1771);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2195.
                                                                                                    return v1772;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    0x12_u8 => {
                                                                        if v1646.1 == 0x13_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x16_u8 {
                                                                                if v1649.1 == 0x17_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x1a_u8 {
                                                                                        if v1655.1 == 0x1b_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1e_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1788 = constructor_vec_pack(ctx, I32X4, v1673, v1611);
                                                                                                    let v1789 = constructor_output_reg(ctx, v1788);
                                                                                                    let v1790 = Some(v1789);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2207.
                                                                                                    return v1790;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x14_u8 => {
                                    if v1625.1 == 0x15_u8 {
                                        let v1628 = C::u8_pair_split(ctx, v1622.1);
                                        if v1628.0 == 0x16_u8 {
                                            if v1628.1 == 0x17_u8 {
                                                let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                if v1634.0 == 0x1c_u8 {
                                                    if v1634.1 == 0x1d_u8 {
                                                        let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                        if v1637.0 == 0x1e_u8 {
                                                            if v1637.1 == 0x1f_u8 {
                                                                let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                match v1646.0 {
                                                                    0x4_u8 => {
                                                                        if v1646.1 == 0x5_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x6_u8 {
                                                                                if v1649.1 == 0x7_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0xc_u8 {
                                                                                        if v1655.1 == 0xd_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0xe_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1767 = constructor_vec_pack(ctx, I64X2, v1673, v1603);
                                                                                                    let v1768 = constructor_output_reg(ctx, v1767);
                                                                                                    let v1769 = Some(v1768);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2193.
                                                                                                    return v1769;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    0x14_u8 => {
                                                                        if v1646.1 == 0x15_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x16_u8 {
                                                                                if v1649.1 == 0x17_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x1c_u8 {
                                                                                        if v1655.1 == 0x1d_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1e_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1785 = constructor_vec_pack(ctx, I64X2, v1673, v1611);
                                                                                                    let v1786 = constructor_output_reg(ctx, v1785);
                                                                                                    let v1787 = Some(v1786);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2205.
                                                                                                    return v1787;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    _ => {}
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                0x18_u8 => {
                                    match v1625.1 {
                                        0x8_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x19_u8 {
                                                if v1628.1 == 0x9_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0x1a_u8 {
                                                        if v1634.1 == 0xa_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0x1b_u8 {
                                                                if v1637.1 == 0xb_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0x1c_u8 {
                                                                        if v1646.1 == 0xc_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x1d_u8 {
                                                                                if v1649.1 == 0xd_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x1e_u8 {
                                                                                        if v1655.1 == 0xe_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1f_u8 {
                                                                                                if v1658.1 == 0xf_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                    let v1731 = constructor_vec_merge_low(ctx, I8X16, v1673, v1603);
                                                                                                    let v1732 = constructor_output_reg(ctx, v1731);
                                                                                                    let v1733 = Some(v1732);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2167.
                                                                                                    return v1733;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        0x18_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            if v1628.0 == 0x19_u8 {
                                                if v1628.1 == 0x19_u8 {
                                                    let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                    let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                    if v1634.0 == 0x1a_u8 {
                                                        if v1634.1 == 0x1a_u8 {
                                                            let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                            if v1637.0 == 0x1b_u8 {
                                                                if v1637.1 == 0x1b_u8 {
                                                                    let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                    let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                    let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                    if v1646.0 == 0x1c_u8 {
                                                                        if v1646.1 == 0x1c_u8 {
                                                                            let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                            if v1649.0 == 0x1d_u8 {
                                                                                if v1649.1 == 0x1d_u8 {
                                                                                    let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                    let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                    if v1655.0 == 0x1e_u8 {
                                                                                        if v1655.1 == 0x1e_u8 {
                                                                                            let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                            if v1658.0 == 0x1f_u8 {
                                                                                                if v1658.1 == 0x1f_u8 {
                                                                                                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                    let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                    let v1755 = constructor_vec_merge_low(ctx, I8X16, v1673, v1611);
                                                                                                    let v1756 = constructor_output_reg(ctx, v1755);
                                                                                                    let v1757 = Some(v1756);
                                                                                                    // Rule at src\isa\s390x\lower.isle line 2183.
                                                                                                    return v1757;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        0x19_u8 => {
                                            let v1628 = C::u8_pair_split(ctx, v1622.1);
                                            match v1628.0 {
                                                0x8_u8 => {
                                                    if v1628.1 == 0x9_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0x1a_u8 {
                                                            if v1634.1 == 0x1b_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0xa_u8 {
                                                                    if v1637.1 == 0xb_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0x1c_u8 {
                                                                            if v1646.1 == 0x1d_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0xc_u8 {
                                                                                    if v1649.1 == 0xd_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0x1e_u8 {
                                                                                            if v1655.1 == 0x1f_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0xe_u8 {
                                                                                                    if v1658.1 == 0xf_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                        let v1728 = constructor_vec_merge_low(ctx, I16X8, v1673, v1603);
                                                                                                        let v1729 = constructor_output_reg(ctx, v1728);
                                                                                                        let v1730 = Some(v1729);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2165.
                                                                                                        return v1730;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0x18_u8 => {
                                                    if v1628.1 == 0x19_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        if v1634.0 == 0x1a_u8 {
                                                            if v1634.1 == 0x1b_u8 {
                                                                let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                if v1637.0 == 0x1a_u8 {
                                                                    if v1637.1 == 0x1b_u8 {
                                                                        let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                        let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                        let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                        if v1646.0 == 0x1c_u8 {
                                                                            if v1646.1 == 0x1d_u8 {
                                                                                let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                if v1649.0 == 0x1c_u8 {
                                                                                    if v1649.1 == 0x1d_u8 {
                                                                                        let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                        let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                        if v1655.0 == 0x1e_u8 {
                                                                                            if v1655.1 == 0x1f_u8 {
                                                                                                let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                if v1658.0 == 0x1e_u8 {
                                                                                                    if v1658.1 == 0x1f_u8 {
                                                                                                        let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                        let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                        let v1752 = constructor_vec_merge_low(ctx, I16X8, v1673, v1611);
                                                                                                        let v1753 = constructor_output_reg(ctx, v1752);
                                                                                                        let v1754 = Some(v1753);
                                                                                                        // Rule at src\isa\s390x\lower.isle line 2181.
                                                                                                        return v1754;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                0x1a_u8 => {
                                                    if v1628.1 == 0x1b_u8 {
                                                        let v1631 = C::u16_pair_split(ctx, v1619.1);
                                                        let v1634 = C::u8_pair_split(ctx, v1631.0);
                                                        match v1634.0 {
                                                            0x8_u8 => {
                                                                if v1634.1 == 0x9_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0xa_u8 {
                                                                        if v1637.1 == 0xb_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0x1c_u8 {
                                                                                if v1646.1 == 0x1d_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0x1e_u8 {
                                                                                        if v1649.1 == 0x1f_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0xc_u8 {
                                                                                                if v1655.1 == 0xd_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0xe_u8 {
                                                                                                        if v1658.1 == 0xf_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                            let v1725 = constructor_vec_merge_low(ctx, I32X4, v1673, v1603);
                                                                                                            let v1726 = constructor_output_reg(ctx, v1725);
                                                                                                            let v1727 = Some(v1726);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2163.
                                                                                                            return v1727;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0x18_u8 => {
                                                                if v1634.1 == 0x19_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x1a_u8 {
                                                                        if v1637.1 == 0x1b_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            if v1646.0 == 0x1c_u8 {
                                                                                if v1646.1 == 0x1d_u8 {
                                                                                    let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                    if v1649.0 == 0x1e_u8 {
                                                                                        if v1649.1 == 0x1f_u8 {
                                                                                            let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                            let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                            if v1655.0 == 0x1c_u8 {
                                                                                                if v1655.1 == 0x1d_u8 {
                                                                                                    let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                    if v1658.0 == 0x1e_u8 {
                                                                                                        if v1658.1 == 0x1f_u8 {
                                                                                                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                            let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                            let v1749 = constructor_vec_merge_low(ctx, I32X4, v1673, v1611);
                                                                                                            let v1750 = constructor_output_reg(ctx, v1749);
                                                                                                            let v1751 = Some(v1750);
                                                                                                            // Rule at src\isa\s390x\lower.isle line 2179.
                                                                                                            return v1751;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            0x1c_u8 => {
                                                                if v1634.1 == 0x1d_u8 {
                                                                    let v1637 = C::u8_pair_split(ctx, v1631.1);
                                                                    if v1637.0 == 0x1e_u8 {
                                                                        if v1637.1 == 0x1f_u8 {
                                                                            let v1640 = C::u32_pair_split(ctx, v1616.1);
                                                                            let v1643 = C::u16_pair_split(ctx, v1640.0);
                                                                            let v1646 = C::u8_pair_split(ctx, v1643.0);
                                                                            match v1646.0 {
                                                                                0x0_u8 => {
                                                                                    if v1646.1 == 0x1_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x2_u8 {
                                                                                            if v1649.1 == 0x3_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x4_u8 {
                                                                                                    if v1655.1 == 0x5_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x6_u8 {
                                                                                                            if v1658.1 == 0x7_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1839 = constructor_vec_permute_dw_imm(ctx, I8X16, v1673, 0x1_u8, v1603, 0x0_u8);
                                                                                                                let v1840 = constructor_output_reg(ctx, v1839);
                                                                                                                let v1841 = Some(v1840);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2247.
                                                                                                                return v1841;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x8_u8 => {
                                                                                    if v1646.1 == 0x9_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0xa_u8 {
                                                                                            if v1649.1 == 0xb_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0xc_u8 {
                                                                                                    if v1655.1 == 0xd_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0xe_u8 {
                                                                                                            if v1658.1 == 0xf_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1603 = C::put_in_reg(ctx, v1594.0);
                                                                                                                let v1722 = constructor_vec_merge_low(ctx, I64X2, v1673, v1603);
                                                                                                                let v1723 = constructor_output_reg(ctx, v1722);
                                                                                                                let v1724 = Some(v1723);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2161.
                                                                                                                return v1724;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x10_u8 => {
                                                                                    if v1646.1 == 0x11_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x12_u8 {
                                                                                            if v1649.1 == 0x13_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x14_u8 {
                                                                                                    if v1655.1 == 0x15_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x16_u8 {
                                                                                                            if v1658.1 == 0x17_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1851 = constructor_vec_permute_dw_imm(ctx, I8X16, v1673, 0x1_u8, v1611, 0x0_u8);
                                                                                                                let v1852 = constructor_output_reg(ctx, v1851);
                                                                                                                let v1853 = Some(v1852);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2255.
                                                                                                                return v1853;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                0x18_u8 => {
                                                                                    if v1646.1 == 0x19_u8 {
                                                                                        let v1649 = C::u8_pair_split(ctx, v1643.1);
                                                                                        if v1649.0 == 0x1a_u8 {
                                                                                            if v1649.1 == 0x1b_u8 {
                                                                                                let v1652 = C::u16_pair_split(ctx, v1640.1);
                                                                                                let v1655 = C::u8_pair_split(ctx, v1652.0);
                                                                                                if v1655.0 == 0x1c_u8 {
                                                                                                    if v1655.1 == 0x1d_u8 {
                                                                                                        let v1658 = C::u8_pair_split(ctx, v1652.1);
                                                                                                        if v1658.0 == 0x1e_u8 {
                                                                                                            if v1658.1 == 0x1f_u8 {
                                                                                                                let v1594 = C::unpack_value_array_2(ctx, v1592);
                                                                                                                let v1673 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1611 = C::put_in_reg(ctx, v1594.1);
                                                                                                                let v1746 = constructor_vec_merge_low(ctx, I64X2, v1673, v1611);
                                                                                                                let v1747 = constructor_output_reg(ctx, v1746);
                                                                                                                let v1748 = Some(v1747);
                                                                                                                // Rule at src\isa\s390x\lower.isle line 2177.
                                                                                                                return v1748;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                _ => {}
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                _ => {}
                            }
                            let v1594 = C::unpack_value_array_2(ctx, v1592);
                            let v1610 = C::put_in_reg(ctx, v1594.0);
                            let v1611 = C::put_in_reg(ctx, v1594.1);
                            let v1612 = constructor_vec_imm(ctx, I8X16, v1599.0);
                            let v1613 = constructor_vec_permute(ctx, I8X16, v1610, v1611, v1612);
                            let v1614 = constructor_output_reg(ctx, v1613);
                            let v1615 = Some(v1614);
                            // Rule at src\isa\s390x\lower.isle line 2115.
                            return v1615;
                        }
                        _ => {}
                    }
                    let v1602 = constructor_vec_imm_byte_mask(ctx, I8X16, v1599.1);
                    let v1594 = C::unpack_value_array_2(ctx, v1592);
                    let v1603 = C::put_in_reg(ctx, v1594.0);
                    let v1604 = C::put_in_reg(ctx, v1594.1);
                    let v1605 = constructor_vec_imm(ctx, I8X16, v1599.0);
                    let v1606 = constructor_vec_permute(ctx, I8X16, v1603, v1604, v1605);
                    let v1607 = constructor_vec_and(ctx, I8X16, v1602, v1606);
                    let v1608 = constructor_output_reg(ctx, v1607);
                    let v1609 = Some(v1608);
                    // Rule at src\isa\s390x\lower.isle line 2110.
                    return v1609;
                }
            }
        }
        &InstructionData::StackLoad {
            opcode: ref v1870,
            stack_slot: v1871,
            offset: v1872,
        } => {
            if let &Opcode::StackAddr = v1870 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    let v3 = C::value_type(ctx, v2);
                    let v1873 = constructor_stack_addr_impl(ctx, v3, v1871, v1872);
                    let v1874 = constructor_output_reg(ctx, v1873);
                    let v1875 = Some(v1874);
                    // Rule at src\isa\s390x\lower.isle line 2297.
                    return v1875;
                }
            }
        }
        &InstructionData::Store {
            opcode: ref v1495,
            args: ref v1496,
            flags: v1497,
            offset: v1498,
        } => {
            match v1495 {
                &Opcode::Store => {
                    let v1499 = C::unpack_value_array_2(ctx, v1496);
                    let v1502 = C::def_inst(ctx, v1499.0);
                    if let Some(v1503) = v1502 {
                        let v1504 = &C::inst_data_value(ctx, v1503);
                        if let &InstructionData::BinaryImm8 {
                            opcode: ref v1505,
                            arg: v1506,
                            imm: v1507,
                        } = v1504 {
                            if let &Opcode::Extractlane = v1505 {
                                let v1510 = C::bigendian(ctx, v1497);
                                if let Some(v1511) = v1510 {
                                    let v1512 = C::put_in_reg(ctx, v1506);
                                    let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                    let v1508 = C::value_type(ctx, v1506);
                                    let v1509 = C::u8_from_uimm8(ctx, v1507);
                                    let v1514 = C::be_lane_idx(ctx, v1508, v1509);
                                    let v1515 = &constructor_vec_store_lane(ctx, v1508, v1512, v1513, v1514);
                                    let v1516 = constructor_side_effect(ctx, v1515);
                                    let v1517 = Some(v1516);
                                    // Rule at src\isa\s390x\lower.isle line 1953.
                                    return v1517;
                                }
                                let v1518 = C::littleendian(ctx, v1497);
                                if let Some(v1519) = v1518 {
                                    let v1512 = C::put_in_reg(ctx, v1506);
                                    let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                    let v1508 = C::value_type(ctx, v1506);
                                    let v1509 = C::u8_from_uimm8(ctx, v1507);
                                    let v1514 = C::be_lane_idx(ctx, v1508, v1509);
                                    let v1520 = &constructor_vec_store_lane_little(ctx, v1508, v1512, v1513, v1514);
                                    let v1521 = constructor_side_effect(ctx, v1520);
                                    let v1522 = Some(v1521);
                                    // Rule at src\isa\s390x\lower.isle line 1960.
                                    return v1522;
                                }
                            }
                        }
                    }
                    let v1854 = &C::lane_order(ctx);
                    match v1854 {
                        &LaneOrder::LittleEndian => {
                            let v2046 = C::value_type(ctx, v1499.0);
                            let v2078 = C::vr128_ty(ctx, v2046);
                            if let Some(v2079) = v2078 {
                                let v1510 = C::bigendian(ctx, v1497);
                                if let Some(v1511) = v1510 {
                                    let v2059 = C::put_in_reg(ctx, v1499.0);
                                    let v2086 = &constructor_vec_store_elt_rev(ctx, v2079, v2059, v1497, v1499.1, v1498);
                                    let v2087 = constructor_side_effect(ctx, v2086);
                                    let v2088 = Some(v2087);
                                    // Rule at src\isa\s390x\lower.isle line 2766.
                                    return v2088;
                                }
                                let v1518 = C::littleendian(ctx, v1497);
                                if let Some(v1519) = v1518 {
                                    let v2059 = C::put_in_reg(ctx, v1499.0);
                                    let v2089 = &constructor_vec_store_full_rev(ctx, v2079, v2059, v1497, v1499.1, v1498);
                                    let v2090 = constructor_side_effect(ctx, v2089);
                                    let v2091 = Some(v2090);
                                    // Rule at src\isa\s390x\lower.isle line 2772.
                                    return v2091;
                                }
                            }
                        }
                        &LaneOrder::BigEndian => {
                            let v2046 = C::value_type(ctx, v1499.0);
                            let v2078 = C::vr128_ty(ctx, v2046);
                            if let Some(v2079) = v2078 {
                                let v1510 = C::bigendian(ctx, v1497);
                                if let Some(v1511) = v1510 {
                                    let v2059 = C::put_in_reg(ctx, v1499.0);
                                    let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                    let v2080 = &constructor_vec_store(ctx, v2059, v1513);
                                    let v2081 = constructor_side_effect(ctx, v2080);
                                    let v2082 = Some(v2081);
                                    // Rule at src\isa\s390x\lower.isle line 2754.
                                    return v2082;
                                }
                                let v1518 = C::littleendian(ctx, v1497);
                                if let Some(v1519) = v1518 {
                                    let v2059 = C::put_in_reg(ctx, v1499.0);
                                    let v2083 = &constructor_vec_store_byte_rev(ctx, v2079, v2059, v1497, v1499.1, v1498);
                                    let v2084 = constructor_side_effect(ctx, v2083);
                                    let v2085 = Some(v2084);
                                    // Rule at src\isa\s390x\lower.isle line 2760.
                                    return v2085;
                                }
                            }
                        }
                        _ => {}
                    }
                    let v2046 = C::value_type(ctx, v1499.0);
                    match v2046 {
                        I8 => {
                            let v2047 = &constructor_istore8_impl(ctx, v1497, v1499.0, v1499.1, v1498);
                            let v2048 = constructor_side_effect(ctx, v2047);
                            let v2049 = Some(v2048);
                            // Rule at src\isa\s390x\lower.isle line 2702.
                            return v2049;
                        }
                        I16 => {
                            let v2050 = &constructor_istore16_impl(ctx, v1497, v1499.0, v1499.1, v1498);
                            let v2051 = constructor_side_effect(ctx, v2050);
                            let v2052 = Some(v2051);
                            // Rule at src\isa\s390x\lower.isle line 2706.
                            return v2052;
                        }
                        I32 => {
                            let v2053 = &constructor_istore32_impl(ctx, v1497, v1499.0, v1499.1, v1498);
                            let v2054 = constructor_side_effect(ctx, v2053);
                            let v2055 = Some(v2054);
                            // Rule at src\isa\s390x\lower.isle line 2710.
                            return v2055;
                        }
                        I64 => {
                            let v2056 = &constructor_istore64_impl(ctx, v1497, v1499.0, v1499.1, v1498);
                            let v2057 = constructor_side_effect(ctx, v2056);
                            let v2058 = Some(v2057);
                            // Rule at src\isa\s390x\lower.isle line 2714.
                            return v2058;
                        }
                        F16 => {
                            let v1518 = C::littleendian(ctx, v1497);
                            if let Some(v1519) = v1518 {
                                let v2059 = C::put_in_reg(ctx, v1499.0);
                                let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                let v2063 = &constructor_vec_store_lane_little(ctx, F16X8, v2059, v1513, 0x0_u8);
                                let v2064 = constructor_side_effect(ctx, v2063);
                                let v2065 = Some(v2064);
                                // Rule at src\isa\s390x\lower.isle line 2724.
                                return v2065;
                            }
                            let v1510 = C::bigendian(ctx, v1497);
                            if let Some(v1511) = v1510 {
                                let v2059 = C::put_in_reg(ctx, v1499.0);
                                let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                let v2060 = &constructor_vec_store_lane(ctx, F16X8, v2059, v1513, 0x0_u8);
                                let v2061 = constructor_side_effect(ctx, v2060);
                                let v2062 = Some(v2061);
                                // Rule at src\isa\s390x\lower.isle line 2718.
                                return v2062;
                            }
                        }
                        F32 => {
                            let v1518 = C::littleendian(ctx, v1497);
                            if let Some(v1519) = v1518 {
                                let v2059 = C::put_in_reg(ctx, v1499.0);
                                let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                let v2069 = &constructor_vec_store_lane_little(ctx, F32X4, v2059, v1513, 0x0_u8);
                                let v2070 = constructor_side_effect(ctx, v2069);
                                let v2071 = Some(v2070);
                                // Rule at src\isa\s390x\lower.isle line 2736.
                                return v2071;
                            }
                            let v1510 = C::bigendian(ctx, v1497);
                            if let Some(v1511) = v1510 {
                                let v2059 = C::put_in_reg(ctx, v1499.0);
                                let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                let v2066 = &constructor_vec_store_lane(ctx, F32X4, v2059, v1513, 0x0_u8);
                                let v2067 = constructor_side_effect(ctx, v2066);
                                let v2068 = Some(v2067);
                                // Rule at src\isa\s390x\lower.isle line 2730.
                                return v2068;
                            }
                        }
                        F64 => {
                            let v1518 = C::littleendian(ctx, v1497);
                            if let Some(v1519) = v1518 {
                                let v2059 = C::put_in_reg(ctx, v1499.0);
                                let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                let v2075 = &constructor_vec_store_lane_little(ctx, F64X2, v2059, v1513, 0x0_u8);
                                let v2076 = constructor_side_effect(ctx, v2075);
                                let v2077 = Some(v2076);
                                // Rule at src\isa\s390x\lower.isle line 2748.
                                return v2077;
                            }
                            let v1510 = C::bigendian(ctx, v1497);
                            if let Some(v1511) = v1510 {
                                let v2059 = C::put_in_reg(ctx, v1499.0);
                                let v1513 = &constructor_lower_address(ctx, v1497, v1499.1, v1498);
                                let v2072 = &constructor_vec_store_lane(ctx, F64X2, v2059, v1513, 0x0_u8);
                                let v2073 = constructor_side_effect(ctx, v2072);
                                let v2074 = Some(v2073);
                                // Rule at src\isa\s390x\lower.isle line 2742.
                                return v2074;
                            }
                        }
                        _ => {}
                    }
                }
                &Opcode::Istore8 => {
                    let v1499 = C::unpack_value_array_2(ctx, v1496);
                    let v2047 = &constructor_istore8_impl(ctx, v1497, v1499.0, v1499.1, v1498);
                    let v2048 = constructor_side_effect(ctx, v2047);
                    let v2049 = Some(v2048);
                    // Rule at src\isa\s390x\lower.isle line 2874.
                    return v2049;
                }
                &Opcode::Istore16 => {
                    let v1499 = C::unpack_value_array_2(ctx, v1496);
                    let v2050 = &constructor_istore16_impl(ctx, v1497, v1499.0, v1499.1, v1498);
                    let v2051 = constructor_side_effect(ctx, v2050);
                    let v2052 = Some(v2051);
                    // Rule at src\isa\s390x\lower.isle line 2892.
                    return v2052;
                }
                &Opcode::Istore32 => {
                    let v1499 = C::unpack_value_array_2(ctx, v1496);
                    let v2053 = &constructor_istore32_impl(ctx, v1497, v1499.0, v1499.1, v1498);
                    let v2054 = constructor_side_effect(ctx, v2053);
                    let v2055 = Some(v2054);
                    // Rule at src\isa\s390x\lower.isle line 2918.
                    return v2055;
                }
                _ => {}
            }
        }
        &InstructionData::StoreNoOffset {
            opcode: ref v2224,
            args: ref v2225,
            flags: v2226,
        } => {
            if let &Opcode::AtomicStore = v2224 {
                let v2227 = C::unpack_value_array_2(ctx, v2225);
                let v2230 = C::value_type(ctx, v2227.0);
                match v2230 {
                    I8 => {
                        let v2197 = C::zero_offset(ctx);
                        let v2231 = &constructor_istore8_impl(ctx, v2226, v2227.0, v2227.1, v2197);
                        let v2232 = constructor_atomic_store_impl(ctx, v2231);
                        let v2233 = Some(v2232);
                        // Rule at src\isa\s390x\lower.isle line 3324.
                        return v2233;
                    }
                    I16 => {
                        let v2197 = C::zero_offset(ctx);
                        let v2234 = &constructor_istore16_impl(ctx, v2226, v2227.0, v2227.1, v2197);
                        let v2235 = constructor_atomic_store_impl(ctx, v2234);
                        let v2236 = Some(v2235);
                        // Rule at src\isa\s390x\lower.isle line 3328.
                        return v2236;
                    }
                    I32 => {
                        let v2197 = C::zero_offset(ctx);
                        let v2237 = &constructor_istore32_impl(ctx, v2226, v2227.0, v2227.1, v2197);
                        let v2238 = constructor_atomic_store_impl(ctx, v2237);
                        let v2239 = Some(v2238);
                        // Rule at src\isa\s390x\lower.isle line 3332.
                        return v2239;
                    }
                    I64 => {
                        let v2197 = C::zero_offset(ctx);
                        let v2240 = &constructor_istore64_impl(ctx, v2226, v2227.0, v2227.1, v2197);
                        let v2241 = constructor_atomic_store_impl(ctx, v2240);
                        let v2242 = Some(v2241);
                        // Rule at src\isa\s390x\lower.isle line 3336.
                        return v2242;
                    }
                    _ => {}
                }
            }
        }
        &InstructionData::Ternary {
            opcode: ref v936,
            args: ref v937,
        } => {
            match v936 {
                &Opcode::Select => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v1406 = C::ty_scalar_float(ctx, v3);
                        if let Some(v1407) = v1406 {
                            let v938 = C::unpack_value_array_3(ctx, v937);
                            let v2427 = C::maybe_uextend(ctx, v938.0);
                            if let Some(v2428) = v2427 {
                                let v2429 = C::def_inst(ctx, v2428);
                                if let Some(v2430) = v2429 {
                                    let v2431 = &C::inst_data_value(ctx, v2430);
                                    if let &InstructionData::FloatCompare {
                                        opcode: ref v2432,
                                        args: ref v2433,
                                        cond: ref v2434,
                                    } = v2431 {
                                        if let &Opcode::Fcmp = v2432 {
                                            if let &FloatCC::LessThan = v2434 {
                                                let v2435 = C::unpack_value_array_2(ctx, v2433);
                                                if v938.1 == v2435.1 {
                                                    if v938.2 == v2435.0 {
                                                        let v2443 = C::put_in_reg(ctx, v2435.0);
                                                        let v2444 = C::put_in_reg(ctx, v2435.1);
                                                        let v2445 = constructor_fmax_pseudo_reg(ctx, v1407, v2443, v2444);
                                                        let v2446 = constructor_output_reg(ctx, v2445);
                                                        let v2447 = Some(v2446);
                                                        // Rule at src\isa\s390x\lower.isle line 3796.
                                                        return v2447;
                                                    }
                                                }
                                                if v938.1 == v2435.0 {
                                                    if v938.2 == v2435.1 {
                                                        let v2438 = C::put_in_reg(ctx, v2435.1);
                                                        let v2439 = C::put_in_reg(ctx, v2435.0);
                                                        let v2440 = constructor_fmin_pseudo_reg(ctx, v1407, v2438, v2439);
                                                        let v2441 = constructor_output_reg(ctx, v2440);
                                                        let v2442 = Some(v2441);
                                                        // Rule at src\isa\s390x\lower.isle line 3794.
                                                        return v2442;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        let v938 = C::unpack_value_array_3(ctx, v937);
                        let v2423 = &constructor_value_nonzero(ctx, v938.0);
                        let v943 = C::put_in_reg(ctx, v938.1);
                        let v1155 = C::put_in_reg(ctx, v938.2);
                        let v2424 = constructor_select_bool_reg(ctx, v3, v2423, v943, v1155);
                        let v2425 = constructor_output_reg(ctx, v2424);
                        let v2426 = Some(v2425);
                        // Rule at src\isa\s390x\lower.isle line 3789.
                        return v2426;
                    }
                }
                &Opcode::SelectSpectreGuard => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v938 = C::unpack_value_array_3(ctx, v937);
                        let v2423 = &constructor_value_nonzero(ctx, v938.0);
                        let v943 = C::put_in_reg(ctx, v938.1);
                        let v1155 = C::put_in_reg(ctx, v938.2);
                        let v3 = C::value_type(ctx, v2);
                        let v2424 = constructor_select_bool_reg(ctx, v3, v2423, v943, v1155);
                        let v2425 = constructor_output_reg(ctx, v2424);
                        let v2426 = Some(v2425);
                        // Rule at src\isa\s390x\lower.isle line 3805.
                        return v2426;
                    }
                }
                &Opcode::Bitselect => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v938 = C::unpack_value_array_3(ctx, v937);
                            let v961 = C::def_inst(ctx, v938.0);
                            if let Some(v962) = v961 {
                                let v963 = &C::inst_data_value(ctx, v962);
                                if let &InstructionData::LoadNoOffset {
                                    opcode: ref v964,
                                    arg: v965,
                                    flags: v966,
                                } = v963 {
                                    if let &Opcode::Bitcast = v964 {
                                        let v967 = C::def_inst(ctx, v965);
                                        if let Some(v968) = v967 {
                                            let v969 = &C::inst_data_value(ctx, v968);
                                            if let &InstructionData::FloatCompare {
                                                opcode: ref v970,
                                                args: ref v971,
                                                cond: ref v972,
                                            } = v969 {
                                                if let &Opcode::Fcmp = v970 {
                                                    if let &FloatCC::LessThan = v972 {
                                                        let v973 = C::unpack_value_array_2(ctx, v971);
                                                        if v938.1 == v973.1 {
                                                            if v938.2 == v973.0 {
                                                                let v981 = C::put_in_reg(ctx, v973.0);
                                                                let v982 = C::put_in_reg(ctx, v973.1);
                                                                let v983 = constructor_fmax_pseudo_reg(ctx, v183, v981, v982);
                                                                let v984 = constructor_output_reg(ctx, v983);
                                                                let v985 = Some(v984);
                                                                // Rule at src\isa\s390x\lower.isle line 1156.
                                                                return v985;
                                                            }
                                                        }
                                                        if v938.1 == v973.0 {
                                                            if v938.2 == v973.1 {
                                                                let v976 = C::put_in_reg(ctx, v973.1);
                                                                let v977 = C::put_in_reg(ctx, v973.0);
                                                                let v978 = constructor_fmin_pseudo_reg(ctx, v183, v976, v977);
                                                                let v979 = constructor_output_reg(ctx, v978);
                                                                let v980 = Some(v979);
                                                                // Rule at src\isa\s390x\lower.isle line 1154.
                                                                return v980;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v792 = C::mie3_enabled(ctx, v3);
                            if let Some(v793) = v792 {
                                let v938 = C::unpack_value_array_3(ctx, v937);
                                let v942 = C::put_in_reg(ctx, v938.0);
                                let v943 = C::put_in_reg(ctx, v938.1);
                                let v944 = constructor_and_reg(ctx, v79, v943, v942);
                                let v945 = C::put_in_reg(ctx, v938.2);
                                let v946 = constructor_and_not_reg(ctx, v79, v945, v942);
                                let v947 = constructor_or_reg(ctx, v79, v946, v944);
                                let v948 = constructor_output_reg(ctx, v947);
                                let v949 = Some(v948);
                                // Rule at src\isa\s390x\lower.isle line 1136.
                                return v949;
                            }
                            let v797 = C::mie3_disabled(ctx, v3);
                            if let Some(v798) = v797 {
                                let v938 = C::unpack_value_array_3(ctx, v937);
                                let v942 = C::put_in_reg(ctx, v938.0);
                                let v943 = C::put_in_reg(ctx, v938.1);
                                let v944 = constructor_and_reg(ctx, v79, v943, v942);
                                let v945 = C::put_in_reg(ctx, v938.2);
                                let v950 = constructor_not_reg(ctx, v79, v942);
                                let v951 = constructor_and_reg(ctx, v79, v945, v950);
                                let v952 = constructor_or_reg(ctx, v79, v951, v944);
                                let v953 = constructor_output_reg(ctx, v952);
                                let v954 = Some(v953);
                                // Rule at src\isa\s390x\lower.isle line 1143.
                                return v954;
                            }
                        }
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v938 = C::unpack_value_array_3(ctx, v937);
                            let v955 = C::put_in_reg(ctx, v938.1);
                            let v956 = C::put_in_reg(ctx, v938.2);
                            let v957 = C::put_in_reg(ctx, v938.0);
                            let v958 = constructor_vec_select(ctx, v52, v955, v956, v957);
                            let v959 = constructor_output_reg(ctx, v958);
                            let v960 = Some(v959);
                            // Rule at src\isa\s390x\lower.isle line 1150.
                            return v960;
                        }
                    }
                }
                &Opcode::Fma => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v938 = C::unpack_value_array_3(ctx, v937);
                        let v942 = C::put_in_reg(ctx, v938.0);
                        let v943 = C::put_in_reg(ctx, v938.1);
                        let v1155 = C::put_in_reg(ctx, v938.2);
                        let v3 = C::value_type(ctx, v2);
                        let v1156 = constructor_fma_reg(ctx, v3, v942, v943, v1155);
                        let v1157 = constructor_output_reg(ctx, v1156);
                        let v1158 = Some(v1157);
                        // Rule at src\isa\s390x\lower.isle line 1434.
                        return v1158;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::TernaryImm8 {
            opcode: ref v1421,
            args: ref v1422,
            imm: v1423,
        } => {
            if let &Opcode::Insertlane = v1421 {
                let v1424 = C::unpack_value_array_2(ctx, v1422);
                let v1462 = C::sinkable_inst(ctx, v1424.1);
                if let Some(v1463) = v1462 {
                    let v1464 = &C::inst_data_value(ctx, v1463);
                    if let &InstructionData::Load {
                        opcode: ref v1465,
                        arg: v1466,
                        flags: v1467,
                        offset: v1468,
                    } = v1464 {
                        if let &Opcode::Load = v1465 {
                            let v1475 = C::littleendian(ctx, v1467);
                            if let Some(v1476) = v1475 {
                                let v1432 = C::put_in_reg(ctx, v1424.0);
                                let v1471 = &constructor_sink_load(ctx, v1463);
                                let v1427 = C::value_type(ctx, v1424.0);
                                let v1429 = C::u8_from_uimm8(ctx, v1423);
                                let v1434 = C::be_lane_idx(ctx, v1427, v1429);
                                let v1477 = constructor_vec_load_lane_little(ctx, v1427, v1432, v1471, v1434);
                                let v1478 = constructor_output_reg(ctx, v1477);
                                let v1479 = Some(v1478);
                                // Rule at src\isa\s390x\lower.isle line 1855.
                                return v1479;
                            }
                            let v1469 = C::bigendian(ctx, v1467);
                            if let Some(v1470) = v1469 {
                                let v1432 = C::put_in_reg(ctx, v1424.0);
                                let v1471 = &constructor_sink_load(ctx, v1463);
                                let v1427 = C::value_type(ctx, v1424.0);
                                let v1429 = C::u8_from_uimm8(ctx, v1423);
                                let v1434 = C::be_lane_idx(ctx, v1427, v1429);
                                let v1472 = constructor_vec_load_lane(ctx, v1427, v1432, v1471, v1434);
                                let v1473 = constructor_output_reg(ctx, v1472);
                                let v1474 = Some(v1473);
                                // Rule at src\isa\s390x\lower.isle line 1850.
                                return v1474;
                            }
                        }
                    }
                }
                let v1457 = C::i16_from_value(ctx, v1424.1);
                if let Some(v1458) = v1457 {
                    let v1432 = C::put_in_reg(ctx, v1424.0);
                    let v1427 = C::value_type(ctx, v1424.0);
                    let v1429 = C::u8_from_uimm8(ctx, v1423);
                    let v1440 = C::be_lane_idx(ctx, v1427, v1429);
                    let v1459 = constructor_vec_insert_lane_imm(ctx, v1427, v1432, v1458, v1440);
                    let v1460 = constructor_output_reg(ctx, v1459);
                    let v1461 = Some(v1460);
                    // Rule at src\isa\s390x\lower.isle line 1845.
                    return v1461;
                }
                let v1445 = C::def_inst(ctx, v1424.1);
                if let Some(v1446) = v1445 {
                    let v1447 = &C::inst_data_value(ctx, v1446);
                    if let &InstructionData::BinaryImm8 {
                        opcode: ref v1448,
                        arg: v1449,
                        imm: v1450,
                    } = v1447 {
                        if let &Opcode::Extractlane = v1448 {
                            let v1432 = C::put_in_reg(ctx, v1424.0);
                            let v1427 = C::value_type(ctx, v1424.0);
                            let v1429 = C::u8_from_uimm8(ctx, v1423);
                            let v1440 = C::be_lane_idx(ctx, v1427, v1429);
                            let v1452 = C::put_in_reg(ctx, v1449);
                            let v1451 = C::u8_from_uimm8(ctx, v1450);
                            let v1453 = C::be_lane_idx(ctx, v1427, v1451);
                            let v1454 = constructor_vec_move_lane_and_insert(ctx, v1427, v1432, v1440, v1452, v1453);
                            let v1455 = constructor_output_reg(ctx, v1454);
                            let v1456 = Some(v1455);
                            // Rule at src\isa\s390x\lower.isle line 1838.
                            return v1456;
                        }
                    }
                }
                let v1428 = C::value_type(ctx, v1424.1);
                let v1430 = C::ty_int_ref_scalar_64(ctx, v1428);
                if let Some(v1431) = v1430 {
                    let v1432 = C::put_in_reg(ctx, v1424.0);
                    let v1433 = C::put_in_reg(ctx, v1424.1);
                    let v1427 = C::value_type(ctx, v1424.0);
                    let v1429 = C::u8_from_uimm8(ctx, v1423);
                    let v1434 = C::be_lane_idx(ctx, v1427, v1429);
                    let v72 = C::zero_reg(ctx);
                    let v1435 = constructor_vec_insert_lane(ctx, v1427, v1432, v1433, v1434, v72);
                    let v1436 = constructor_output_reg(ctx, v1435);
                    let v1437 = Some(v1436);
                    // Rule at src\isa\s390x\lower.isle line 1825.
                    return v1437;
                }
                let v1438 = C::ty_scalar_float(ctx, v1428);
                if let Some(v1439) = v1438 {
                    let v1432 = C::put_in_reg(ctx, v1424.0);
                    let v1427 = C::value_type(ctx, v1424.0);
                    let v1429 = C::u8_from_uimm8(ctx, v1423);
                    let v1440 = C::be_lane_idx(ctx, v1427, v1429);
                    let v1441 = C::put_in_reg(ctx, v1424.1);
                    let v1442 = constructor_vec_move_lane_and_insert(ctx, v1427, v1432, v1440, v1441, 0x0_u8);
                    let v1443 = constructor_output_reg(ctx, v1442);
                    let v1444 = Some(v1443);
                    // Rule at src\isa\s390x\lower.isle line 1832.
                    return v1444;
                }
            }
        }
        &InstructionData::Trap {
            opcode: ref v2448,
            code: ref v2449,
        } => {
            if let &Opcode::Trap = v2448 {
                let v2450 = &constructor_trap_impl(ctx, v2449);
                let v2451 = constructor_side_effect(ctx, v2450);
                let v2452 = Some(v2451);
                // Rule at src\isa\s390x\lower.isle line 3860.
                return v2452;
            }
        }
        &InstructionData::Unary {
            opcode: ref v63,
            arg: v64,
        } => {
            match v63 {
                &Opcode::Splat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v1548 = C::sinkable_inst(ctx, v64);
                        if let Some(v1549) = v1548 {
                            let v1550 = &C::inst_data_value(ctx, v1549);
                            if let &InstructionData::Load {
                                opcode: ref v1551,
                                arg: v1552,
                                flags: v1553,
                                offset: v1554,
                            } = v1550 {
                                if let &Opcode::Load = v1551 {
                                    let v1561 = C::littleendian(ctx, v1553);
                                    if let Some(v1562) = v1561 {
                                        let v1557 = &constructor_sink_load(ctx, v1549);
                                        let v3 = C::value_type(ctx, v2);
                                        let v1563 = constructor_vec_load_replicate_little(ctx, v3, v1557);
                                        let v1564 = constructor_output_reg(ctx, v1563);
                                        let v1565 = Some(v1564);
                                        // Rule at src\isa\s390x\lower.isle line 2022.
                                        return v1565;
                                    }
                                    let v1555 = C::bigendian(ctx, v1553);
                                    if let Some(v1556) = v1555 {
                                        let v1557 = &constructor_sink_load(ctx, v1549);
                                        let v3 = C::value_type(ctx, v2);
                                        let v1558 = constructor_vec_load_replicate(ctx, v3, v1557);
                                        let v1559 = constructor_output_reg(ctx, v1558);
                                        let v1560 = Some(v1559);
                                        // Rule at src\isa\s390x\lower.isle line 2018.
                                        return v1560;
                                    }
                                }
                            }
                        }
                        let v1543 = C::i16_from_value(ctx, v64);
                        if let Some(v1544) = v1543 {
                            let v3 = C::value_type(ctx, v2);
                            let v1545 = constructor_vec_imm_replicate(ctx, v3, v1544);
                            let v1546 = constructor_output_reg(ctx, v1545);
                            let v1547 = Some(v1546);
                            // Rule at src\isa\s390x\lower.isle line 2014.
                            return v1547;
                        }
                        let v309 = C::def_inst(ctx, v64);
                        if let Some(v310) = v309 {
                            let v311 = &C::inst_data_value(ctx, v310);
                            if let &InstructionData::BinaryImm8 {
                                opcode: ref v1534,
                                arg: v1535,
                                imm: v1536,
                            } = v311 {
                                if let &Opcode::Extractlane = v1534 {
                                    let v1538 = C::put_in_reg(ctx, v1535);
                                    let v3 = C::value_type(ctx, v2);
                                    let v1537 = C::u8_from_uimm8(ctx, v1536);
                                    let v1539 = C::be_lane_idx(ctx, v3, v1537);
                                    let v1540 = constructor_vec_replicate_lane(ctx, v3, v1538, v1539);
                                    let v1541 = constructor_output_reg(ctx, v1540);
                                    let v1542 = Some(v1541);
                                    // Rule at src\isa\s390x\lower.isle line 2010.
                                    return v1542;
                                }
                            }
                        }
                        let v65 = C::value_type(ctx, v64);
                        let v1523 = C::ty_int_ref_scalar_64(ctx, v65);
                        if let Some(v1524) = v1523 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v69 = C::zero_reg(ctx);
                            let v3 = C::value_type(ctx, v2);
                            let v1525 = constructor_vec_insert_lane_undef(ctx, v3, v66, 0x0_u8, v69);
                            let v1526 = constructor_vec_replicate_lane(ctx, v3, v1525, 0x0_u8);
                            let v1527 = constructor_output_reg(ctx, v1526);
                            let v1528 = Some(v1527);
                            // Rule at src\isa\s390x\lower.isle line 2000.
                            return v1528;
                        }
                        let v1529 = C::ty_scalar_float(ctx, v65);
                        if let Some(v1530) = v1529 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v3 = C::value_type(ctx, v2);
                            let v1531 = constructor_vec_replicate_lane(ctx, v3, v66, 0x0_u8);
                            let v1532 = constructor_output_reg(ctx, v1531);
                            let v1533 = Some(v1532);
                            // Rule at src\isa\s390x\lower.isle line 2005.
                            return v1533;
                        }
                    }
                }
                &Opcode::VanyTrue => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v2355 = &constructor_vany_true_val(ctx, v64);
                            let v2356 = constructor_lower_bool(ctx, v79, v2355);
                            let v2357 = constructor_output_reg(ctx, v2356);
                            let v2358 = Some(v2357);
                            // Rule at src\isa\s390x\lower.isle line 3648.
                            return v2358;
                        }
                    }
                }
                &Opcode::VallTrue => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v2351 = &constructor_vall_true_val(ctx, v64);
                            let v2352 = constructor_lower_bool(ctx, v79, v2351);
                            let v2353 = constructor_output_reg(ctx, v2352);
                            let v2354 = Some(v2353);
                            // Rule at src\isa\s390x\lower.isle line 3570.
                            return v2354;
                        }
                    }
                }
                &Opcode::VhighBits => {
                    let v1854 = &C::lane_order(ctx);
                    match v1854 {
                        &LaneOrder::LittleEndian => {
                            let v65 = C::value_type(ctx, v64);
                            let v2359 = C::multi_lane(ctx, v65);
                            if let Some(v2360) = v2359 {
                                match v2360.0 {
                                    0x8_u32 => {
                                        if v2360.1 == 0x10_u32 {
                                            let v2373 = constructor_imm8x16(ctx, 0x0_u8, 0x8_u8, 0x10_u8, 0x18_u8, 0x20_u8, 0x28_u8, 0x30_u8, 0x38_u8, 0x40_u8, 0x48_u8, 0x50_u8, 0x58_u8, 0x60_u8, 0x68_u8, 0x70_u8, 0x78_u8);
                                            let v2374 = constructor_vec_imm(ctx, I8X16, v2373);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2376 = constructor_vec_bitpermute(ctx, v2375, v2374);
                                            let v502 = C::zero_reg(ctx);
                                            let v2377 = constructor_vec_extract_lane(ctx, I64X2, v2376, 0x0_u8, v502);
                                            let v2378 = constructor_output_reg(ctx, v2377);
                                            let v2379 = Some(v2378);
                                            // Rule at src\isa\s390x\lower.isle line 3724.
                                            return v2379;
                                        }
                                    }
                                    0x10_u32 => {
                                        if v2360.1 == 0x8_u32 {
                                            let v2387 = constructor_imm8x16(ctx, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x0_u8, 0x10_u8, 0x20_u8, 0x30_u8, 0x40_u8, 0x50_u8, 0x60_u8, 0x70_u8);
                                            let v2388 = constructor_vec_imm(ctx, I8X16, v2387);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2389 = constructor_vec_bitpermute(ctx, v2375, v2388);
                                            let v502 = C::zero_reg(ctx);
                                            let v2390 = constructor_vec_extract_lane(ctx, I64X2, v2389, 0x0_u8, v502);
                                            let v2391 = constructor_output_reg(ctx, v2390);
                                            let v2392 = Some(v2391);
                                            // Rule at src\isa\s390x\lower.isle line 3735.
                                            return v2392;
                                        }
                                    }
                                    0x20_u32 => {
                                        if v2360.1 == 0x4_u32 {
                                            let v2399 = constructor_imm8x16(ctx, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x0_u8, 0x20_u8, 0x40_u8, 0x60_u8);
                                            let v2400 = constructor_vec_imm(ctx, I8X16, v2399);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2401 = constructor_vec_bitpermute(ctx, v2375, v2400);
                                            let v502 = C::zero_reg(ctx);
                                            let v2402 = constructor_vec_extract_lane(ctx, I64X2, v2401, 0x0_u8, v502);
                                            let v2403 = constructor_output_reg(ctx, v2402);
                                            let v2404 = Some(v2403);
                                            // Rule at src\isa\s390x\lower.isle line 3746.
                                            return v2404;
                                        }
                                    }
                                    0x40_u32 => {
                                        if v2360.1 == 0x2_u32 {
                                            let v2411 = constructor_imm8x16(ctx, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x0_u8, 0x40_u8);
                                            let v2412 = constructor_vec_imm(ctx, I8X16, v2411);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2413 = constructor_vec_bitpermute(ctx, v2375, v2412);
                                            let v502 = C::zero_reg(ctx);
                                            let v2414 = constructor_vec_extract_lane(ctx, I64X2, v2413, 0x0_u8, v502);
                                            let v2415 = constructor_output_reg(ctx, v2414);
                                            let v2416 = Some(v2415);
                                            // Rule at src\isa\s390x\lower.isle line 3757.
                                            return v2416;
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                        &LaneOrder::BigEndian => {
                            let v65 = C::value_type(ctx, v64);
                            let v2359 = C::multi_lane(ctx, v65);
                            if let Some(v2360) = v2359 {
                                match v2360.0 {
                                    0x8_u32 => {
                                        if v2360.1 == 0x10_u32 {
                                            let v2380 = constructor_imm8x16(ctx, 0x78_u8, 0x70_u8, 0x68_u8, 0x60_u8, 0x58_u8, 0x50_u8, 0x48_u8, 0x40_u8, 0x38_u8, 0x30_u8, 0x28_u8, 0x20_u8, 0x18_u8, 0x10_u8, 0x8_u8, 0x0_u8);
                                            let v2381 = constructor_vec_imm(ctx, I8X16, v2380);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2382 = constructor_vec_bitpermute(ctx, v2375, v2381);
                                            let v502 = C::zero_reg(ctx);
                                            let v2383 = constructor_vec_extract_lane(ctx, I64X2, v2382, 0x0_u8, v502);
                                            let v2384 = constructor_output_reg(ctx, v2383);
                                            let v2385 = Some(v2384);
                                            // Rule at src\isa\s390x\lower.isle line 3729.
                                            return v2385;
                                        }
                                    }
                                    0x10_u32 => {
                                        if v2360.1 == 0x8_u32 {
                                            let v2393 = constructor_imm8x16(ctx, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x70_u8, 0x60_u8, 0x50_u8, 0x40_u8, 0x30_u8, 0x20_u8, 0x10_u8, 0x0_u8);
                                            let v2394 = constructor_vec_imm(ctx, I8X16, v2393);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2395 = constructor_vec_bitpermute(ctx, v2375, v2394);
                                            let v502 = C::zero_reg(ctx);
                                            let v2396 = constructor_vec_extract_lane(ctx, I64X2, v2395, 0x0_u8, v502);
                                            let v2397 = constructor_output_reg(ctx, v2396);
                                            let v2398 = Some(v2397);
                                            // Rule at src\isa\s390x\lower.isle line 3740.
                                            return v2398;
                                        }
                                    }
                                    0x20_u32 => {
                                        if v2360.1 == 0x4_u32 {
                                            let v2405 = constructor_imm8x16(ctx, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x60_u8, 0x40_u8, 0x20_u8, 0x0_u8);
                                            let v2406 = constructor_vec_imm(ctx, I8X16, v2405);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2407 = constructor_vec_bitpermute(ctx, v2375, v2406);
                                            let v502 = C::zero_reg(ctx);
                                            let v2408 = constructor_vec_extract_lane(ctx, I64X2, v2407, 0x0_u8, v502);
                                            let v2409 = constructor_output_reg(ctx, v2408);
                                            let v2410 = Some(v2409);
                                            // Rule at src\isa\s390x\lower.isle line 3751.
                                            return v2410;
                                        }
                                    }
                                    0x40_u32 => {
                                        if v2360.1 == 0x2_u32 {
                                            let v2417 = constructor_imm8x16(ctx, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x80_u8, 0x40_u8, 0x0_u8);
                                            let v2418 = constructor_vec_imm(ctx, I8X16, v2417);
                                            let v2375 = C::put_in_reg(ctx, v64);
                                            let v2419 = constructor_vec_bitpermute(ctx, v2375, v2418);
                                            let v502 = C::zero_reg(ctx);
                                            let v2420 = constructor_vec_extract_lane(ctx, I64X2, v2419, 0x0_u8, v502);
                                            let v2421 = constructor_output_reg(ctx, v2420);
                                            let v2422 = Some(v2421);
                                            // Rule at src\isa\s390x\lower.isle line 3762.
                                            return v2422;
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                        _ => {}
                    }
                }
                &Opcode::Ineg => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v309 = C::def_inst(ctx, v64);
                            if let Some(v310) = v309 {
                                let v311 = &C::inst_data_value(ctx, v310);
                                if let &InstructionData::Unary {
                                    opcode: ref v312,
                                    arg: v313,
                                } = v311 {
                                    if let &Opcode::Sextend = v312 {
                                        let v314 = C::value_type(ctx, v313);
                                        if v314 == I32 {
                                            let v315 = C::put_in_reg(ctx, v313);
                                            let v335 = constructor_neg_reg_sext32(ctx, v79, v315);
                                            let v336 = constructor_output_reg(ctx, v335);
                                            let v337 = Some(v336);
                                            // Rule at src\isa\s390x\lower.isle line 240.
                                            return v337;
                                        }
                                    }
                                }
                            }
                            let v66 = C::put_in_reg(ctx, v64);
                            let v332 = constructor_neg_reg(ctx, v79, v66);
                            let v333 = constructor_output_reg(ctx, v332);
                            let v334 = Some(v333);
                            // Rule at src\isa\s390x\lower.isle line 236.
                            return v334;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v338 = constructor_vec_neg(ctx, v183, v66);
                            let v339 = constructor_output_reg(ctx, v338);
                            let v340 = Some(v339);
                            // Rule at src\isa\s390x\lower.isle line 244.
                            return v340;
                        }
                        if v3 == I128 {
                            let v324 = constructor_vec_imm(ctx, I128, 0x0_u128);
                            let v325 = C::put_in_reg(ctx, v64);
                            let v326 = constructor_vec_sub(ctx, I128, v324, v325);
                            let v341 = constructor_output_reg(ctx, v326);
                            let v342 = Some(v341);
                            // Rule at src\isa\s390x\lower.isle line 248.
                            return v342;
                        }
                    }
                }
                &Opcode::Iabs => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v309 = C::def_inst(ctx, v64);
                            if let Some(v310) = v309 {
                                let v311 = &C::inst_data_value(ctx, v310);
                                if let &InstructionData::Unary {
                                    opcode: ref v312,
                                    arg: v313,
                                } = v311 {
                                    if let &Opcode::Sextend = v312 {
                                        let v314 = C::value_type(ctx, v313);
                                        if v314 == I32 {
                                            let v315 = C::put_in_reg(ctx, v313);
                                            let v316 = constructor_abs_reg_sext32(ctx, v79, v315);
                                            let v317 = constructor_output_reg(ctx, v316);
                                            let v318 = Some(v317);
                                            // Rule at src\isa\s390x\lower.isle line 216.
                                            return v318;
                                        }
                                    }
                                }
                            }
                            let v304 = constructor_ty_ext32(ctx, v79);
                            let v305 = constructor_put_in_reg_sext32(ctx, v64);
                            let v306 = constructor_abs_reg(ctx, v304, v305);
                            let v307 = constructor_output_reg(ctx, v306);
                            let v308 = Some(v307);
                            // Rule at src\isa\s390x\lower.isle line 212.
                            return v308;
                        }
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v319 = constructor_vec_abs(ctx, v183, v66);
                            let v320 = constructor_output_reg(ctx, v319);
                            let v321 = Some(v320);
                            // Rule at src\isa\s390x\lower.isle line 220.
                            return v321;
                        }
                        if v3 == I128 {
                            let v324 = constructor_vec_imm(ctx, I128, 0x0_u128);
                            let v325 = C::put_in_reg(ctx, v64);
                            let v326 = constructor_vec_sub(ctx, I128, v324, v325);
                            let v327 = constructor_vec_replicate_lane(ctx, I64X2, v325, 0x0_u8);
                            let v328 = constructor_vec_cmph(ctx, I64X2, v324, v327);
                            let v329 = constructor_vec_select(ctx, I128, v326, v325, v328);
                            let v330 = constructor_output_reg(ctx, v329);
                            let v331 = Some(v330);
                            // Rule at src\isa\s390x\lower.isle line 224.
                            return v331;
                        }
                    }
                }
                &Opcode::Bnot => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v309 = C::def_inst(ctx, v64);
                        if let Some(v310) = v309 {
                            let v311 = &C::inst_data_value(ctx, v310);
                            if let &InstructionData::Binary {
                                opcode: ref v805,
                                args: ref v806,
                            } = v311 {
                                if let &Opcode::Bxor = v805 {
                                    let v3 = C::value_type(ctx, v2);
                                    let v51 = C::vr128_ty(ctx, v3);
                                    if let Some(v52) = v51 {
                                        let v807 = C::unpack_value_array_2(ctx, v806);
                                        let v810 = C::put_in_reg(ctx, v807.0);
                                        let v811 = C::put_in_reg(ctx, v807.1);
                                        let v815 = constructor_vec_not_xor(ctx, v52, v810, v811);
                                        let v816 = constructor_output_reg(ctx, v815);
                                        let v817 = Some(v816);
                                        // Rule at src\isa\s390x\lower.isle line 1005.
                                        return v817;
                                    }
                                    let v78 = C::fits_in_64(ctx, v3);
                                    if let Some(v79) = v78 {
                                        let v792 = C::mie3_enabled(ctx, v3);
                                        if let Some(v793) = v792 {
                                            let v807 = C::unpack_value_array_2(ctx, v806);
                                            let v810 = C::put_in_reg(ctx, v807.0);
                                            let v811 = C::put_in_reg(ctx, v807.1);
                                            let v812 = constructor_not_xor_reg(ctx, v79, v810, v811);
                                            let v813 = constructor_output_reg(ctx, v812);
                                            let v814 = Some(v813);
                                            // Rule at src\isa\s390x\lower.isle line 1001.
                                            return v814;
                                        }
                                    }
                                }
                            }
                        }
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v792 = C::mie3_enabled(ctx, v3);
                            if let Some(v793) = v792 {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v794 = constructor_not_or_reg(ctx, v79, v66, v66);
                                let v795 = constructor_output_reg(ctx, v794);
                                let v796 = Some(v795);
                                // Rule at src\isa\s390x\lower.isle line 987.
                                return v796;
                            }
                            let v797 = C::mie3_disabled(ctx, v3);
                            if let Some(v798) = v797 {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v799 = constructor_not_reg(ctx, v79, v66);
                                let v800 = constructor_output_reg(ctx, v799);
                                let v801 = Some(v800);
                                // Rule at src\isa\s390x\lower.isle line 992.
                                return v801;
                            }
                        }
                        let v51 = C::vr128_ty(ctx, v3);
                        if let Some(v52) = v51 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v802 = constructor_vec_not(ctx, v52, v66);
                            let v803 = constructor_output_reg(ctx, v802);
                            let v804 = Some(v803);
                            // Rule at src\isa\s390x\lower.isle line 996.
                            return v804;
                        }
                    }
                }
                &Opcode::Bitrev => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v995 = constructor_bitrev_bits(ctx, 0x1_u8, 0xaaaaaaaaaaaaaaaa_u64, v3, v66);
                        let v996 = constructor_bitrev_bits(ctx, 0x2_u8, 0xcccccccccccccccc_u64, v3, v995);
                        let v997 = constructor_bitrev_bits(ctx, 0x4_u8, 0xf0f0f0f0f0f0f0f0_u64, v3, v996);
                        let v998 = constructor_bitrev_bytes(ctx, v3, v997);
                        let v999 = constructor_output_reg(ctx, v998);
                        let v1000 = Some(v999);
                        // Rule at src\isa\s390x\lower.isle line 1169.
                        return v1000;
                    }
                }
                &Opcode::Clz => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v734 = constructor_put_in_reg_zext64(ctx, v64);
                            let v1005 = constructor_clz_reg(ctx, 64_i16, v734);
                            let v1006 = constructor_clz_offset(ctx, v79, v1005);
                            let v1007 = constructor_output_reg(ctx, v1006);
                            let v1008 = Some(v1007);
                            // Rule at src\isa\s390x\lower.isle line 1220.
                            return v1008;
                        }
                        if v3 == I128 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v1009 = constructor_vec_clz(ctx, I64X2, v66);
                            let v1010 = constructor_vec_imm(ctx, I64X2, 0x0_u128);
                            let v1011 = constructor_vec_permute_dw_imm(ctx, I64X2, v1010, 0x0_u8, v1009, 0x0_u8);
                            let v1012 = constructor_vec_permute_dw_imm(ctx, I64X2, v1010, 0x0_u8, v1009, 0x1_u8);
                            let v1013 = constructor_vec_add(ctx, I64X2, v1011, v1012);
                            let v1015 = constructor_vec_imm_splat(ctx, I64X2, 0x40_u64);
                            let v1016 = constructor_vec_cmpeq(ctx, I64X2, v1011, v1015);
                            let v1017 = constructor_vec_select(ctx, I128, v1013, v1011, v1016);
                            let v1018 = constructor_output_reg(ctx, v1017);
                            let v1019 = Some(v1018);
                            // Rule at src\isa\s390x\lower.isle line 1228.
                            return v1019;
                        }
                    }
                }
                &Opcode::Cls => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v756 = constructor_put_in_reg_sext64(ctx, v64);
                            let v760 = constructor_ashr_imm(ctx, I64, v756, 0x3f_u8);
                            let v1020 = constructor_xor_reg(ctx, I64, v756, v760);
                            let v1021 = constructor_clz_reg(ctx, 64_i16, v1020);
                            let v1022 = constructor_cls_offset(ctx, v79, v1021);
                            let v1023 = constructor_output_reg(ctx, v1022);
                            let v1024 = Some(v1023);
                            // Rule at src\isa\s390x\lower.isle line 1254.
                            return v1024;
                        }
                        if v3 == I128 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v1026 = constructor_vec_imm_splat(ctx, I8X16, 0xff_u64);
                            let v1027 = constructor_vec_ashr_by_byte(ctx, v66, v1026);
                            let v1028 = constructor_vec_ashr_by_bit(ctx, v1027, v1026);
                            let v1029 = constructor_vec_xor(ctx, I128, v66, v1028);
                            let v1030 = constructor_vec_clz(ctx, I64X2, v1029);
                            let v1031 = constructor_vec_imm(ctx, I64X2, 0x0_u128);
                            let v1032 = constructor_vec_permute_dw_imm(ctx, I64X2, v1031, 0x0_u8, v1030, 0x0_u8);
                            let v1033 = constructor_vec_permute_dw_imm(ctx, I64X2, v1031, 0x0_u8, v1030, 0x1_u8);
                            let v1034 = constructor_vec_add(ctx, I64X2, v1032, v1033);
                            let v1035 = constructor_vec_imm_splat(ctx, I64X2, 0x40_u64);
                            let v1036 = constructor_vec_cmpeq(ctx, I64X2, v1032, v1035);
                            let v1037 = constructor_vec_select(ctx, I128, v1034, v1032, v1036);
                            let v1038 = constructor_vec_add(ctx, I128, v1037, v1026);
                            let v1039 = constructor_output_reg(ctx, v1038);
                            let v1040 = Some(v1039);
                            // Rule at src\isa\s390x\lower.isle line 1262.
                            return v1040;
                        }
                    }
                }
                &Opcode::Ctz => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v727 = C::gpr32_ty(ctx, v3);
                        if let Some(v728) = v727 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v1041 = constructor_ctz_guardbit(ctx, v728);
                            let v1042 = constructor_or_uimm16shifted(ctx, I64, v66, v1041);
                            let v1043 = constructor_neg_reg(ctx, I64, v1042);
                            let v1044 = constructor_and_reg(ctx, I64, v1042, v1043);
                            let v1045 = constructor_clz_reg(ctx, 64_i16, v1044);
                            let v1047 = constructor_imm(ctx, v728, 0x3f_u64);
                            let v1048 = constructor_sub_reg(ctx, v728, v1047, v1045);
                            let v1049 = constructor_output_reg(ctx, v1048);
                            let v1050 = Some(v1049);
                            // Rule at src\isa\s390x\lower.isle line 1291.
                            return v1050;
                        }
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v1051 = constructor_neg_reg(ctx, I64, v66);
                            let v1052 = constructor_and_reg(ctx, I64, v66, v1051);
                            let v1054 = constructor_clz_reg(ctx, -1_i16, v1052);
                            let v1055 = constructor_imm(ctx, I64, 0x3f_u64);
                            let v1056 = constructor_sub_reg(ctx, I64, v1055, v1054);
                            let v1057 = constructor_output_reg(ctx, v1056);
                            let v1058 = Some(v1057);
                            // Rule at src\isa\s390x\lower.isle line 1306.
                            return v1058;
                        }
                        if v3 == I128 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v1059 = constructor_vec_ctz(ctx, I64X2, v66);
                            let v1010 = constructor_vec_imm(ctx, I64X2, 0x0_u128);
                            let v1060 = constructor_vec_permute_dw_imm(ctx, I64X2, v1010, 0x0_u8, v1059, 0x0_u8);
                            let v1061 = constructor_vec_permute_dw_imm(ctx, I64X2, v1010, 0x0_u8, v1059, 0x1_u8);
                            let v1062 = constructor_vec_add(ctx, I64X2, v1060, v1061);
                            let v1015 = constructor_vec_imm_splat(ctx, I64X2, 0x40_u64);
                            let v1063 = constructor_vec_cmpeq(ctx, I64X2, v1061, v1015);
                            let v1064 = constructor_vec_select(ctx, I128, v1062, v1061, v1063);
                            let v1065 = constructor_output_reg(ctx, v1064);
                            let v1066 = Some(v1065);
                            // Rule at src\isa\s390x\lower.isle line 1313.
                            return v1066;
                        }
                    }
                }
                &Opcode::Bswap => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1001 = constructor_bitrev_bytes(ctx, v3, v66);
                        let v1002 = constructor_output_reg(ctx, v1001);
                        let v1003 = Some(v1002);
                        // Rule at src\isa\s390x\lower.isle line 1204.
                        return v1003;
                    }
                }
                &Opcode::Popcnt => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v182 = C::ty_vec128(ctx, v3);
                        if let Some(v183) = v182 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v1100 = constructor_vec_popcnt(ctx, v183, v66);
                            let v1101 = constructor_output_reg(ctx, v1100);
                            let v1102 = Some(v1101);
                            // Rule at src\isa\s390x\lower.isle line 1361.
                            return v1102;
                        }
                        match v3 {
                            I8 => {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v1067 = constructor_popcnt_byte(ctx, v66);
                                let v1068 = constructor_output_reg(ctx, v1067);
                                let v1069 = Some(v1068);
                                // Rule at src\isa\s390x\lower.isle line 1326.
                                return v1069;
                            }
                            I16 => {
                                let v797 = C::mie3_disabled(ctx, v3);
                                if let Some(v798) = v797 {
                                    let v66 = C::put_in_reg(ctx, v64);
                                    let v1067 = constructor_popcnt_byte(ctx, v66);
                                    let v1074 = constructor_lshr_imm(ctx, I32, v1067, 0x8_u8);
                                    let v1075 = constructor_add_reg(ctx, I32, v1067, v1074);
                                    let v1077 = C::uimm16shifted(ctx, 0xff_u16, 0x0_u8);
                                    let v1078 = constructor_and_uimm16shifted(ctx, I32, v1075, v1077);
                                    let v1079 = constructor_output_reg(ctx, v1078);
                                    let v1080 = Some(v1079);
                                    // Rule at src\isa\s390x\lower.isle line 1342.
                                    return v1080;
                                }
                            }
                            I32 => {
                                let v797 = C::mie3_disabled(ctx, v3);
                                if let Some(v798) = v797 {
                                    let v66 = C::put_in_reg(ctx, v64);
                                    let v1067 = constructor_popcnt_byte(ctx, v66);
                                    let v1082 = constructor_lshl_imm(ctx, I32, v1067, 0x10_u8);
                                    let v1083 = constructor_add_reg(ctx, I32, v1067, v1082);
                                    let v1084 = constructor_lshl_imm(ctx, I32, v1083, 0x8_u8);
                                    let v1085 = constructor_add_reg(ctx, I32, v1083, v1084);
                                    let v1087 = constructor_lshr_imm(ctx, I32, v1085, 0x18_u8);
                                    let v1088 = constructor_output_reg(ctx, v1087);
                                    let v1089 = Some(v1088);
                                    // Rule at src\isa\s390x\lower.isle line 1347.
                                    return v1089;
                                }
                            }
                            I64 => {
                                let v797 = C::mie3_disabled(ctx, v3);
                                if let Some(v798) = v797 {
                                    let v66 = C::put_in_reg(ctx, v64);
                                    let v1067 = constructor_popcnt_byte(ctx, v66);
                                    let v1090 = constructor_lshl_imm(ctx, I64, v1067, 0x20_u8);
                                    let v1091 = constructor_add_reg(ctx, I64, v1067, v1090);
                                    let v1092 = constructor_lshl_imm(ctx, I64, v1091, 0x10_u8);
                                    let v1093 = constructor_add_reg(ctx, I64, v1091, v1092);
                                    let v1094 = constructor_lshl_imm(ctx, I64, v1093, 0x8_u8);
                                    let v1095 = constructor_add_reg(ctx, I64, v1093, v1094);
                                    let v1097 = constructor_lshr_imm(ctx, I64, v1095, 0x38_u8);
                                    let v1098 = constructor_output_reg(ctx, v1097);
                                    let v1099 = Some(v1098);
                                    // Rule at src\isa\s390x\lower.isle line 1353.
                                    return v1099;
                                }
                            }
                            I128 => {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v1103 = constructor_vec_popcnt(ctx, I64X2, v66);
                                let v1010 = constructor_vec_imm(ctx, I64X2, 0x0_u128);
                                let v1104 = constructor_vec_permute_dw_imm(ctx, I64X2, v1010, 0x0_u8, v1103, 0x0_u8);
                                let v1105 = constructor_vec_permute_dw_imm(ctx, I64X2, v1010, 0x0_u8, v1103, 0x1_u8);
                                let v1106 = constructor_vec_add(ctx, I64X2, v1104, v1105);
                                let v1107 = constructor_output_reg(ctx, v1106);
                                let v1108 = Some(v1107);
                                // Rule at src\isa\s390x\lower.isle line 1365.
                                return v1108;
                            }
                            _ => {}
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v792 = C::mie3_enabled(ctx, v3);
                            if let Some(v793) = v792 {
                                let v734 = constructor_put_in_reg_zext64(ctx, v64);
                                let v1070 = constructor_popcnt_reg(ctx, v734);
                                let v1071 = constructor_output_reg(ctx, v1070);
                                let v1072 = Some(v1071);
                                // Rule at src\isa\s390x\lower.isle line 1331.
                                return v1072;
                            }
                        }
                    }
                }
                &Opcode::Sqrt => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1159 = constructor_sqrt_reg(ctx, v3, v66);
                        let v1160 = constructor_output_reg(ctx, v1159);
                        let v1161 = Some(v1160);
                        // Rule at src\isa\s390x\lower.isle line 1441.
                        return v1161;
                    }
                }
                &Opcode::Fneg => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1162 = constructor_fneg_reg(ctx, v3, v66);
                        let v1163 = constructor_output_reg(ctx, v1162);
                        let v1164 = Some(v1163);
                        // Rule at src\isa\s390x\lower.isle line 1448.
                        return v1164;
                    }
                }
                &Opcode::Fabs => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1165 = constructor_fabs_reg(ctx, v3, v66);
                        let v1166 = constructor_output_reg(ctx, v1165);
                        let v1167 = Some(v1166);
                        // Rule at src\isa\s390x\lower.isle line 1455.
                        return v1167;
                    }
                }
                &Opcode::Ceil => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1168 = constructor_ceil_reg(ctx, v3, v66);
                        let v1169 = constructor_output_reg(ctx, v1168);
                        let v1170 = Some(v1169);
                        // Rule at src\isa\s390x\lower.isle line 1462.
                        return v1170;
                    }
                }
                &Opcode::Floor => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1171 = constructor_floor_reg(ctx, v3, v66);
                        let v1172 = constructor_output_reg(ctx, v1171);
                        let v1173 = Some(v1172);
                        // Rule at src\isa\s390x\lower.isle line 1469.
                        return v1173;
                    }
                }
                &Opcode::Trunc => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1174 = constructor_trunc_reg(ctx, v3, v66);
                        let v1175 = constructor_output_reg(ctx, v1174);
                        let v1176 = Some(v1175);
                        // Rule at src\isa\s390x\lower.isle line 1476.
                        return v1176;
                    }
                }
                &Opcode::Nearest => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v1177 = constructor_nearest_reg(ctx, v3, v66);
                        let v1178 = constructor_output_reg(ctx, v1177);
                        let v1179 = Some(v1178);
                        // Rule at src\isa\s390x\lower.isle line 1483.
                        return v1179;
                    }
                }
                &Opcode::ScalarToVector => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v1548 = C::sinkable_inst(ctx, v64);
                        if let Some(v1549) = v1548 {
                            let v1550 = &C::inst_data_value(ctx, v1549);
                            if let &InstructionData::Load {
                                opcode: ref v1551,
                                arg: v1552,
                                flags: v1553,
                                offset: v1554,
                            } = v1550 {
                                if let &Opcode::Load = v1551 {
                                    let v1561 = C::littleendian(ctx, v1553);
                                    if let Some(v1562) = v1561 {
                                        let v3 = C::value_type(ctx, v2);
                                        let v1566 = constructor_vec_imm(ctx, v3, 0x0_u128);
                                        let v1584 = &constructor_sink_load(ctx, v1549);
                                        let v1567 = C::be_lane_idx(ctx, v3, 0x0_u8);
                                        let v1588 = constructor_vec_load_lane_little(ctx, v3, v1566, v1584, v1567);
                                        let v1589 = constructor_output_reg(ctx, v1588);
                                        let v1590 = Some(v1589);
                                        // Rule at src\isa\s390x\lower.isle line 2083.
                                        return v1590;
                                    }
                                    let v1555 = C::bigendian(ctx, v1553);
                                    if let Some(v1556) = v1555 {
                                        let v3 = C::value_type(ctx, v2);
                                        let v1566 = constructor_vec_imm(ctx, v3, 0x0_u128);
                                        let v1584 = &constructor_sink_load(ctx, v1549);
                                        let v1567 = C::be_lane_idx(ctx, v3, 0x0_u8);
                                        let v1585 = constructor_vec_load_lane(ctx, v3, v1566, v1584, v1567);
                                        let v1586 = constructor_output_reg(ctx, v1585);
                                        let v1587 = Some(v1586);
                                        // Rule at src\isa\s390x\lower.isle line 2079.
                                        return v1587;
                                    }
                                }
                            }
                        }
                        let v1543 = C::i16_from_value(ctx, v64);
                        if let Some(v1544) = v1543 {
                            let v3 = C::value_type(ctx, v2);
                            let v1566 = constructor_vec_imm(ctx, v3, 0x0_u128);
                            let v1580 = C::be_lane_idx(ctx, v3, 0x0_u8);
                            let v1581 = constructor_vec_insert_lane_imm(ctx, v3, v1566, v1544, v1580);
                            let v1582 = constructor_output_reg(ctx, v1581);
                            let v1583 = Some(v1582);
                            // Rule at src\isa\s390x\lower.isle line 2075.
                            return v1583;
                        }
                        let v309 = C::def_inst(ctx, v64);
                        if let Some(v310) = v309 {
                            let v311 = &C::inst_data_value(ctx, v310);
                            if let &InstructionData::BinaryImm8 {
                                opcode: ref v1534,
                                arg: v1535,
                                imm: v1536,
                            } = v311 {
                                if let &Opcode::Extractlane = v1534 {
                                    let v3 = C::value_type(ctx, v2);
                                    let v1571 = C::be_lane_idx(ctx, v3, 0x0_u8);
                                    let v1575 = C::put_in_reg(ctx, v1535);
                                    let v1537 = C::u8_from_uimm8(ctx, v1536);
                                    let v1576 = C::be_lane_idx(ctx, v3, v1537);
                                    let v1577 = constructor_vec_move_lane_and_zero(ctx, v3, v1571, v1575, v1576);
                                    let v1578 = constructor_output_reg(ctx, v1577);
                                    let v1579 = Some(v1578);
                                    // Rule at src\isa\s390x\lower.isle line 2070.
                                    return v1579;
                                }
                            }
                        }
                        let v65 = C::value_type(ctx, v64);
                        let v1523 = C::ty_int_ref_scalar_64(ctx, v65);
                        if let Some(v1524) = v1523 {
                            let v3 = C::value_type(ctx, v2);
                            let v1566 = constructor_vec_imm(ctx, v3, 0x0_u128);
                            let v325 = C::put_in_reg(ctx, v64);
                            let v1567 = C::be_lane_idx(ctx, v3, 0x0_u8);
                            let v72 = C::zero_reg(ctx);
                            let v1568 = constructor_vec_insert_lane(ctx, v3, v1566, v325, v1567, v72);
                            let v1569 = constructor_output_reg(ctx, v1568);
                            let v1570 = Some(v1569);
                            // Rule at src\isa\s390x\lower.isle line 2059.
                            return v1570;
                        }
                        let v1529 = C::ty_scalar_float(ctx, v65);
                        if let Some(v1530) = v1529 {
                            let v3 = C::value_type(ctx, v2);
                            let v1571 = C::be_lane_idx(ctx, v3, 0x0_u8);
                            let v325 = C::put_in_reg(ctx, v64);
                            let v1572 = constructor_vec_move_lane_and_zero(ctx, v3, v1571, v325, 0x0_u8);
                            let v1573 = constructor_output_reg(ctx, v1572);
                            let v1574 = Some(v1573);
                            // Rule at src\isa\s390x\lower.isle line 2065.
                            return v1574;
                        }
                    }
                }
                &Opcode::Bmask => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v986 = &constructor_value_nonzero(ctx, v64);
                        let v3 = C::value_type(ctx, v2);
                        let v987 = constructor_lower_bool_to_mask(ctx, v3, v986);
                        let v988 = constructor_output_reg(ctx, v987);
                        let v989 = Some(v988);
                        // Rule at src\isa\s390x\lower.isle line 1163.
                        return v989;
                    }
                }
                &Opcode::Ireduce => {
                    let v65 = C::value_type(ctx, v64);
                    let v718 = C::fits_in_64(ctx, v65);
                    if let Some(v719) = v718 {
                        let v720 = constructor_output_value(ctx, v64);
                        let v721 = Some(v720);
                        // Rule at src\isa\s390x\lower.isle line 896.
                        return v721;
                    }
                    let v722 = C::vr128_ty(ctx, v65);
                    if let Some(v723) = v722 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v69 = C::zero_reg(ctx);
                        let v724 = constructor_vec_extract_lane(ctx, I64X2, v66, 0x1_u8, v69);
                        let v725 = constructor_output_reg(ctx, v724);
                        let v726 = Some(v725);
                        // Rule at src\isa\s390x\lower.isle line 900.
                        return v726;
                    }
                }
                &Opcode::SwidenLow => {
                    let v65 = C::value_type(ctx, v64);
                    let v778 = C::ty_vec128(ctx, v65);
                    if let Some(v779) = v778 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v780 = constructor_vec_unpacks_low_lane_order(ctx, v779, v66);
                        let v781 = constructor_output_reg(ctx, v780);
                        let v782 = Some(v781);
                        // Rule at src\isa\s390x\lower.isle line 962.
                        return v782;
                    }
                }
                &Opcode::SwidenHigh => {
                    let v65 = C::value_type(ctx, v64);
                    let v778 = C::ty_vec128(ctx, v65);
                    if let Some(v779) = v778 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v783 = constructor_vec_unpacks_high_lane_order(ctx, v779, v66);
                        let v784 = constructor_output_reg(ctx, v783);
                        let v785 = Some(v784);
                        // Rule at src\isa\s390x\lower.isle line 968.
                        return v785;
                    }
                }
                &Opcode::UwidenLow => {
                    let v65 = C::value_type(ctx, v64);
                    let v778 = C::ty_vec128(ctx, v65);
                    if let Some(v779) = v778 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v786 = constructor_vec_unpacku_low_lane_order(ctx, v779, v66);
                        let v787 = constructor_output_reg(ctx, v786);
                        let v788 = Some(v787);
                        // Rule at src\isa\s390x\lower.isle line 974.
                        return v788;
                    }
                }
                &Opcode::UwidenHigh => {
                    let v65 = C::value_type(ctx, v64);
                    let v778 = C::ty_vec128(ctx, v65);
                    if let Some(v779) = v778 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v789 = constructor_vec_unpacku_high_lane_order(ctx, v779, v66);
                        let v790 = constructor_output_reg(ctx, v789);
                        let v791 = Some(v790);
                        // Rule at src\isa\s390x\lower.isle line 980.
                        return v791;
                    }
                }
                &Opcode::Uextend => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v734 = constructor_put_in_reg_zext64(ctx, v64);
                            let v735 = constructor_output_reg(ctx, v734);
                            let v736 = Some(v735);
                            // Rule at src\isa\s390x\lower.isle line 911.
                            return v736;
                        }
                        let v727 = C::gpr32_ty(ctx, v3);
                        if let Some(v728) = v727 {
                            let v729 = constructor_put_in_reg_zext32(ctx, v64);
                            let v730 = constructor_output_reg(ctx, v729);
                            let v731 = Some(v730);
                            // Rule at src\isa\s390x\lower.isle line 907.
                            return v731;
                        }
                        if v3 == I128 {
                            let v65 = C::value_type(ctx, v64);
                            match v65 {
                                I8 => {
                                    let v324 = constructor_vec_imm(ctx, I128, 0x0_u128);
                                    let v325 = C::put_in_reg(ctx, v64);
                                    let v738 = C::zero_reg(ctx);
                                    let v739 = constructor_vec_insert_lane(ctx, I8X16, v324, v325, 0xf_u8, v738);
                                    let v740 = constructor_output_reg(ctx, v739);
                                    let v741 = Some(v740);
                                    // Rule at src\isa\s390x\lower.isle line 915.
                                    return v741;
                                }
                                I16 => {
                                    let v324 = constructor_vec_imm(ctx, I128, 0x0_u128);
                                    let v325 = C::put_in_reg(ctx, v64);
                                    let v738 = C::zero_reg(ctx);
                                    let v743 = constructor_vec_insert_lane(ctx, I16X8, v324, v325, 0x7_u8, v738);
                                    let v744 = constructor_output_reg(ctx, v743);
                                    let v745 = Some(v744);
                                    // Rule at src\isa\s390x\lower.isle line 917.
                                    return v745;
                                }
                                I32 => {
                                    let v324 = constructor_vec_imm(ctx, I128, 0x0_u128);
                                    let v325 = C::put_in_reg(ctx, v64);
                                    let v738 = C::zero_reg(ctx);
                                    let v747 = constructor_vec_insert_lane(ctx, I32X4, v324, v325, 0x3_u8, v738);
                                    let v748 = constructor_output_reg(ctx, v747);
                                    let v749 = Some(v748);
                                    // Rule at src\isa\s390x\lower.isle line 919.
                                    return v749;
                                }
                                I64 => {
                                    let v324 = constructor_vec_imm(ctx, I128, 0x0_u128);
                                    let v325 = C::put_in_reg(ctx, v64);
                                    let v738 = C::zero_reg(ctx);
                                    let v750 = constructor_vec_insert_lane(ctx, I64X2, v324, v325, 0x1_u8, v738);
                                    let v751 = constructor_output_reg(ctx, v750);
                                    let v752 = Some(v751);
                                    // Rule at src\isa\s390x\lower.isle line 921.
                                    return v752;
                                }
                                _ => {}
                            }
                        }
                    }
                }
                &Opcode::Sextend => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v732 = C::gpr64_ty(ctx, v3);
                        if let Some(v733) = v732 {
                            let v756 = constructor_put_in_reg_sext64(ctx, v64);
                            let v757 = constructor_output_reg(ctx, v756);
                            let v758 = Some(v757);
                            // Rule at src\isa\s390x\lower.isle line 932.
                            return v758;
                        }
                        let v727 = C::gpr32_ty(ctx, v3);
                        if let Some(v728) = v727 {
                            let v753 = constructor_put_in_reg_sext32(ctx, v64);
                            let v754 = constructor_output_reg(ctx, v753);
                            let v755 = Some(v754);
                            // Rule at src\isa\s390x\lower.isle line 928.
                            return v755;
                        }
                        if v3 == I128 {
                            let v756 = constructor_put_in_reg_sext64(ctx, v64);
                            let v760 = constructor_ashr_imm(ctx, I64, v756, 0x3f_u8);
                            let v761 = constructor_mov_to_vec128(ctx, I128, v760, v756);
                            let v762 = constructor_output_reg(ctx, v761);
                            let v763 = Some(v762);
                            // Rule at src\isa\s390x\lower.isle line 936.
                            return v763;
                        }
                    }
                }
                &Opcode::Fpromote => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == F128 {
                            let v65 = C::value_type(ctx, v64);
                            if v65 == F32 {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v1183 = constructor_fpromote_reg(ctx, F64, F32, v66);
                                let v1184 = constructor_fpromote_reg(ctx, F128, F64, v1183);
                                let v1185 = constructor_output_reg(ctx, v1184);
                                let v1186 = Some(v1185);
                                // Rule at src\isa\s390x\lower.isle line 1493.
                                return v1186;
                            }
                        }
                        let v66 = C::put_in_reg(ctx, v64);
                        let v65 = C::value_type(ctx, v64);
                        let v1180 = constructor_fpromote_reg(ctx, v3, v65, v66);
                        let v1181 = constructor_output_reg(ctx, v1180);
                        let v1182 = Some(v1181);
                        // Rule at src\isa\s390x\lower.isle line 1490.
                        return v1182;
                    }
                }
                &Opcode::Fdemote => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == F32 {
                            let v65 = C::value_type(ctx, v64);
                            if v65 == F128 {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v1196 = constructor_fdemote_reg(ctx, F64, F128, &FpuRoundMode::ShorterPrecision, v66);
                                let v1197 = constructor_fdemote_reg(ctx, F32, F64, &FpuRoundMode::Current, v1196);
                                let v1198 = constructor_output_reg(ctx, v1197);
                                let v1199 = Some(v1198);
                                // Rule at src\isa\s390x\lower.isle line 1510.
                                return v1199;
                            }
                        }
                        let v66 = C::put_in_reg(ctx, v64);
                        let v65 = C::value_type(ctx, v64);
                        let v1192 = constructor_fdemote_reg(ctx, v3, v65, &FpuRoundMode::Current, v66);
                        let v1193 = constructor_output_reg(ctx, v1192);
                        let v1194 = Some(v1193);
                        // Rule at src\isa\s390x\lower.isle line 1507.
                        return v1194;
                    }
                }
                &Opcode::Fvdemote => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == F32X4 {
                            let v65 = C::value_type(ctx, v64);
                            if v65 == F64X2 {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v1200 = constructor_fdemote_reg(ctx, F32X4, F64X2, &FpuRoundMode::Current, v66);
                                let v1201 = constructor_vec_lshr_imm(ctx, I64X2, v1200, 0x20_u8);
                                let v1202 = constructor_vec_imm(ctx, I64X2, 0x0_u128);
                                let v1203 = constructor_vec_pack_lane_order(ctx, I64X2, v1201, v1202);
                                let v1204 = constructor_output_reg(ctx, v1203);
                                let v1205 = Some(v1204);
                                // Rule at src\isa\s390x\lower.isle line 1518.
                                return v1205;
                            }
                        }
                    }
                }
                &Opcode::FvpromoteLow => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        if v3 == F64X2 {
                            let v65 = C::value_type(ctx, v64);
                            if v65 == F32X4 {
                                let v66 = C::put_in_reg(ctx, v64);
                                let v325 = C::put_in_reg(ctx, v64);
                                let v1187 = constructor_vec_merge_low_lane_order(ctx, I32X4, v66, v325);
                                let v1188 = constructor_fpromote_reg(ctx, F64X2, F32X4, v1187);
                                let v1189 = constructor_output_reg(ctx, v1188);
                                let v1190 = Some(v1189);
                                // Rule at src\isa\s390x\lower.isle line 1500.
                                return v1190;
                            }
                        }
                    }
                }
                &Opcode::FcvtToUint => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v65 = C::value_type(ctx, v64);
                            let v1289 = &constructor_fcmp_reg(ctx, v65, v66, v66);
                            let v1291 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                            let v1292 = &C::trap_code_bad_conversion_to_integer(ctx);
                            let v1293 = constructor_trap_if(ctx, v1289, v1291, v1292);
                            let v1294 = constructor_fcvt_to_uint_ub(ctx, v65, v79);
                            let v1295 = &constructor_fcmp_reg(ctx, v65, v66, v1294);
                            let v1297 = &C::floatcc_as_cond(ctx, &FloatCC::GreaterThanOrEqual);
                            let v1298 = &C::trap_code_integer_overflow(ctx);
                            let v1299 = constructor_trap_if(ctx, v1295, v1297, v1298);
                            let v1300 = constructor_fcvt_to_uint_lb(ctx, v65);
                            let v1301 = &constructor_fcmp_reg(ctx, v65, v66, v1300);
                            let v1303 = &C::floatcc_as_cond(ctx, &FloatCC::LessThanOrEqual);
                            let v1304 = constructor_trap_if(ctx, v1301, v1303, v1298);
                            let v1305 = constructor_fcvt_flt_ty(ctx, v79, v65);
                            let v1306 = constructor_fcvt_int_ty(ctx, v79, v65);
                            let v1307 = constructor_fpromote_reg(ctx, v1305, v65, v66);
                            let v1309 = constructor_fcvt_to_uint_reg(ctx, v1306, v1305, &FpuRoundMode::ToZero, v1307);
                            let v1310 = constructor_output_reg(ctx, v1309);
                            let v1311 = Some(v1310);
                            // Rule at src\isa\s390x\lower.isle line 1630.
                            return v1311;
                        }
                    }
                }
                &Opcode::FcvtToSint => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v65 = C::value_type(ctx, v64);
                            let v1289 = &constructor_fcmp_reg(ctx, v65, v66, v66);
                            let v1291 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                            let v1292 = &C::trap_code_bad_conversion_to_integer(ctx);
                            let v1293 = constructor_trap_if(ctx, v1289, v1291, v1292);
                            let v1312 = constructor_fcvt_to_sint_ub(ctx, v65, v79);
                            let v1313 = &constructor_fcmp_reg(ctx, v65, v66, v1312);
                            let v1297 = &C::floatcc_as_cond(ctx, &FloatCC::GreaterThanOrEqual);
                            let v1298 = &C::trap_code_integer_overflow(ctx);
                            let v1314 = constructor_trap_if(ctx, v1313, v1297, v1298);
                            let v1315 = constructor_fcvt_to_sint_lb(ctx, v65, v79);
                            let v1316 = &constructor_fcmp_reg(ctx, v65, v66, v1315);
                            let v1303 = &C::floatcc_as_cond(ctx, &FloatCC::LessThanOrEqual);
                            let v1317 = constructor_trap_if(ctx, v1316, v1303, v1298);
                            let v1305 = constructor_fcvt_flt_ty(ctx, v79, v65);
                            let v1306 = constructor_fcvt_int_ty(ctx, v79, v65);
                            let v1307 = constructor_fpromote_reg(ctx, v1305, v65, v66);
                            let v1318 = constructor_fcvt_to_sint_reg(ctx, v1306, v1305, &FpuRoundMode::ToZero, v1307);
                            let v1319 = constructor_output_reg(ctx, v1318);
                            let v1320 = Some(v1319);
                            // Rule at src\isa\s390x\lower.isle line 1655.
                            return v1320;
                        }
                    }
                }
                &Opcode::FcvtToUintSat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            I32X4 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == F32X4 {
                                    let v1227 = C::vxrs_ext2_enabled(ctx, v3);
                                    if let Some(v1228) = v1227 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v1328 = constructor_fcvt_to_uint_reg(ctx, I32X4, F32X4, &FpuRoundMode::ToZero, v66);
                                        let v1329 = constructor_output_reg(ctx, v1328);
                                        let v1330 = Some(v1329);
                                        // Rule at src\isa\s390x\lower.isle line 1692.
                                        return v1330;
                                    }
                                    let v1232 = C::vxrs_ext2_disabled(ctx, v3);
                                    if let Some(v1233) = v1232 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v325 = C::put_in_reg(ctx, v64);
                                        let v1331 = constructor_vec_merge_high(ctx, I32X4, v66, v325);
                                        let v1332 = constructor_fpromote_reg(ctx, F64X2, F32X4, v1331);
                                        let v1333 = constructor_fcvt_to_uint_reg(ctx, I64X2, F64X2, &FpuRoundMode::ToZero, v1332);
                                        let v1334 = C::put_in_reg(ctx, v64);
                                        let v1335 = C::put_in_reg(ctx, v64);
                                        let v1336 = constructor_vec_merge_low(ctx, I32X4, v1334, v1335);
                                        let v1337 = constructor_fpromote_reg(ctx, F64X2, F32X4, v1336);
                                        let v1338 = constructor_fcvt_to_uint_reg(ctx, I64X2, F64X2, &FpuRoundMode::ToZero, v1337);
                                        let v1339 = constructor_vec_pack_usat(ctx, I64X2, v1333, v1338);
                                        let v1340 = constructor_output_reg(ctx, v1339);
                                        let v1341 = Some(v1340);
                                        // Rule at src\isa\s390x\lower.isle line 1697.
                                        return v1341;
                                    }
                                }
                            }
                            I64X2 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == F64X2 {
                                    let v66 = C::put_in_reg(ctx, v64);
                                    let v1342 = constructor_fcvt_to_uint_reg(ctx, I64X2, F64X2, &FpuRoundMode::ToZero, v66);
                                    let v1343 = constructor_output_reg(ctx, v1342);
                                    let v1344 = Some(v1343);
                                    // Rule at src\isa\s390x\lower.isle line 1706.
                                    return v1344;
                                }
                            }
                            _ => {}
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v65 = C::value_type(ctx, v64);
                            let v1321 = constructor_fcvt_flt_ty(ctx, v79, v65);
                            let v1322 = constructor_fcvt_int_ty(ctx, v79, v65);
                            let v1323 = constructor_fpromote_reg(ctx, v1321, v65, v66);
                            let v1324 = constructor_fcvt_to_uint_reg(ctx, v1322, v1321, &FpuRoundMode::ToZero, v1323);
                            let v1325 = constructor_uint_sat_reg(ctx, v79, v1322, v1324);
                            let v1326 = constructor_output_reg(ctx, v1325);
                            let v1327 = Some(v1326);
                            // Rule at src\isa\s390x\lower.isle line 1680.
                            return v1327;
                        }
                    }
                }
                &Opcode::FcvtToSintSat => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            I32X4 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == F32X4 {
                                    let v1227 = C::vxrs_ext2_enabled(ctx, v3);
                                    if let Some(v1228) = v1227 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v1354 = constructor_fcvt_to_sint_reg(ctx, I32X4, F32X4, &FpuRoundMode::ToZero, v66);
                                        let v1355 = constructor_vec_imm(ctx, I32X4, 0x0_u128);
                                        let v1356 = C::put_in_reg(ctx, v64);
                                        let v1237 = C::put_in_reg(ctx, v64);
                                        let v1357 = constructor_vec_fcmpeq(ctx, F32X4, v1356, v1237);
                                        let v1358 = constructor_vec_select(ctx, I32X4, v1354, v1355, v1357);
                                        let v1359 = constructor_output_reg(ctx, v1358);
                                        let v1360 = Some(v1359);
                                        // Rule at src\isa\s390x\lower.isle line 1732.
                                        return v1360;
                                    }
                                    let v1232 = C::vxrs_ext2_disabled(ctx, v3);
                                    if let Some(v1233) = v1232 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v325 = C::put_in_reg(ctx, v64);
                                        let v1331 = constructor_vec_merge_high(ctx, I32X4, v66, v325);
                                        let v1332 = constructor_fpromote_reg(ctx, F64X2, F32X4, v1331);
                                        let v1361 = constructor_fcvt_to_sint_reg(ctx, I64X2, F64X2, &FpuRoundMode::ToZero, v1332);
                                        let v1334 = C::put_in_reg(ctx, v64);
                                        let v1335 = C::put_in_reg(ctx, v64);
                                        let v1336 = constructor_vec_merge_low(ctx, I32X4, v1334, v1335);
                                        let v1337 = constructor_fpromote_reg(ctx, F64X2, F32X4, v1336);
                                        let v1362 = constructor_fcvt_to_sint_reg(ctx, I64X2, F64X2, &FpuRoundMode::ToZero, v1337);
                                        let v1363 = constructor_vec_pack_ssat(ctx, I64X2, v1361, v1362);
                                        let v1364 = constructor_vec_imm(ctx, I32X4, 0x0_u128);
                                        let v1365 = C::put_in_reg(ctx, v64);
                                        let v1366 = C::put_in_reg(ctx, v64);
                                        let v1367 = constructor_vec_fcmpeq(ctx, F32X4, v1365, v1366);
                                        let v1368 = constructor_vec_select(ctx, I32X4, v1363, v1364, v1367);
                                        let v1369 = constructor_output_reg(ctx, v1368);
                                        let v1370 = Some(v1369);
                                        // Rule at src\isa\s390x\lower.isle line 1740.
                                        return v1370;
                                    }
                                }
                            }
                            I64X2 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == F64X2 {
                                    let v66 = C::put_in_reg(ctx, v64);
                                    let v1371 = constructor_fcvt_to_sint_reg(ctx, I64X2, F64X2, &FpuRoundMode::ToZero, v66);
                                    let v1010 = constructor_vec_imm(ctx, I64X2, 0x0_u128);
                                    let v1356 = C::put_in_reg(ctx, v64);
                                    let v1237 = C::put_in_reg(ctx, v64);
                                    let v1372 = constructor_vec_fcmpeq(ctx, F64X2, v1356, v1237);
                                    let v1373 = constructor_vec_select(ctx, I64X2, v1371, v1010, v1372);
                                    let v1374 = constructor_output_reg(ctx, v1373);
                                    let v1375 = Some(v1374);
                                    // Rule at src\isa\s390x\lower.isle line 1752.
                                    return v1375;
                                }
                            }
                            _ => {}
                        }
                        let v78 = C::fits_in_64(ctx, v3);
                        if let Some(v79) = v78 {
                            let v66 = C::put_in_reg(ctx, v64);
                            let v65 = C::value_type(ctx, v64);
                            let v1321 = constructor_fcvt_flt_ty(ctx, v79, v65);
                            let v1322 = constructor_fcvt_int_ty(ctx, v79, v65);
                            let v1323 = constructor_fpromote_reg(ctx, v1321, v65, v66);
                            let v1345 = constructor_fcvt_to_sint_reg(ctx, v1322, v1321, &FpuRoundMode::ToZero, v1323);
                            let v1346 = &constructor_fcmp_reg(ctx, v65, v66, v66);
                            let v1347 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                            let v1349 = &constructor_cmov_imm(ctx, v1322, v1347, 0_i16, v1345);
                            let v1350 = constructor_with_flags_reg(ctx, v1346, v1349);
                            let v1351 = constructor_sint_sat_reg(ctx, v79, v1322, v1350);
                            let v1352 = constructor_output_reg(ctx, v1351);
                            let v1353 = Some(v1352);
                            // Rule at src\isa\s390x\lower.isle line 1713.
                            return v1353;
                        }
                    }
                }
                &Opcode::FcvtFromUint => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            F32 => {
                                let v65 = C::value_type(ctx, v64);
                                let v1206 = C::vxrs_ext2_enabled(ctx, v65);
                                if let Some(v1207) = v1206 {
                                    let v1208 = C::fits_in_32(ctx, v65);
                                    if let Some(v1209) = v1208 {
                                        let v729 = constructor_put_in_reg_zext32(ctx, v64);
                                        let v1211 = constructor_fcvt_from_uint_reg(ctx, F32, I32, &FpuRoundMode::ToNearestTiesToEven, v729);
                                        let v1212 = constructor_output_reg(ctx, v1211);
                                        let v1213 = Some(v1212);
                                        // Rule at src\isa\s390x\lower.isle line 1527.
                                        return v1213;
                                    }
                                }
                                let v718 = C::fits_in_64(ctx, v65);
                                if let Some(v719) = v718 {
                                    let v734 = constructor_put_in_reg_zext64(ctx, v64);
                                    let v1214 = constructor_fcvt_from_uint_reg(ctx, F64, I64, &FpuRoundMode::ShorterPrecision, v734);
                                    let v1215 = constructor_fdemote_reg(ctx, F32, F64, &FpuRoundMode::ToNearestTiesToEven, v1214);
                                    let v1216 = constructor_output_reg(ctx, v1215);
                                    let v1217 = Some(v1216);
                                    // Rule at src\isa\s390x\lower.isle line 1533.
                                    return v1217;
                                }
                            }
                            F64 => {
                                let v65 = C::value_type(ctx, v64);
                                let v718 = C::fits_in_64(ctx, v65);
                                if let Some(v719) = v718 {
                                    let v734 = constructor_put_in_reg_zext64(ctx, v64);
                                    let v1218 = constructor_fcvt_from_uint_reg(ctx, F64, I64, &FpuRoundMode::ToNearestTiesToEven, v734);
                                    let v1219 = constructor_output_reg(ctx, v1218);
                                    let v1220 = Some(v1219);
                                    // Rule at src\isa\s390x\lower.isle line 1539.
                                    return v1220;
                                }
                            }
                            F128 => {
                                let v65 = C::value_type(ctx, v64);
                                let v1208 = C::fits_in_32(ctx, v65);
                                if let Some(v1209) = v1208 {
                                    let v729 = constructor_put_in_reg_zext32(ctx, v64);
                                    let v1221 = constructor_fcvt_from_uint_reg(ctx, F128, I32, &FpuRoundMode::ToNearestTiesToEven, v729);
                                    let v1222 = constructor_output_reg(ctx, v1221);
                                    let v1223 = Some(v1222);
                                    // Rule at src\isa\s390x\lower.isle line 1544.
                                    return v1223;
                                }
                                let v718 = C::fits_in_64(ctx, v65);
                                if let Some(v719) = v718 {
                                    let v734 = constructor_put_in_reg_zext64(ctx, v64);
                                    let v1224 = constructor_fcvt_from_uint_reg(ctx, F128, I64, &FpuRoundMode::ToNearestTiesToEven, v734);
                                    let v1225 = constructor_output_reg(ctx, v1224);
                                    let v1226 = Some(v1225);
                                    // Rule at src\isa\s390x\lower.isle line 1549.
                                    return v1226;
                                }
                            }
                            F32X4 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == I32X4 {
                                    let v1227 = C::vxrs_ext2_enabled(ctx, v3);
                                    if let Some(v1228) = v1227 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v1229 = constructor_fcvt_from_uint_reg(ctx, F32X4, I32X4, &FpuRoundMode::ToNearestTiesToEven, v66);
                                        let v1230 = constructor_output_reg(ctx, v1229);
                                        let v1231 = Some(v1230);
                                        // Rule at src\isa\s390x\lower.isle line 1554.
                                        return v1231;
                                    }
                                    let v1232 = C::vxrs_ext2_disabled(ctx, v3);
                                    if let Some(v1233) = v1232 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v1234 = constructor_vec_unpacku_high(ctx, I32X4, v66);
                                        let v1235 = constructor_fcvt_from_uint_reg(ctx, F64X2, I64X2, &FpuRoundMode::ShorterPrecision, v1234);
                                        let v1236 = constructor_fdemote_reg(ctx, F32X4, F64X2, &FpuRoundMode::ToNearestTiesToEven, v1235);
                                        let v1237 = C::put_in_reg(ctx, v64);
                                        let v1238 = constructor_vec_unpacku_low(ctx, I32X4, v1237);
                                        let v1239 = constructor_fcvt_from_uint_reg(ctx, F64X2, I64X2, &FpuRoundMode::ShorterPrecision, v1238);
                                        let v1240 = constructor_fdemote_reg(ctx, F32X4, F64X2, &FpuRoundMode::ToNearestTiesToEven, v1239);
                                        let v1250 = constructor_imm8x16(ctx, 0x0_u8, 0x1_u8, 0x2_u8, 0x3_u8, 0x8_u8, 0x9_u8, 0xa_u8, 0xb_u8, 0x10_u8, 0x11_u8, 0x12_u8, 0x13_u8, 0x18_u8, 0x19_u8, 0x1a_u8, 0x1b_u8);
                                        let v1251 = constructor_vec_imm(ctx, I8X16, v1250);
                                        let v1252 = constructor_vec_permute(ctx, F32X4, v1236, v1240, v1251);
                                        let v1253 = constructor_output_reg(ctx, v1252);
                                        let v1254 = Some(v1253);
                                        // Rule at src\isa\s390x\lower.isle line 1559.
                                        return v1254;
                                    }
                                }
                            }
                            F64X2 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == I64X2 {
                                    let v66 = C::put_in_reg(ctx, v64);
                                    let v1255 = constructor_fcvt_from_uint_reg(ctx, F64X2, I64X2, &FpuRoundMode::ToNearestTiesToEven, v66);
                                    let v1256 = constructor_output_reg(ctx, v1255);
                                    let v1257 = Some(v1256);
                                    // Rule at src\isa\s390x\lower.isle line 1571.
                                    return v1257;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtFromSint => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v3 = C::value_type(ctx, v2);
                        match v3 {
                            F32 => {
                                let v65 = C::value_type(ctx, v64);
                                let v1206 = C::vxrs_ext2_enabled(ctx, v65);
                                if let Some(v1207) = v1206 {
                                    let v1208 = C::fits_in_32(ctx, v65);
                                    if let Some(v1209) = v1208 {
                                        let v753 = constructor_put_in_reg_sext32(ctx, v64);
                                        let v1258 = constructor_fcvt_from_sint_reg(ctx, F32, I32, &FpuRoundMode::ToNearestTiesToEven, v753);
                                        let v1259 = constructor_output_reg(ctx, v1258);
                                        let v1260 = Some(v1259);
                                        // Rule at src\isa\s390x\lower.isle line 1578.
                                        return v1260;
                                    }
                                }
                                let v718 = C::fits_in_64(ctx, v65);
                                if let Some(v719) = v718 {
                                    let v756 = constructor_put_in_reg_sext64(ctx, v64);
                                    let v1261 = constructor_fcvt_from_sint_reg(ctx, F64, I64, &FpuRoundMode::ShorterPrecision, v756);
                                    let v1262 = constructor_fdemote_reg(ctx, F32, F64, &FpuRoundMode::ToNearestTiesToEven, v1261);
                                    let v1263 = constructor_output_reg(ctx, v1262);
                                    let v1264 = Some(v1263);
                                    // Rule at src\isa\s390x\lower.isle line 1584.
                                    return v1264;
                                }
                            }
                            F64 => {
                                let v65 = C::value_type(ctx, v64);
                                let v718 = C::fits_in_64(ctx, v65);
                                if let Some(v719) = v718 {
                                    let v756 = constructor_put_in_reg_sext64(ctx, v64);
                                    let v1265 = constructor_fcvt_from_sint_reg(ctx, F64, I64, &FpuRoundMode::ToNearestTiesToEven, v756);
                                    let v1266 = constructor_output_reg(ctx, v1265);
                                    let v1267 = Some(v1266);
                                    // Rule at src\isa\s390x\lower.isle line 1590.
                                    return v1267;
                                }
                            }
                            F128 => {
                                let v65 = C::value_type(ctx, v64);
                                let v1208 = C::fits_in_32(ctx, v65);
                                if let Some(v1209) = v1208 {
                                    let v753 = constructor_put_in_reg_sext32(ctx, v64);
                                    let v1268 = constructor_fcvt_from_sint_reg(ctx, F128, I32, &FpuRoundMode::ToNearestTiesToEven, v753);
                                    let v1269 = constructor_output_reg(ctx, v1268);
                                    let v1270 = Some(v1269);
                                    // Rule at src\isa\s390x\lower.isle line 1595.
                                    return v1270;
                                }
                                let v718 = C::fits_in_64(ctx, v65);
                                if let Some(v719) = v718 {
                                    let v756 = constructor_put_in_reg_sext64(ctx, v64);
                                    let v1271 = constructor_fcvt_from_sint_reg(ctx, F128, I64, &FpuRoundMode::ToNearestTiesToEven, v756);
                                    let v1272 = constructor_output_reg(ctx, v1271);
                                    let v1273 = Some(v1272);
                                    // Rule at src\isa\s390x\lower.isle line 1600.
                                    return v1273;
                                }
                            }
                            F32X4 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == I32X4 {
                                    let v1227 = C::vxrs_ext2_enabled(ctx, v3);
                                    if let Some(v1228) = v1227 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v1274 = constructor_fcvt_from_sint_reg(ctx, F32X4, I32X4, &FpuRoundMode::ToNearestTiesToEven, v66);
                                        let v1275 = constructor_output_reg(ctx, v1274);
                                        let v1276 = Some(v1275);
                                        // Rule at src\isa\s390x\lower.isle line 1605.
                                        return v1276;
                                    }
                                    let v1232 = C::vxrs_ext2_disabled(ctx, v3);
                                    if let Some(v1233) = v1232 {
                                        let v66 = C::put_in_reg(ctx, v64);
                                        let v1277 = constructor_vec_unpacks_high(ctx, I32X4, v66);
                                        let v1278 = constructor_fcvt_from_sint_reg(ctx, F64X2, I64X2, &FpuRoundMode::ShorterPrecision, v1277);
                                        let v1279 = constructor_fdemote_reg(ctx, F32X4, F64X2, &FpuRoundMode::ToNearestTiesToEven, v1278);
                                        let v1237 = C::put_in_reg(ctx, v64);
                                        let v1280 = constructor_vec_unpacks_low(ctx, I32X4, v1237);
                                        let v1281 = constructor_fcvt_from_sint_reg(ctx, F64X2, I64X2, &FpuRoundMode::ShorterPrecision, v1280);
                                        let v1282 = constructor_fdemote_reg(ctx, F32X4, F64X2, &FpuRoundMode::ToNearestTiesToEven, v1281);
                                        let v1250 = constructor_imm8x16(ctx, 0x0_u8, 0x1_u8, 0x2_u8, 0x3_u8, 0x8_u8, 0x9_u8, 0xa_u8, 0xb_u8, 0x10_u8, 0x11_u8, 0x12_u8, 0x13_u8, 0x18_u8, 0x19_u8, 0x1a_u8, 0x1b_u8);
                                        let v1251 = constructor_vec_imm(ctx, I8X16, v1250);
                                        let v1283 = constructor_vec_permute(ctx, F32X4, v1279, v1282, v1251);
                                        let v1284 = constructor_output_reg(ctx, v1283);
                                        let v1285 = Some(v1284);
                                        // Rule at src\isa\s390x\lower.isle line 1610.
                                        return v1285;
                                    }
                                }
                            }
                            F64X2 => {
                                let v65 = C::value_type(ctx, v64);
                                if v65 == I64X2 {
                                    let v66 = C::put_in_reg(ctx, v64);
                                    let v1286 = constructor_fcvt_from_sint_reg(ctx, F64X2, I64X2, &FpuRoundMode::ToNearestTiesToEven, v66);
                                    let v1287 = constructor_output_reg(ctx, v1286);
                                    let v1288 = Some(v1287);
                                    // Rule at src\isa\s390x\lower.isle line 1622.
                                    return v1288;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Isplit => {
                    let v65 = C::value_type(ctx, v64);
                    if v65 == I128 {
                        let v66 = C::put_in_reg(ctx, v64);
                        let v69 = C::zero_reg(ctx);
                        let v70 = constructor_vec_extract_lane(ctx, I64X2, v66, 0x0_u8, v69);
                        let v72 = C::zero_reg(ctx);
                        let v73 = constructor_vec_extract_lane(ctx, I64X2, v66, 0x1_u8, v72);
                        let v74 = C::value_reg(ctx, v73);
                        let v75 = C::value_reg(ctx, v70);
                        let v76 = C::output_pair(ctx, v74, v75);
                        let v77 = Some(v76);
                        // Rule at src\isa\s390x\lower.isle line 62.
                        return v77;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::UnaryConst {
            opcode: ref v34,
            constant_handle: v35,
        } => {
            match v34 {
                &Opcode::F128const => {
                    let v36 = C::u128_from_constant(ctx, v35);
                    if let Some(v37) = v36 {
                        let v39 = C::be_vec_const(ctx, F128, v37);
                        let v40 = constructor_vec_imm(ctx, F128, v39);
                        let v41 = constructor_output_reg(ctx, v40);
                        let v42 = Some(v41);
                        // Rule at src\isa\s390x\lower.isle line 38.
                        return v42;
                    }
                }
                &Opcode::Vconst => {
                    let v1 = C::first_result(ctx, arg0);
                    if let Some(v2) = v1 {
                        let v36 = C::u128_from_constant(ctx, v35);
                        if let Some(v37) = v36 {
                            let v3 = C::value_type(ctx, v2);
                            let v43 = C::be_vec_const(ctx, v3, v37);
                            let v44 = constructor_vec_imm(ctx, v3, v43);
                            let v45 = constructor_output_reg(ctx, v44);
                            let v46 = Some(v45);
                            // Rule at src\isa\s390x\lower.isle line 44.
                            return v46;
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::UnaryGlobalValue {
            opcode: ref v1893,
            global_value: v1894,
        } => {
            match v1893 {
                &Opcode::SymbolValue => {
                    let v1895 = C::symbol_value_data(ctx, v1894);
                    if let Some(v1896) = v1895 {
                        if let &RelocDistance::Near = &v1896.1 {
                            let v1900 = constructor_memarg_symbol_offset(ctx, v1896.2);
                            if let Some(v1901) = v1900 {
                                let v1883 = C::memflags_trusted(ctx);
                                let v1902 = &C::memarg_symbol(ctx, v1896.0, v1901, v1883);
                                let v1903 = constructor_load_addr(ctx, v1902);
                                let v1904 = constructor_output_reg(ctx, v1903);
                                let v1905 = Some(v1904);
                                // Rule at src\isa\s390x\lower.isle line 2315.
                                return v1905;
                            }
                        }
                        let v1906 = SymbolReloc::Absolute {
                            name: v1896.0,
                            offset: v1896.2,
                        };
                        let v1907 = constructor_load_symbol_reloc(ctx, &v1906);
                        let v1908 = constructor_output_reg(ctx, v1907);
                        let v1909 = Some(v1908);
                        // Rule at src\isa\s390x\lower.isle line 2321.
                        return v1909;
                    }
                }
                &Opcode::TlsValue => {
                    let v1895 = C::symbol_value_data(ctx, v1894);
                    if let Some(v1896) = v1895 {
                        if v1896.2 == 0_i64 {
                            let v1910 = C::tls_model_is_elf_gd(ctx);
                            if let Some(v1911) = v1910 {
                                let v1913 = &C::memarg_got(ctx);
                                let v1914 = constructor_load_addr(ctx, v1913);
                                let v1912 = SymbolReloc::TlsGd {
                                    name: v1896.0,
                                };
                                let v1915 = constructor_load_symbol_reloc(ctx, &v1912);
                                let v1916 = constructor_lib_call_tls_get_offset(ctx, v1914, v1915, &v1912);
                                let v1917 = constructor_thread_pointer(ctx);
                                let v1918 = constructor_add_reg(ctx, I64, v1916, v1917);
                                let v1919 = constructor_output_reg(ctx, v1918);
                                let v1920 = Some(v1919);
                                // Rule at src\isa\s390x\lower.isle line 2328.
                                return v1920;
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::UnaryIeee16 {
            opcode: ref v11,
            imm: v12,
        } => {
            if let &Opcode::F16const = v11 {
                let v13 = C::u16_from_ieee16(ctx, v12);
                let v15 = C::u16_into_u64(ctx, v13);
                let v16 = constructor_imm(ctx, F16, v15);
                let v17 = constructor_output_reg(ctx, v16);
                let v18 = Some(v17);
                // Rule at src\isa\s390x\lower.isle line 20.
                return v18;
            }
        }
        &InstructionData::UnaryIeee32 {
            opcode: ref v19,
            imm: v20,
        } => {
            if let &Opcode::F32const = v19 {
                let v21 = C::u32_from_ieee32(ctx, v20);
                let v23 = C::u32_into_u64(ctx, v21);
                let v24 = constructor_imm(ctx, F32, v23);
                let v25 = constructor_output_reg(ctx, v24);
                let v26 = Some(v25);
                // Rule at src\isa\s390x\lower.isle line 26.
                return v26;
            }
        }
        &InstructionData::UnaryIeee64 {
            opcode: ref v27,
            imm: v28,
        } => {
            if let &Opcode::F64const = v27 {
                let v29 = C::u64_from_ieee64(ctx, v28);
                let v31 = constructor_imm(ctx, F64, v29);
                let v32 = constructor_output_reg(ctx, v31);
                let v33 = Some(v32);
                // Rule at src\isa\s390x\lower.isle line 32.
                return v33;
            }
        }
        &InstructionData::UnaryImm {
            opcode: ref v5,
            imm: v6,
        } => {
            if let &Opcode::Iconst = v5 {
                let v1 = C::first_result(ctx, arg0);
                if let Some(v2) = v1 {
                    let v3 = C::value_type(ctx, v2);
                    let v7 = C::u64_from_imm64(ctx, v6);
                    let v8 = constructor_imm(ctx, v3, v7);
                    let v9 = constructor_output_reg(ctx, v8);
                    let v10 = Some(v9);
                    // Rule at src\isa\s390x\lower.isle line 14.
                    return v10;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term lower_branch.
pub fn constructor_lower_branch<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: &MachLabelSlice,
) -> Option<Unit> {
    let v1 = &C::inst_data_value(ctx, arg0);
    match v1 {
        &InstructionData::BranchTable {
            opcode: ref v10,
            arg: v11,
            table: v12,
        } => {
            if let &Opcode::BrTable = v10 {
                let v13 = C::jump_table_targets(ctx, arg1);
                if let Some(v14) = v13 {
                    let v17 = constructor_put_in_reg_zext64(ctx, v11);
                    let v19 = C::jump_table_size(ctx, &v14.1);
                    let v20 = &constructor_icmpu_uimm32(ctx, I64, v17, v19);
                    let v22 = &C::intcc_as_cond(ctx, &IntCC::UnsignedGreaterThanOrEqual);
                    let v23 = &constructor_bool(ctx, v20, v22);
                    let v25 = constructor_lshl_imm(ctx, I64, v17, 0x2_u8);
                    let v26 = &constructor_jt_sequence_default_bool(ctx, v25, v14.0, v23, &v14.1);
                    let v27 = constructor_emit_side_effect(ctx, v26);
                    let v28 = Some(v27);
                    // Rule at src\isa\s390x\lower.isle line 3823.
                    return v28;
                }
            }
        }
        &InstructionData::Brif {
            opcode: ref v29,
            arg: v30,
            blocks: ref v31,
        } => {
            if let &Opcode::Brif = v29 {
                let v35 = C::two_targets(ctx, arg1);
                if let Some(v36) = v35 {
                    let v39 = &constructor_value_nonzero(ctx, v30);
                    let v40 = &constructor_cond_br_bool(ctx, v39, v36.0, v36.1);
                    let v41 = constructor_emit_side_effect(ctx, v40);
                    let v42 = Some(v41);
                    // Rule at src\isa\s390x\lower.isle line 3854.
                    return v42;
                }
            }
        }
        &InstructionData::Jump {
            opcode: ref v2,
            destination: v3,
        } => {
            if let &Opcode::Jump = v2 {
                let v5 = C::single_target(ctx, arg1);
                if let Some(v6) = v5 {
                    let v7 = &constructor_jump_impl(ctx, v6);
                    let v8 = constructor_emit_side_effect(ctx, v7);
                    let v9 = Some(v8);
                    // Rule at src\isa\s390x\lower.isle line 3815.
                    return v9;
                }
            }
        }
        &InstructionData::TryCall {
            opcode: ref v43,
            args: v44,
            func_ref: v45,
            exception: v46,
        } => {
            if let &Opcode::TryCall = v43 {
                let v48 = C::func_ref_data(ctx, v45);
                if let &RelocDistance::Near = &v48.2 {
                    let v52 = C::abi_sig(ctx, v48.0);
                    let v53 = C::try_call_info(ctx, v46, arg1);
                    let v54 = C::abi_emit_call_adjust_stack(ctx, v52);
                    let v47 = C::value_list_slice(ctx, v44);
                    let v55 = &C::abi_prepare_args(ctx, v52, v47);
                    let v56 = C::gen_call_args(ctx, v52, v55);
                    let v57 = C::gen_try_call_rets(ctx, v52);
                    let v58 = C::call_inst_dest_direct(ctx, v48.1);
                    let v59 = C::gen_call_info(ctx, v52, v58, v56, v57, v53);
                    let v60 = constructor_writable_link_reg(ctx);
                    let v61 = &constructor_call_impl(ctx, v60, v59);
                    let v62 = constructor_emit_side_effect(ctx, v61);
                    let v63 = Some(v62);
                    // Rule at src\isa\s390x\lower.isle line 4044.
                    return v63;
                }
                let v52 = C::abi_sig(ctx, v48.0);
                let v53 = C::try_call_info(ctx, v46, arg1);
                let v54 = C::abi_emit_call_adjust_stack(ctx, v52);
                let v47 = C::value_list_slice(ctx, v44);
                let v55 = &C::abi_prepare_args(ctx, v52, v47);
                let v56 = C::gen_call_args(ctx, v52, v55);
                let v57 = C::gen_try_call_rets(ctx, v52);
                let v65 = SymbolReloc::Absolute {
                    name: v48.1,
                    offset: 0_i64,
                };
                let v66 = constructor_load_symbol_reloc(ctx, &v65);
                let v67 = C::call_inst_dest_indirect(ctx, v66);
                let v68 = C::gen_call_info(ctx, v52, v67, v56, v57, v53);
                let v69 = constructor_writable_link_reg(ctx);
                let v70 = &constructor_call_impl(ctx, v69, v68);
                let v71 = constructor_emit_side_effect(ctx, v70);
                let v72 = Some(v71);
                // Rule at src\isa\s390x\lower.isle line 4054.
                return v72;
            }
        }
        &InstructionData::TryCallIndirect {
            opcode: ref v73,
            args: v74,
            exception: v75,
        } => {
            if let &Opcode::TryCallIndirect = v73 {
                let v76 = C::value_list_slice(ctx, v74);
                let v77 = C::value_slice_unwrap(ctx, v76);
                if let Some(v78) = v77 {
                    let v81 = C::exception_sig(ctx, v75);
                    let v82 = C::abi_sig(ctx, v81);
                    let v83 = C::try_call_info(ctx, v75, arg1);
                    let v84 = C::put_in_reg(ctx, v78.0);
                    let v85 = C::abi_emit_call_adjust_stack(ctx, v82);
                    let v86 = &C::abi_prepare_args(ctx, v82, v78.1);
                    let v87 = C::gen_call_args(ctx, v82, v86);
                    let v88 = C::gen_try_call_rets(ctx, v82);
                    let v89 = C::call_inst_dest_indirect(ctx, v84);
                    let v90 = C::gen_call_info(ctx, v82, v89, v87, v88, v83);
                    let v69 = constructor_writable_link_reg(ctx);
                    let v91 = &constructor_call_impl(ctx, v69, v90);
                    let v92 = constructor_emit_side_effect(ctx, v91);
                    let v93 = Some(v92);
                    // Rule at src\isa\s390x\lower.isle line 4065.
                    return v93;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term vec_mul_impl.
pub fn constructor_vec_mul_impl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    match arg0 {
        I128 => {
            let v12 = C::zero_reg(ctx);
            let v13 = constructor_vec_extract_lane(ctx, I64X2, arg1, 0x0_u8, v12);
            let v14 = C::zero_reg(ctx);
            let v24 = constructor_vec_extract_lane(ctx, I64X2, arg1, 0x1_u8, v14);
            let v25 = C::zero_reg(ctx);
            let v26 = constructor_vec_extract_lane(ctx, I64X2, arg2, 0x0_u8, v25);
            let v27 = C::zero_reg(ctx);
            let v28 = constructor_vec_extract_lane(ctx, I64X2, arg2, 0x1_u8, v27);
            let v29 = constructor_umul_wide(ctx, v24, v28);
            let v30 = C::regpair_lo(ctx, v29);
            let v31 = C::regpair_hi(ctx, v29);
            let v32 = constructor_mul_reg(ctx, I64, v24, v26);
            let v33 = constructor_mul_reg(ctx, I64, v13, v28);
            let v34 = constructor_add_reg(ctx, I64, v32, v31);
            let v35 = constructor_add_reg(ctx, I64, v33, v34);
            let v36 = constructor_mov_to_vec128(ctx, I64X2, v35, v30);
            // Rule at src\isa\s390x\lower.isle line 410.
            return v36;
        }
        I8X16 => {
            let v4 = constructor_vec_mul(ctx, I8X16, arg1, arg2);
            // Rule at src\isa\s390x\lower.isle line 397.
            return v4;
        }
        I16X8 => {
            let v6 = constructor_vec_mul(ctx, I16X8, arg1, arg2);
            // Rule at src\isa\s390x\lower.isle line 398.
            return v6;
        }
        I32X4 => {
            let v8 = constructor_vec_mul(ctx, I32X4, arg1, arg2);
            // Rule at src\isa\s390x\lower.isle line 399.
            return v8;
        }
        I64X2 => {
            let v12 = C::zero_reg(ctx);
            let v13 = constructor_vec_extract_lane(ctx, I64X2, arg1, 0x0_u8, v12);
            let v14 = C::zero_reg(ctx);
            let v15 = constructor_vec_extract_lane(ctx, I64X2, arg2, 0x0_u8, v14);
            let v16 = constructor_mul_reg(ctx, I64, v13, v15);
            let v18 = C::zero_reg(ctx);
            let v19 = constructor_vec_extract_lane(ctx, I64X2, arg1, 0x1_u8, v18);
            let v20 = C::zero_reg(ctx);
            let v21 = constructor_vec_extract_lane(ctx, I64X2, arg2, 0x1_u8, v20);
            let v22 = constructor_mul_reg(ctx, I64, v19, v21);
            let v23 = constructor_mov_to_vec128(ctx, I64X2, v16, v22);
            // Rule at src\isa\s390x\lower.isle line 402.
            return v23;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_mul_impl", "src\\isa\\s390x\\lower.isle line 392")
}

// Generated as internal constructor for term sqmul_impl.
pub fn constructor_sqmul_impl<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    match arg0 {
        I32X4 => {
            let v4 = constructor_vec_mul_impl(ctx, I32X4, arg1, arg2);
            let v6 = constructor_vec_imm_bit_mask(ctx, I32X4, 0x11_u8, 0x11_u8);
            let v7 = constructor_vec_add(ctx, I32X4, v4, v6);
            let v9 = constructor_vec_ashr_imm(ctx, I32X4, v7, 0xf_u8);
            // Rule at src\isa\s390x\lower.isle line 523.
            return v9;
        }
        I64X2 => {
            let v11 = constructor_vec_mul_impl(ctx, I64X2, arg1, arg2);
            let v13 = constructor_vec_imm_bit_mask(ctx, I64X2, 0x21_u8, 0x21_u8);
            let v14 = constructor_vec_add(ctx, I64X2, v11, v13);
            let v16 = constructor_vec_ashr_imm(ctx, I64X2, v14, 0x1f_u8);
            // Rule at src\isa\s390x\lower.isle line 527.
            return v16;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sqmul_impl", "src\\isa\\s390x\\lower.isle line 522")
}

// Generated as internal constructor for term div_overflow_check_needed.
pub fn constructor_div_overflow_check_needed<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> bool {
    let v1 = C::i64_from_value(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = constructor_i64_not_neg1(ctx, v2);
        if let Some(v4) = v3 {
            let v5 = false;
            // Rule at src\isa\s390x\lower.isle line 640.
            return v5;
        }
    }
    let v6 = true;
    // Rule at src\isa\s390x\lower.isle line 643.
    return v6;
}

// Generated as internal constructor for term maybe_trap_if_sdiv_overflow.
pub fn constructor_maybe_trap_if_sdiv_overflow<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: Type,
    arg2: Type,
    arg3: Reg,
    arg4: Reg,
) -> Reg {
    match arg0 {
        false => {
            let v5 = C::invalid_reg(ctx);
            // Rule at src\isa\s390x\lower.isle line 655.
            return v5;
        }
        true => {
            let v6 = constructor_int_max(ctx, arg2);
            let v7 = constructor_imm(ctx, arg1, v6);
            let v8 = constructor_xor_reg(ctx, arg1, v7, arg3);
            let v9 = constructor_and_reg(ctx, arg1, v8, arg4);
            let v12 = &C::intcc_as_cond(ctx, &IntCC::Equal);
            let v13 = &C::trap_code_integer_overflow(ctx);
            let v14 = constructor_icmps_simm16_and_trap(ctx, arg1, v9, -1_i16, v12, v13);
            // Rule at src\isa\s390x\lower.isle line 656.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "maybe_trap_if_sdiv_overflow", "src\\isa\\s390x\\lower.isle line 654")
}

// Generated as internal constructor for term int_max.
pub fn constructor_int_max<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> u64 {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\lower.isle line 663.
            return 0x7f_u64;
        }
        I16 => {
            // Rule at src\isa\s390x\lower.isle line 664.
            return 0x7fff_u64;
        }
        I32 => {
            // Rule at src\isa\s390x\lower.isle line 665.
            return 0x7fffffff_u64;
        }
        I64 => {
            // Rule at src\isa\s390x\lower.isle line 666.
            return 0x7fffffffffffffff_u64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "int_max", "src\\isa\\s390x\\lower.isle line 662")
}

// Generated as internal constructor for term maybe_avoid_srem_overflow.
pub fn constructor_maybe_avoid_srem_overflow<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: Type,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    match arg0 {
        false => {
            // Rule at src\isa\s390x\lower.isle line 683.
            return arg2;
        }
        true => {
            match arg1 {
                I32 => {
                    // Rule at src\isa\s390x\lower.isle line 684.
                    return arg2;
                }
                I64 => {
                    let v6 = &constructor_icmps_simm16(ctx, I64, arg3, -1_i16);
                    let v8 = &C::intcc_as_cond(ctx, &IntCC::Equal);
                    let v10 = &constructor_cmov_imm(ctx, I64, v8, 0_i16, arg2);
                    let v11 = constructor_with_flags_reg(ctx, v6, v10);
                    // Rule at src\isa\s390x\lower.isle line 685.
                    return v11;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "maybe_avoid_srem_overflow", "src\\isa\\s390x\\lower.isle line 682")
}

// Generated as internal constructor for term bitrev_bits.
pub fn constructor_bitrev_bits<C: Context>(
    ctx: &mut C,
    arg0: u8,
    arg1: u64,
    arg2: Type,
    arg3: Reg,
) -> Reg {
    let v3 = C::fits_in_64(ctx, arg2);
    if let Some(v4) = v3 {
        let v6 = constructor_imm(ctx, v4, arg1);
        let v7 = constructor_ty_ext32(ctx, v4);
        let v8 = constructor_lshl_imm(ctx, v7, arg3, arg0);
        let v9 = constructor_ty_ext32(ctx, v4);
        let v10 = constructor_lshr_imm(ctx, v9, arg3, arg0);
        let v11 = constructor_and_reg(ctx, v4, v8, v6);
        let v12 = constructor_not_reg(ctx, v4, v6);
        let v13 = constructor_and_reg(ctx, v4, v10, v12);
        let v14 = constructor_or_reg(ctx, v4, v11, v13);
        // Rule at src\isa\s390x\lower.isle line 1176.
        return v14;
    }
    let v15 = C::vr128_ty(ctx, arg2);
    if let Some(v16) = v15 {
        let v18 = constructor_vec_imm_splat(ctx, I64X2, arg1);
        let v20 = C::u8_into_u64(ctx, arg0);
        let v21 = constructor_vec_imm_splat(ctx, I8X16, v20);
        let v22 = constructor_vec_lshl_by_bit(ctx, arg3, v21);
        let v23 = constructor_vec_lshr_by_bit(ctx, arg3, v21);
        let v24 = constructor_vec_select(ctx, v16, v22, v23, v18);
        // Rule at src\isa\s390x\lower.isle line 1184.
        return v24;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "bitrev_bits", "src\\isa\\s390x\\lower.isle line 1175")
}

// Generated as internal constructor for term bitrev_bytes.
pub fn constructor_bitrev_bytes<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    match arg0 {
        I8 => {
            // Rule at src\isa\s390x\lower.isle line 1192.
            return arg1;
        }
        I16 => {
            let v3 = constructor_bswap_reg(ctx, I32, arg1);
            let v5 = constructor_lshr_imm(ctx, I32, v3, 0x10_u8);
            // Rule at src\isa\s390x\lower.isle line 1193.
            return v5;
        }
        I32 => {
            let v3 = constructor_bswap_reg(ctx, I32, arg1);
            // Rule at src\isa\s390x\lower.isle line 1194.
            return v3;
        }
        I64 => {
            let v7 = constructor_bswap_reg(ctx, I64, arg1);
            // Rule at src\isa\s390x\lower.isle line 1195.
            return v7;
        }
        I128 => {
            let v26 = constructor_imm8x16(ctx, 0xf_u8, 0xe_u8, 0xd_u8, 0xc_u8, 0xb_u8, 0xa_u8, 0x9_u8, 0x8_u8, 0x7_u8, 0x6_u8, 0x5_u8, 0x4_u8, 0x3_u8, 0x2_u8, 0x1_u8, 0x0_u8);
            let v27 = constructor_vec_imm(ctx, I8X16, v26);
            let v28 = constructor_vec_permute(ctx, I128, arg1, arg1, v27);
            // Rule at src\isa\s390x\lower.isle line 1196.
            return v28;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "bitrev_bytes", "src\\isa\\s390x\\lower.isle line 1191")
}

// Generated as internal constructor for term clz_offset.
pub fn constructor_clz_offset<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    match arg0 {
        I8 => {
            let v4 = constructor_add_simm16(ctx, I8, arg1, -56_i16);
            // Rule at src\isa\s390x\lower.isle line 1213.
            return v4;
        }
        I16 => {
            let v7 = constructor_add_simm16(ctx, I16, arg1, -48_i16);
            // Rule at src\isa\s390x\lower.isle line 1214.
            return v7;
        }
        I32 => {
            let v10 = constructor_add_simm16(ctx, I32, arg1, -32_i16);
            // Rule at src\isa\s390x\lower.isle line 1215.
            return v10;
        }
        I64 => {
            // Rule at src\isa\s390x\lower.isle line 1216.
            return arg1;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "clz_offset", "src\\isa\\s390x\\lower.isle line 1212")
}

// Generated as internal constructor for term cls_offset.
pub fn constructor_cls_offset<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
) -> Reg {
    match arg0 {
        I8 => {
            let v4 = constructor_add_simm16(ctx, I8, arg1, -57_i16);
            // Rule at src\isa\s390x\lower.isle line 1244.
            return v4;
        }
        I16 => {
            let v7 = constructor_add_simm16(ctx, I16, arg1, -49_i16);
            // Rule at src\isa\s390x\lower.isle line 1245.
            return v7;
        }
        I32 => {
            let v10 = constructor_add_simm16(ctx, I32, arg1, -33_i16);
            // Rule at src\isa\s390x\lower.isle line 1246.
            return v10;
        }
        I64 => {
            let v13 = constructor_add_simm16(ctx, I64, arg1, -1_i16);
            // Rule at src\isa\s390x\lower.isle line 1247.
            return v13;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "cls_offset", "src\\isa\\s390x\\lower.isle line 1243")
}

// Generated as internal constructor for term ctz_guardbit.
pub fn constructor_ctz_guardbit<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> UImm16Shifted {
    match arg0 {
        I8 => {
            let v3 = C::uimm16shifted(ctx, 0x100_u16, 0x0_u8);
            // Rule at src\isa\s390x\lower.isle line 1298.
            return v3;
        }
        I16 => {
            let v6 = C::uimm16shifted(ctx, 0x1_u16, 0x10_u8);
            // Rule at src\isa\s390x\lower.isle line 1299.
            return v6;
        }
        I32 => {
            let v8 = C::uimm16shifted(ctx, 0x1_u16, 0x20_u8);
            // Rule at src\isa\s390x\lower.isle line 1300.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "ctz_guardbit", "src\\isa\\s390x\\lower.isle line 1297")
}

// Generated as internal constructor for term abi_vec_elt_rev.
pub fn constructor_abi_vec_elt_rev<C: Context>(
    ctx: &mut C,
    arg0: &LaneOrder,
    arg1: Type,
    arg2: Reg,
) -> Reg {
    let v2 = C::ty_vec128(ctx, arg1);
    if let Some(v3) = v2 {
        let v5 = &C::lane_order(ctx);
        let v6 = constructor_lane_order_equal(ctx, arg0, v5);
        if v6 == false {
            let v7 = constructor_vec_elt_rev(ctx, v3, arg2);
            // Rule at src\isa\s390x\lower.isle line 1816.
            return v7;
        }
    }
    // Rule at src\isa\s390x\lower.isle line 1819.
    return arg2;
}

// Generated as internal constructor for term vec_move_lane_and_insert.
pub fn constructor_vec_move_lane_and_insert<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: u8,
    arg3: Reg,
    arg4: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        if v2.0 == 0x40_u32 {
            match arg2 {
                0x0_u8 => {
                    let v10 = constructor_vec_permute_dw_imm(ctx, arg0, arg3, arg4, arg1, 0x1_u8);
                    // Rule at src\isa\s390x\lower.isle line 1864.
                    return v10;
                }
                0x1_u8 => {
                    let v12 = constructor_vec_permute_dw_imm(ctx, arg0, arg1, 0x0_u8, arg3, arg4);
                    // Rule at src\isa\s390x\lower.isle line 1866.
                    return v12;
                }
                _ => {}
            }
        }
    }
    if arg2 == arg4 {
        let v13 = C::lane_byte_mask(ctx, arg0, arg2);
        let v14 = constructor_vec_imm_byte_mask(ctx, arg0, v13);
        let v15 = constructor_vec_select(ctx, arg0, arg3, arg1, v14);
        // Rule at src\isa\s390x\lower.isle line 1870.
        return v15;
    }
    let v16 = constructor_vec_replicate_lane(ctx, arg0, arg3, arg4);
    let v17 = C::lane_byte_mask(ctx, arg0, arg2);
    let v18 = constructor_vec_imm_byte_mask(ctx, arg0, v17);
    let v19 = constructor_vec_select(ctx, arg0, v16, arg1, v18);
    // Rule at src\isa\s390x\lower.isle line 1875.
    return v19;
}

// Generated as internal constructor for term vec_load_lane_little.
pub fn constructor_vec_load_lane_little<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
    arg3: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x8_u32 => {
                let v8 = constructor_vec_load_lane(ctx, arg0, arg1, arg2, arg3);
                // Rule at src\isa\s390x\lower.isle line 1884.
                return v8;
            }
            0x10_u32 => {
                let v9 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v10) = v9 {
                    let v11 = constructor_vec_load_lane_rev(ctx, arg0, arg1, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 1888.
                    return v11;
                }
                let v12 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v13) = v12 {
                    let v14 = constructor_loadrev16(ctx, arg2);
                    let v15 = C::zero_reg(ctx);
                    let v16 = constructor_vec_insert_lane(ctx, arg0, arg1, v14, arg3, v15);
                    // Rule at src\isa\s390x\lower.isle line 1899.
                    return v16;
                }
            }
            0x20_u32 => {
                let v9 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v10) = v9 {
                    let v11 = constructor_vec_load_lane_rev(ctx, arg0, arg1, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 1891.
                    return v11;
                }
                let v12 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v13) = v12 {
                    let v17 = constructor_loadrev32(ctx, arg2);
                    let v15 = C::zero_reg(ctx);
                    let v18 = constructor_vec_insert_lane(ctx, arg0, arg1, v17, arg3, v15);
                    // Rule at src\isa\s390x\lower.isle line 1902.
                    return v18;
                }
            }
            0x40_u32 => {
                let v9 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v10) = v9 {
                    let v11 = constructor_vec_load_lane_rev(ctx, arg0, arg1, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 1894.
                    return v11;
                }
                let v12 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v13) = v12 {
                    let v19 = constructor_loadrev64(ctx, arg2);
                    let v15 = C::zero_reg(ctx);
                    let v20 = constructor_vec_insert_lane(ctx, arg0, arg1, v19, arg3, v15);
                    // Rule at src\isa\s390x\lower.isle line 1905.
                    return v20;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_lane_little", "src\\isa\\s390x\\lower.isle line 1881")
}

// Generated as internal constructor for term vec_load_lane_little_undef.
pub fn constructor_vec_load_lane_little_undef<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
    arg2: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x8_u32 => {
                let v7 = constructor_vec_load_lane_undef(ctx, arg0, arg1, arg2);
                // Rule at src\isa\s390x\lower.isle line 1913.
                return v7;
            }
            0x10_u32 => {
                let v8 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v9) = v8 {
                    let v10 = constructor_vec_load_lane_rev_undef(ctx, arg0, arg1, arg2);
                    // Rule at src\isa\s390x\lower.isle line 1917.
                    return v10;
                }
                let v11 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v12) = v11 {
                    let v13 = constructor_loadrev16(ctx, arg1);
                    let v14 = C::zero_reg(ctx);
                    let v15 = constructor_vec_insert_lane_undef(ctx, arg0, v13, arg2, v14);
                    // Rule at src\isa\s390x\lower.isle line 1928.
                    return v15;
                }
            }
            0x20_u32 => {
                let v8 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v9) = v8 {
                    let v10 = constructor_vec_load_lane_rev_undef(ctx, arg0, arg1, arg2);
                    // Rule at src\isa\s390x\lower.isle line 1920.
                    return v10;
                }
                let v11 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v12) = v11 {
                    let v16 = constructor_loadrev32(ctx, arg1);
                    let v14 = C::zero_reg(ctx);
                    let v17 = constructor_vec_insert_lane_undef(ctx, arg0, v16, arg2, v14);
                    // Rule at src\isa\s390x\lower.isle line 1931.
                    return v17;
                }
            }
            0x40_u32 => {
                let v8 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v9) = v8 {
                    let v10 = constructor_vec_load_lane_rev_undef(ctx, arg0, arg1, arg2);
                    // Rule at src\isa\s390x\lower.isle line 1923.
                    return v10;
                }
                let v11 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v12) = v11 {
                    let v18 = constructor_loadrev64(ctx, arg1);
                    let v14 = C::zero_reg(ctx);
                    let v19 = constructor_vec_insert_lane_undef(ctx, arg0, v18, arg2, v14);
                    // Rule at src\isa\s390x\lower.isle line 1934.
                    return v19;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_lane_little_undef", "src\\isa\\s390x\\lower.isle line 1910")
}

// Generated as internal constructor for term vec_store_lane_little.
pub fn constructor_vec_store_lane_little<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: &MemArg,
    arg3: u8,
) -> SideEffectNoResult {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x8_u32 => {
                let v8 = &constructor_vec_store_lane(ctx, arg0, arg1, arg2, arg3);
                // Rule at src\isa\s390x\lower.isle line 1971.
                return v8.clone();
            }
            0x10_u32 => {
                let v9 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v10) = v9 {
                    let v11 = &constructor_vec_store_lane_rev(ctx, arg0, arg1, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 1975.
                    return v11.clone();
                }
                let v12 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v13) = v12 {
                    let v14 = C::zero_reg(ctx);
                    let v15 = constructor_vec_extract_lane(ctx, arg0, arg1, arg3, v14);
                    let v16 = &constructor_storerev16(ctx, v15, arg2);
                    // Rule at src\isa\s390x\lower.isle line 1986.
                    return v16.clone();
                }
            }
            0x20_u32 => {
                let v9 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v10) = v9 {
                    let v11 = &constructor_vec_store_lane_rev(ctx, arg0, arg1, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 1978.
                    return v11.clone();
                }
                let v12 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v13) = v12 {
                    let v14 = C::zero_reg(ctx);
                    let v15 = constructor_vec_extract_lane(ctx, arg0, arg1, arg3, v14);
                    let v17 = &constructor_storerev32(ctx, v15, arg2);
                    // Rule at src\isa\s390x\lower.isle line 1989.
                    return v17.clone();
                }
            }
            0x40_u32 => {
                let v9 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v10) = v9 {
                    let v11 = &constructor_vec_store_lane_rev(ctx, arg0, arg1, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 1981.
                    return v11.clone();
                }
                let v12 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v13) = v12 {
                    let v14 = C::zero_reg(ctx);
                    let v15 = constructor_vec_extract_lane(ctx, arg0, arg1, arg3, v14);
                    let v18 = &constructor_storerev64(ctx, v15, arg2);
                    // Rule at src\isa\s390x\lower.isle line 1992.
                    return v18.clone();
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_store_lane_little", "src\\isa\\s390x\\lower.isle line 1968")
}

// Generated as internal constructor for term vec_load_replicate_little.
pub fn constructor_vec_load_replicate_little<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &MemArg,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        match v2.0 {
            0x8_u32 => {
                let v6 = constructor_vec_load_replicate(ctx, arg0, arg1);
                // Rule at src\isa\s390x\lower.isle line 2030.
                return v6;
            }
            0x10_u32 => {
                let v7 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v8) = v7 {
                    let v9 = constructor_vec_load_replicate_rev(ctx, arg0, arg1);
                    // Rule at src\isa\s390x\lower.isle line 2034.
                    return v9;
                }
                let v10 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v11) = v10 {
                    let v13 = constructor_vec_load_lane_little_undef(ctx, arg0, arg1, 0x0_u8);
                    let v14 = constructor_vec_replicate_lane(ctx, arg0, v13, 0x0_u8);
                    // Rule at src\isa\s390x\lower.isle line 2045.
                    return v14;
                }
            }
            0x20_u32 => {
                let v7 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v8) = v7 {
                    let v9 = constructor_vec_load_replicate_rev(ctx, arg0, arg1);
                    // Rule at src\isa\s390x\lower.isle line 2037.
                    return v9;
                }
                let v10 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v11) = v10 {
                    let v13 = constructor_vec_load_lane_little_undef(ctx, arg0, arg1, 0x0_u8);
                    let v14 = constructor_vec_replicate_lane(ctx, arg0, v13, 0x0_u8);
                    // Rule at src\isa\s390x\lower.isle line 2048.
                    return v14;
                }
            }
            0x40_u32 => {
                let v7 = C::vxrs_ext2_enabled(ctx, arg0);
                if let Some(v8) = v7 {
                    let v9 = constructor_vec_load_replicate_rev(ctx, arg0, arg1);
                    // Rule at src\isa\s390x\lower.isle line 2040.
                    return v9;
                }
                let v10 = C::vxrs_ext2_disabled(ctx, arg0);
                if let Some(v11) = v10 {
                    let v13 = constructor_vec_load_lane_little_undef(ctx, arg0, arg1, 0x0_u8);
                    let v14 = constructor_vec_replicate_lane(ctx, arg0, v13, 0x0_u8);
                    // Rule at src\isa\s390x\lower.isle line 2051.
                    return v14;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_replicate_little", "src\\isa\\s390x\\lower.isle line 2027")
}

// Generated as internal constructor for term vec_move_lane_and_zero.
pub fn constructor_vec_move_lane_and_zero<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u8,
    arg2: Reg,
    arg3: u8,
) -> Reg {
    let v1 = C::multi_lane(ctx, arg0);
    if let Some(v2) = v1 {
        if v2.0 == 0x40_u32 {
            match arg1 {
                0x0_u8 => {
                    let v9 = constructor_vec_imm(ctx, arg0, 0x0_u128);
                    let v11 = constructor_vec_permute_dw_imm(ctx, arg0, arg2, arg3, v9, 0x0_u8);
                    // Rule at src\isa\s390x\lower.isle line 2091.
                    return v11;
                }
                0x1_u8 => {
                    let v9 = constructor_vec_imm(ctx, arg0, 0x0_u128);
                    let v12 = constructor_vec_permute_dw_imm(ctx, arg0, v9, 0x0_u8, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 2093.
                    return v12;
                }
                _ => {}
            }
        }
    }
    if arg1 == arg3 {
        let v13 = C::lane_byte_mask(ctx, arg0, arg1);
        let v14 = constructor_vec_imm_byte_mask(ctx, arg0, v13);
        let v15 = constructor_vec_and(ctx, arg0, arg2, v14);
        // Rule at src\isa\s390x\lower.isle line 2097.
        return v15;
    }
    let v16 = constructor_vec_replicate_lane(ctx, arg0, arg2, arg3);
    let v17 = C::lane_byte_mask(ctx, arg0, arg1);
    let v18 = constructor_vec_imm_byte_mask(ctx, arg0, v17);
    let v19 = constructor_vec_and(ctx, arg0, v16, v18);
    // Rule at src\isa\s390x\lower.isle line 2102.
    return v19;
}

// Generated as internal constructor for term lib_call_tls_get_offset.
pub fn constructor_lib_call_tls_get_offset<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
    arg2: &SymbolReloc,
) -> Reg {
    let v4 = C::temp_writable_reg(ctx, I64);
    let v5 = C::abi_for_elf_tls_get_offset(ctx);
    let v6 = C::box_symbol_reloc(ctx, arg2);
    let v7 = MInst::ElfTlsGetOffset {
        tls_offset: v4,
        got: arg0,
        got_offset: arg1,
        symbol: v6,
    };
    let v8 = C::emit(ctx, &v7);
    let v9 = C::writable_reg_to_reg(ctx, v4);
    // Rule at src\isa\s390x\lower.isle line 2338.
    return v9;
}

// Generated as internal constructor for term thread_pointer.
pub fn constructor_thread_pointer<C: Context>(
    ctx: &mut C,
) -> Reg {
    let v2 = constructor_load_ar(ctx, 0x0_u8);
    let v4 = constructor_lshl_imm(ctx, I64, v2, 0x20_u8);
    let v6 = constructor_insert_ar(ctx, v4, 0x1_u8);
    // Rule at src\isa\s390x\lower.isle line 2349.
    return v6;
}

// Generated as internal constructor for term vec_load_full_rev.
pub fn constructor_vec_load_full_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Reg {
    let v3 = C::vr128_ty(ctx, arg0);
    if let Some(v4) = v3 {
        let v1 = C::vxrs_ext2_enabled(ctx, arg0);
        if let Some(v2) = v1 {
            let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
            let v9 = constructor_vec_loadrev(ctx, v4, v8);
            // Rule at src\isa\s390x\lower.isle line 2432.
            return v9;
        }
        let v10 = C::vxrs_ext2_disabled(ctx, arg0);
        if let Some(v11) = v10 {
            let v13 = &constructor_lower_address_bias(ctx, arg1, arg2, arg3, 0x0_u8);
            let v15 = &constructor_lower_address_bias(ctx, arg1, arg2, arg3, 0x8_u8);
            let v16 = constructor_loadrev64(ctx, v13);
            let v17 = constructor_loadrev64(ctx, v15);
            let v18 = constructor_mov_to_vec128(ctx, v4, v17, v16);
            // Rule at src\isa\s390x\lower.isle line 2436.
            return v18;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_full_rev", "src\\isa\\s390x\\lower.isle line 2429")
}

// Generated as internal constructor for term vec_load_byte_rev.
pub fn constructor_vec_load_byte_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Reg {
    let v8 = C::multi_lane(ctx, arg0);
    if let Some(v9) = v8 {
        match v9.0 {
            0x8_u32 => {
                if v9.1 == 0x10_u32 {
                    let v12 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                    let v13 = constructor_vec_load(ctx, arg0, v12);
                    // Rule at src\isa\s390x\lower.isle line 2456.
                    return v13;
                }
            }
            0x10_u32 => {
                if v9.1 == 0x8_u32 {
                    let v14 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v15) = v14 {
                        let v12 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v18 = constructor_vec_load_byte16rev(ctx, arg0, v12);
                        // Rule at src\isa\s390x\lower.isle line 2466.
                        return v18;
                    }
                    let v19 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v20) = v19 {
                        let v21 = constructor_vec_load_full_rev(ctx, arg0, arg1, arg2, arg3);
                        let v22 = constructor_vec_elt_rev(ctx, arg0, v21);
                        // Rule at src\isa\s390x\lower.isle line 2477.
                        return v22;
                    }
                }
            }
            0x20_u32 => {
                if v9.1 == 0x4_u32 {
                    let v14 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v15) = v14 {
                        let v12 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v17 = constructor_vec_load_byte32rev(ctx, arg0, v12);
                        // Rule at src\isa\s390x\lower.isle line 2463.
                        return v17;
                    }
                    let v19 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v20) = v19 {
                        let v21 = constructor_vec_load_full_rev(ctx, arg0, arg1, arg2, arg3);
                        let v22 = constructor_vec_elt_rev(ctx, arg0, v21);
                        // Rule at src\isa\s390x\lower.isle line 2474.
                        return v22;
                    }
                }
            }
            0x40_u32 => {
                if v9.1 == 0x2_u32 {
                    let v14 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v15) = v14 {
                        let v12 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v16 = constructor_vec_load_byte64rev(ctx, arg0, v12);
                        // Rule at src\isa\s390x\lower.isle line 2460.
                        return v16;
                    }
                    let v19 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v20) = v19 {
                        let v21 = constructor_vec_load_full_rev(ctx, arg0, arg1, arg2, arg3);
                        let v22 = constructor_vec_elt_rev(ctx, arg0, v21);
                        // Rule at src\isa\s390x\lower.isle line 2471.
                        return v22;
                    }
                }
            }
            _ => {}
        }
    }
    match arg0 {
        I128 => {
            let v5 = constructor_vec_load_full_rev(ctx, I128, arg1, arg2, arg3);
            // Rule at src\isa\s390x\lower.isle line 2448.
            return v5;
        }
        F128 => {
            let v7 = constructor_vec_load_full_rev(ctx, F128, arg1, arg2, arg3);
            // Rule at src\isa\s390x\lower.isle line 2452.
            return v7;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_byte_rev", "src\\isa\\s390x\\lower.isle line 2445")
}

// Generated as internal constructor for term vec_load_elt_rev.
pub fn constructor_vec_load_elt_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Reg {
    let v9 = C::multi_lane(ctx, arg0);
    if let Some(v10) = v9 {
        match v10.0 {
            0x8_u32 => {
                if v10.1 == 0x10_u32 {
                    let v13 = constructor_vec_load_full_rev(ctx, arg0, arg1, arg2, arg3);
                    // Rule at src\isa\s390x\lower.isle line 2495.
                    return v13;
                }
            }
            0x10_u32 => {
                if v10.1 == 0x8_u32 {
                    let v14 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v15) = v14 {
                        let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v18 = constructor_vec_load_elt16rev(ctx, arg0, v5);
                        // Rule at src\isa\s390x\lower.isle line 2505.
                        return v18;
                    }
                    let v19 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v20) = v19 {
                        let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v21 = constructor_vec_load(ctx, arg0, v5);
                        let v22 = constructor_vec_elt_rev(ctx, arg0, v21);
                        // Rule at src\isa\s390x\lower.isle line 2516.
                        return v22;
                    }
                }
            }
            0x20_u32 => {
                if v10.1 == 0x4_u32 {
                    let v14 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v15) = v14 {
                        let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v17 = constructor_vec_load_elt32rev(ctx, arg0, v5);
                        // Rule at src\isa\s390x\lower.isle line 2502.
                        return v17;
                    }
                    let v19 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v20) = v19 {
                        let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v21 = constructor_vec_load(ctx, arg0, v5);
                        let v22 = constructor_vec_elt_rev(ctx, arg0, v21);
                        // Rule at src\isa\s390x\lower.isle line 2513.
                        return v22;
                    }
                }
            }
            0x40_u32 => {
                if v10.1 == 0x2_u32 {
                    let v14 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v15) = v14 {
                        let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v16 = constructor_vec_load_elt64rev(ctx, arg0, v5);
                        // Rule at src\isa\s390x\lower.isle line 2499.
                        return v16;
                    }
                    let v19 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v20) = v19 {
                        let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                        let v21 = constructor_vec_load(ctx, arg0, v5);
                        let v22 = constructor_vec_elt_rev(ctx, arg0, v21);
                        // Rule at src\isa\s390x\lower.isle line 2510.
                        return v22;
                    }
                }
            }
            _ => {}
        }
    }
    match arg0 {
        I128 => {
            let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
            let v6 = constructor_vec_load(ctx, I128, v5);
            // Rule at src\isa\s390x\lower.isle line 2487.
            return v6;
        }
        F128 => {
            let v5 = &constructor_lower_address(ctx, arg1, arg2, arg3);
            let v8 = constructor_vec_load(ctx, F128, v5);
            // Rule at src\isa\s390x\lower.isle line 2491.
            return v8;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_load_elt_rev", "src\\isa\\s390x\\lower.isle line 2483")
}

// Generated as internal constructor for term load_v64.
pub fn constructor_load_v64<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Reg {
    let v6 = &C::lane_order(ctx);
    match v6 {
        &LaneOrder::LittleEndian => {
            let v14 = C::multi_lane(ctx, arg0);
            if let Some(v15) = v14 {
                match v15.0 {
                    0x8_u32 => {
                        if v15.1 == 0x10_u32 {
                            let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                            let v13 = constructor_vec_load_lane_little_undef(ctx, I64X2, v8, 0x0_u8);
                            // Rule at src\isa\s390x\lower.isle line 2667.
                            return v13;
                        }
                    }
                    0x10_u32 => {
                        let v2 = C::bigendian(ctx, arg1);
                        if let Some(v3) = v2 {
                            if v15.1 == 0x8_u32 {
                                let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                                let v13 = constructor_vec_load_lane_little_undef(ctx, I64X2, v8, 0x0_u8);
                                let v21 = constructor_vec_rot_imm(ctx, I16X8, v13, 0x8_u8);
                                // Rule at src\isa\s390x\lower.isle line 2678.
                                return v21;
                            }
                        }
                    }
                    0x20_u32 => {
                        let v2 = C::bigendian(ctx, arg1);
                        if let Some(v3) = v2 {
                            if v15.1 == 0x4_u32 {
                                let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                                let v10 = constructor_vec_load_lane_undef(ctx, I64X2, v8, 0x0_u8);
                                let v24 = constructor_vec_rot_imm(ctx, I64X2, v10, 0x20_u8);
                                // Rule at src\isa\s390x\lower.isle line 2690.
                                return v24;
                            }
                        }
                    }
                    _ => {}
                }
            }
            let v11 = C::littleendian(ctx, arg1);
            if let Some(v12) = v11 {
                let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                let v13 = constructor_vec_load_lane_little_undef(ctx, I64X2, v8, 0x0_u8);
                // Rule at src\isa\s390x\lower.isle line 2657.
                return v13;
            }
        }
        &LaneOrder::BigEndian => {
            let v14 = C::multi_lane(ctx, arg0);
            if let Some(v15) = v14 {
                match v15.0 {
                    0x8_u32 => {
                        if v15.1 == 0x10_u32 {
                            let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                            let v10 = constructor_vec_load_lane_undef(ctx, I64X2, v8, 0x0_u8);
                            // Rule at src\isa\s390x\lower.isle line 2662.
                            return v10;
                        }
                    }
                    0x10_u32 => {
                        let v11 = C::littleendian(ctx, arg1);
                        if let Some(v12) = v11 {
                            if v15.1 == 0x8_u32 {
                                let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                                let v10 = constructor_vec_load_lane_undef(ctx, I64X2, v8, 0x0_u8);
                                let v20 = constructor_vec_rot_imm(ctx, I16X8, v10, 0x8_u8);
                                // Rule at src\isa\s390x\lower.isle line 2672.
                                return v20;
                            }
                        }
                    }
                    0x20_u32 => {
                        let v11 = C::littleendian(ctx, arg1);
                        if let Some(v12) = v11 {
                            if v15.1 == 0x4_u32 {
                                let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                                let v13 = constructor_vec_load_lane_little_undef(ctx, I64X2, v8, 0x0_u8);
                                let v23 = constructor_vec_rot_imm(ctx, I64X2, v13, 0x20_u8);
                                // Rule at src\isa\s390x\lower.isle line 2684.
                                return v23;
                            }
                        }
                    }
                    _ => {}
                }
            }
            let v2 = C::bigendian(ctx, arg1);
            if let Some(v3) = v2 {
                let v8 = &constructor_lower_address(ctx, arg1, arg2, arg3);
                let v10 = constructor_vec_load_lane_undef(ctx, I64X2, v8, 0x0_u8);
                // Rule at src\isa\s390x\lower.isle line 2652.
                return v10;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "load_v64", "src\\isa\\s390x\\lower.isle line 2649")
}

// Generated as internal constructor for term vec_store_full_rev.
pub fn constructor_vec_store_full_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: MemFlags,
    arg3: Value,
    arg4: Offset32,
) -> SideEffectNoResult {
    let v1 = C::vxrs_ext2_enabled(ctx, arg0);
    if let Some(v2) = v1 {
        let v7 = &constructor_lower_address(ctx, arg2, arg3, arg4);
        let v8 = &constructor_vec_storerev(ctx, arg1, v7);
        // Rule at src\isa\s390x\lower.isle line 2782.
        return v8.clone();
    }
    let v9 = C::vxrs_ext2_disabled(ctx, arg0);
    if let Some(v10) = v9 {
        let v12 = &constructor_lower_address_bias(ctx, arg2, arg3, arg4, 0x0_u8);
        let v14 = &constructor_lower_address_bias(ctx, arg2, arg3, arg4, 0x8_u8);
        let v17 = C::zero_reg(ctx);
        let v18 = constructor_vec_extract_lane(ctx, I64X2, arg1, 0x1_u8, v17);
        let v19 = C::zero_reg(ctx);
        let v20 = constructor_vec_extract_lane(ctx, I64X2, arg1, 0x0_u8, v19);
        let v21 = &constructor_storerev64(ctx, v18, v12);
        let v22 = &constructor_storerev64(ctx, v20, v14);
        let v23 = &constructor_side_effect_concat(ctx, v21, v22);
        // Rule at src\isa\s390x\lower.isle line 2786.
        return v23.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_store_full_rev", "src\\isa\\s390x\\lower.isle line 2779")
}

// Generated as internal constructor for term vec_store_byte_rev.
pub fn constructor_vec_store_byte_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: MemFlags,
    arg3: Value,
    arg4: Offset32,
) -> SideEffectNoResult {
    let v9 = C::multi_lane(ctx, arg0);
    if let Some(v10) = v9 {
        match v10.0 {
            0x8_u32 => {
                if v10.1 == 0x10_u32 {
                    let v13 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                    let v14 = &constructor_vec_store(ctx, arg1, v13);
                    // Rule at src\isa\s390x\lower.isle line 2807.
                    return v14.clone();
                }
            }
            0x10_u32 => {
                if v10.1 == 0x8_u32 {
                    let v15 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v16) = v15 {
                        let v13 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v19 = &constructor_vec_store_byte16rev(ctx, arg1, v13);
                        // Rule at src\isa\s390x\lower.isle line 2817.
                        return v19.clone();
                    }
                    let v20 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v21) = v20 {
                        let v22 = constructor_vec_elt_rev(ctx, arg0, arg1);
                        let v23 = &constructor_vec_store_full_rev(ctx, arg0, v22, arg2, arg3, arg4);
                        // Rule at src\isa\s390x\lower.isle line 2828.
                        return v23.clone();
                    }
                }
            }
            0x20_u32 => {
                if v10.1 == 0x4_u32 {
                    let v15 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v16) = v15 {
                        let v13 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v18 = &constructor_vec_store_byte32rev(ctx, arg1, v13);
                        // Rule at src\isa\s390x\lower.isle line 2814.
                        return v18.clone();
                    }
                    let v20 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v21) = v20 {
                        let v22 = constructor_vec_elt_rev(ctx, arg0, arg1);
                        let v23 = &constructor_vec_store_full_rev(ctx, arg0, v22, arg2, arg3, arg4);
                        // Rule at src\isa\s390x\lower.isle line 2825.
                        return v23.clone();
                    }
                }
            }
            0x40_u32 => {
                if v10.1 == 0x2_u32 {
                    let v15 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v16) = v15 {
                        let v13 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v17 = &constructor_vec_store_byte64rev(ctx, arg1, v13);
                        // Rule at src\isa\s390x\lower.isle line 2811.
                        return v17.clone();
                    }
                    let v20 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v21) = v20 {
                        let v22 = constructor_vec_elt_rev(ctx, arg0, arg1);
                        let v23 = &constructor_vec_store_full_rev(ctx, arg0, v22, arg2, arg3, arg4);
                        // Rule at src\isa\s390x\lower.isle line 2822.
                        return v23.clone();
                    }
                }
            }
            _ => {}
        }
    }
    match arg0 {
        I128 => {
            let v6 = &constructor_vec_store_full_rev(ctx, I128, arg1, arg2, arg3, arg4);
            // Rule at src\isa\s390x\lower.isle line 2799.
            return v6.clone();
        }
        F128 => {
            let v8 = &constructor_vec_store_full_rev(ctx, F128, arg1, arg2, arg3, arg4);
            // Rule at src\isa\s390x\lower.isle line 2803.
            return v8.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_store_byte_rev", "src\\isa\\s390x\\lower.isle line 2796")
}

// Generated as internal constructor for term vec_store_elt_rev.
pub fn constructor_vec_store_elt_rev<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: MemFlags,
    arg3: Value,
    arg4: Offset32,
) -> SideEffectNoResult {
    let v7 = C::multi_lane(ctx, arg0);
    if let Some(v8) = v7 {
        match v8.0 {
            0x8_u32 => {
                if v8.1 == 0x10_u32 {
                    let v11 = &constructor_vec_store_full_rev(ctx, arg0, arg1, arg2, arg3, arg4);
                    // Rule at src\isa\s390x\lower.isle line 2845.
                    return v11.clone();
                }
            }
            0x10_u32 => {
                if v8.1 == 0x8_u32 {
                    let v12 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v13) = v12 {
                        let v5 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v16 = &constructor_vec_store_elt16rev(ctx, arg1, v5);
                        // Rule at src\isa\s390x\lower.isle line 2855.
                        return v16.clone();
                    }
                    let v17 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v18) = v17 {
                        let v19 = constructor_vec_elt_rev(ctx, arg0, arg1);
                        let v20 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v21 = &constructor_vec_store(ctx, v19, v20);
                        // Rule at src\isa\s390x\lower.isle line 2866.
                        return v21.clone();
                    }
                }
            }
            0x20_u32 => {
                if v8.1 == 0x4_u32 {
                    let v12 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v13) = v12 {
                        let v5 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v15 = &constructor_vec_store_elt32rev(ctx, arg1, v5);
                        // Rule at src\isa\s390x\lower.isle line 2852.
                        return v15.clone();
                    }
                    let v17 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v18) = v17 {
                        let v19 = constructor_vec_elt_rev(ctx, arg0, arg1);
                        let v20 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v21 = &constructor_vec_store(ctx, v19, v20);
                        // Rule at src\isa\s390x\lower.isle line 2863.
                        return v21.clone();
                    }
                }
            }
            0x40_u32 => {
                if v8.1 == 0x2_u32 {
                    let v12 = C::vxrs_ext2_enabled(ctx, arg0);
                    if let Some(v13) = v12 {
                        let v5 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v14 = &constructor_vec_store_elt64rev(ctx, arg1, v5);
                        // Rule at src\isa\s390x\lower.isle line 2849.
                        return v14.clone();
                    }
                    let v17 = C::vxrs_ext2_disabled(ctx, arg0);
                    if let Some(v18) = v17 {
                        let v19 = constructor_vec_elt_rev(ctx, arg0, arg1);
                        let v20 = &constructor_lower_address(ctx, arg2, arg3, arg4);
                        let v21 = &constructor_vec_store(ctx, v19, v20);
                        // Rule at src\isa\s390x\lower.isle line 2860.
                        return v21.clone();
                    }
                }
            }
            _ => {}
        }
    }
    match arg0 {
        I128 => {
            let v5 = &constructor_lower_address(ctx, arg2, arg3, arg4);
            let v6 = &constructor_vec_store(ctx, arg1, v5);
            // Rule at src\isa\s390x\lower.isle line 2837.
            return v6.clone();
        }
        F128 => {
            let v5 = &constructor_lower_address(ctx, arg2, arg3, arg4);
            let v6 = &constructor_vec_store(ctx, arg1, v5);
            // Rule at src\isa\s390x\lower.isle line 2841.
            return v6.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "vec_store_elt_rev", "src\\isa\\s390x\\lower.isle line 2834")
}

// Generated as internal constructor for term istore8_impl.
pub fn constructor_istore8_impl<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> SideEffectNoResult {
    let v7 = C::u8_from_value(ctx, arg1);
    if let Some(v8) = v7 {
        let v9 = &constructor_lower_address(ctx, arg0, arg2, arg3);
        let v10 = &constructor_store8_imm(ctx, v8, v9);
        // Rule at src\isa\s390x\lower.isle line 2885.
        return v10.clone();
    }
    let v4 = C::put_in_reg(ctx, arg1);
    let v5 = &constructor_lower_address(ctx, arg0, arg2, arg3);
    let v6 = &constructor_store8(ctx, v4, v5);
    // Rule at src\isa\s390x\lower.isle line 2881.
    return v6.clone();
}

// Generated as internal constructor for term istore16_impl.
pub fn constructor_istore16_impl<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> SideEffectNoResult {
    let v1 = C::bigendian(ctx, arg0);
    if let Some(v2) = v1 {
        let v12 = C::i16_from_value(ctx, arg1);
        if let Some(v13) = v12 {
            let v14 = &constructor_lower_address(ctx, arg0, arg2, arg3);
            let v15 = &constructor_store16_imm(ctx, v13, v14);
            // Rule at src\isa\s390x\lower.isle line 2907.
            return v15.clone();
        }
        let v6 = C::put_in_reg(ctx, arg1);
        let v7 = &constructor_lower_address(ctx, arg0, arg2, arg3);
        let v8 = &constructor_store16(ctx, v6, v7);
        // Rule at src\isa\s390x\lower.isle line 2899.
        return v8.clone();
    }
    let v9 = C::littleendian(ctx, arg0);
    if let Some(v10) = v9 {
        let v16 = C::i16_from_swapped_value(ctx, arg1);
        if let Some(v17) = v16 {
            let v14 = &constructor_lower_address(ctx, arg0, arg2, arg3);
            let v18 = &constructor_store16_imm(ctx, v17, v14);
            // Rule at src\isa\s390x\lower.isle line 2911.
            return v18.clone();
        }
        let v6 = C::put_in_reg(ctx, arg1);
        let v7 = &constructor_lower_address(ctx, arg0, arg2, arg3);
        let v11 = &constructor_storerev16(ctx, v6, v7);
        // Rule at src\isa\s390x\lower.isle line 2903.
        return v11.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "istore16_impl", "src\\isa\\s390x\\lower.isle line 2896")
}

// Generated as internal constructor for term istore32_impl.
pub fn constructor_istore32_impl<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> SideEffectNoResult {
    let v1 = C::bigendian(ctx, arg0);
    if let Some(v2) = v1 {
        let v9 = C::i16_from_value(ctx, arg1);
        if let Some(v10) = v9 {
            let v11 = &constructor_lower_address(ctx, arg0, arg2, arg3);
            let v12 = &constructor_store32_simm16(ctx, v10, v11);
            // Rule at src\isa\s390x\lower.isle line 2929.
            return v12.clone();
        }
        let v6 = C::put_in_reg(ctx, arg1);
        let v7 = &constructor_lower_address(ctx, arg0, arg2, arg3);
        let v8 = &constructor_store32(ctx, v6, v7);
        // Rule at src\isa\s390x\lower.isle line 2925.
        return v8.clone();
    }
    let v13 = C::littleendian(ctx, arg0);
    if let Some(v14) = v13 {
        let v6 = C::put_in_reg(ctx, arg1);
        let v7 = &constructor_lower_address(ctx, arg0, arg2, arg3);
        let v15 = &constructor_storerev32(ctx, v6, v7);
        // Rule at src\isa\s390x\lower.isle line 2933.
        return v15.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "istore32_impl", "src\\isa\\s390x\\lower.isle line 2922")
}

// Generated as internal constructor for term istore64_impl.
pub fn constructor_istore64_impl<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: Value,
    arg2: Value,
    arg3: Offset32,
) -> SideEffectNoResult {
    let v1 = C::bigendian(ctx, arg0);
    if let Some(v2) = v1 {
        let v9 = C::i16_from_value(ctx, arg1);
        if let Some(v10) = v9 {
            let v11 = &constructor_lower_address(ctx, arg0, arg2, arg3);
            let v12 = &constructor_store64_simm16(ctx, v10, v11);
            // Rule at src\isa\s390x\lower.isle line 2947.
            return v12.clone();
        }
        let v6 = C::put_in_reg(ctx, arg1);
        let v7 = &constructor_lower_address(ctx, arg0, arg2, arg3);
        let v8 = &constructor_store64(ctx, v6, v7);
        // Rule at src\isa\s390x\lower.isle line 2943.
        return v8.clone();
    }
    let v13 = C::littleendian(ctx, arg0);
    if let Some(v14) = v13 {
        let v6 = C::put_in_reg(ctx, arg1);
        let v7 = &constructor_lower_address(ctx, arg0, arg2, arg3);
        let v15 = &constructor_storerev64(ctx, v6, v7);
        // Rule at src\isa\s390x\lower.isle line 2951.
        return v15.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "istore64_impl", "src\\isa\\s390x\\lower.isle line 2940")
}

// Generated as internal constructor for term atomic_rmw_body.
pub fn constructor_atomic_rmw_body<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: &AtomicRmwOp,
    arg4: WritableReg,
    arg5: Reg,
    arg6: Reg,
) -> Reg {
    match arg3 {
        &AtomicRmwOp::Add => {
            let v38 = constructor_ty_ext32(ctx, arg1);
            let v39 = &constructor_aluop_add(ctx, v38);
            let v40 = constructor_atomic_rmw_body_addsub(ctx, arg0, arg1, arg2, v39, arg4, arg5, arg6);
            // Rule at src\isa\s390x\lower.isle line 3114.
            return v40;
        }
        &AtomicRmwOp::And => {
            let v27 = C::ty_8_or_16(ctx, arg1);
            if let Some(v28) = v27 {
                let v32 = constructor_atomic_rmw_body_rxsbg(ctx, arg0, v28, arg2, &RxSBGOp::And, arg4, arg5, arg6);
                // Rule at src\isa\s390x\lower.isle line 3076.
                return v32;
            }
        }
        &AtomicRmwOp::Nand => {
            let v2 = C::ty_32_or_64(ctx, arg1);
            if let Some(v3) = v2 {
                let v14 = C::mie3_enabled(ctx, arg1);
                if let Some(v15) = v14 {
                    let v5 = C::bigendian(ctx, arg2);
                    if let Some(v6) = v5 {
                        let v16 = &constructor_aluop_not_and(ctx, v3);
                        let v17 = constructor_push_alu_reg(ctx, arg0, v16, arg4, arg5, arg6);
                        // Rule at src\isa\s390x\lower.isle line 3056.
                        return v17;
                    }
                    let v11 = C::littleendian(ctx, arg2);
                    if let Some(v12) = v11 {
                        let v16 = &constructor_aluop_not_and(ctx, v3);
                        let v18 = constructor_bswap_reg(ctx, v3, arg6);
                        let v19 = constructor_push_alu_reg(ctx, arg0, v16, arg4, arg5, v18);
                        // Rule at src\isa\s390x\lower.isle line 3059.
                        return v19;
                    }
                }
                let v20 = C::mie3_disabled(ctx, arg1);
                if let Some(v21) = v20 {
                    let v5 = C::bigendian(ctx, arg2);
                    if let Some(v6) = v5 {
                        let v22 = &constructor_aluop_and(ctx, v3);
                        let v23 = constructor_push_alu_reg(ctx, arg0, v22, arg4, arg5, arg6);
                        let v24 = constructor_push_not_reg(ctx, arg0, v3, arg4, v23);
                        // Rule at src\isa\s390x\lower.isle line 3062.
                        return v24;
                    }
                    let v11 = C::littleendian(ctx, arg2);
                    if let Some(v12) = v11 {
                        let v22 = &constructor_aluop_and(ctx, v3);
                        let v18 = constructor_bswap_reg(ctx, v3, arg6);
                        let v25 = constructor_push_alu_reg(ctx, arg0, v22, arg4, arg5, v18);
                        let v26 = constructor_push_not_reg(ctx, arg0, v3, arg4, v25);
                        // Rule at src\isa\s390x\lower.isle line 3066.
                        return v26;
                    }
                }
            }
            let v27 = C::ty_8_or_16(ctx, arg1);
            if let Some(v28) = v27 {
                let v32 = constructor_atomic_rmw_body_rxsbg(ctx, arg0, v28, arg2, &RxSBGOp::And, arg4, arg5, arg6);
                let v37 = constructor_atomic_rmw_body_invert(ctx, arg0, v28, arg2, arg4, v32);
                // Rule at src\isa\s390x\lower.isle line 3082.
                return v37;
            }
        }
        &AtomicRmwOp::Or => {
            let v27 = C::ty_8_or_16(ctx, arg1);
            if let Some(v28) = v27 {
                let v34 = constructor_atomic_rmw_body_rxsbg(ctx, arg0, v28, arg2, &RxSBGOp::Or, arg4, arg5, arg6);
                // Rule at src\isa\s390x\lower.isle line 3078.
                return v34;
            }
        }
        &AtomicRmwOp::Smax => {
            let v38 = constructor_ty_ext32(ctx, arg1);
            let v43 = &constructor_cmpop_cmps(ctx, v38);
            let v48 = &C::intcc_as_cond(ctx, &IntCC::SignedGreaterThan);
            let v49 = constructor_atomic_rmw_body_minmax(ctx, arg0, arg1, arg2, v43, v48, arg4, arg5, arg6);
            // Rule at src\isa\s390x\lower.isle line 3155.
            return v49;
        }
        &AtomicRmwOp::Smin => {
            let v38 = constructor_ty_ext32(ctx, arg1);
            let v43 = &constructor_cmpop_cmps(ctx, v38);
            let v45 = &C::intcc_as_cond(ctx, &IntCC::SignedLessThan);
            let v46 = constructor_atomic_rmw_body_minmax(ctx, arg0, arg1, arg2, v43, v45, arg4, arg5, arg6);
            // Rule at src\isa\s390x\lower.isle line 3152.
            return v46;
        }
        &AtomicRmwOp::Sub => {
            let v38 = constructor_ty_ext32(ctx, arg1);
            let v41 = &constructor_aluop_sub(ctx, v38);
            let v42 = constructor_atomic_rmw_body_addsub(ctx, arg0, arg1, arg2, v41, arg4, arg5, arg6);
            // Rule at src\isa\s390x\lower.isle line 3116.
            return v42;
        }
        &AtomicRmwOp::Umax => {
            let v38 = constructor_ty_ext32(ctx, arg1);
            let v50 = &constructor_cmpop_cmpu(ctx, v38);
            let v55 = &C::intcc_as_cond(ctx, &IntCC::UnsignedGreaterThan);
            let v56 = constructor_atomic_rmw_body_minmax(ctx, arg0, arg1, arg2, v50, v55, arg4, arg5, arg6);
            // Rule at src\isa\s390x\lower.isle line 3161.
            return v56;
        }
        &AtomicRmwOp::Umin => {
            let v38 = constructor_ty_ext32(ctx, arg1);
            let v50 = &constructor_cmpop_cmpu(ctx, v38);
            let v52 = &C::intcc_as_cond(ctx, &IntCC::UnsignedLessThan);
            let v53 = constructor_atomic_rmw_body_minmax(ctx, arg0, arg1, arg2, v50, v52, arg4, arg5, arg6);
            // Rule at src\isa\s390x\lower.isle line 3158.
            return v53;
        }
        &AtomicRmwOp::Xchg => {
            let v2 = C::ty_32_or_64(ctx, arg1);
            if let Some(v3) = v2 {
                let v5 = C::bigendian(ctx, arg2);
                if let Some(v6) = v5 {
                    // Rule at src\isa\s390x\lower.isle line 3045.
                    return arg6;
                }
                let v11 = C::littleendian(ctx, arg2);
                if let Some(v12) = v11 {
                    let v13 = constructor_bswap_reg(ctx, v3, arg6);
                    // Rule at src\isa\s390x\lower.isle line 3048.
                    return v13;
                }
            }
            let v27 = C::ty_8_or_16(ctx, arg1);
            if let Some(v28) = v27 {
                let v30 = constructor_atomic_rmw_body_rxsbg(ctx, arg0, v28, arg2, &RxSBGOp::Insert, arg4, arg5, arg6);
                // Rule at src\isa\s390x\lower.isle line 3074.
                return v30;
            }
        }
        &AtomicRmwOp::Xor => {
            let v27 = C::ty_8_or_16(ctx, arg1);
            if let Some(v28) = v27 {
                let v36 = constructor_atomic_rmw_body_rxsbg(ctx, arg0, v28, arg2, &RxSBGOp::Xor, arg4, arg5, arg6);
                // Rule at src\isa\s390x\lower.isle line 3080.
                return v36;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_body", "src\\isa\\s390x\\lower.isle line 3040")
}

// Generated as internal constructor for term atomic_rmw_body_rxsbg.
pub fn constructor_atomic_rmw_body_rxsbg<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: &RxSBGOp,
    arg4: WritableReg,
    arg5: Reg,
    arg6: Reg,
) -> Reg {
    match arg1 {
        I8 => {
            let v10 = constructor_push_rxsbg(ctx, arg0, arg3, arg4, arg5, arg6, 0x20_u8, 0x28_u8, 24_i8);
            // Rule at src\isa\s390x\lower.isle line 3090.
            return v10;
        }
        I16 => {
            let v11 = C::bigendian(ctx, arg2);
            if let Some(v12) = v11 {
                let v15 = constructor_push_rxsbg(ctx, arg0, arg3, arg4, arg5, arg6, 0x20_u8, 0x30_u8, 16_i8);
                // Rule at src\isa\s390x\lower.isle line 3094.
                return v15;
            }
            let v16 = C::littleendian(ctx, arg2);
            if let Some(v17) = v16 {
                let v19 = constructor_bswap_reg(ctx, I32, arg6);
                let v22 = constructor_push_rxsbg(ctx, arg0, arg3, arg4, arg5, v19, 0x30_u8, 0x40_u8, -16_i8);
                // Rule at src\isa\s390x\lower.isle line 3098.
                return v22;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_body_rxsbg", "src\\isa\\s390x\\lower.isle line 3087")
}

// Generated as internal constructor for term atomic_rmw_body_invert.
pub fn constructor_atomic_rmw_body_invert<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: WritableReg,
    arg4: Reg,
) -> Reg {
    match arg1 {
        I8 => {
            let v8 = C::uimm32shifted(ctx, 0xff000000_u32, 0x0_u8);
            let v9 = constructor_push_xor_uimm32shifted(ctx, arg0, I32, arg3, arg4, v8);
            // Rule at src\isa\s390x\lower.isle line 3104.
            return v9;
        }
        I16 => {
            let v10 = C::bigendian(ctx, arg2);
            if let Some(v11) = v10 {
                let v13 = C::uimm32shifted(ctx, 0xffff0000_u32, 0x0_u8);
                let v14 = constructor_push_xor_uimm32shifted(ctx, arg0, I32, arg3, arg4, v13);
                // Rule at src\isa\s390x\lower.isle line 3107.
                return v14;
            }
            let v15 = C::littleendian(ctx, arg2);
            if let Some(v16) = v15 {
                let v18 = C::uimm32shifted(ctx, 0xffff_u32, 0x0_u8);
                let v19 = constructor_push_xor_uimm32shifted(ctx, arg0, I32, arg3, arg4, v18);
                // Rule at src\isa\s390x\lower.isle line 3110.
                return v19;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_body_invert", "src\\isa\\s390x\\lower.isle line 3102")
}

// Generated as internal constructor for term atomic_rmw_body_addsub.
pub fn constructor_atomic_rmw_body_addsub<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: &ALUOp,
    arg4: WritableReg,
    arg5: Reg,
    arg6: Reg,
) -> Reg {
    let v5 = C::bigendian(ctx, arg2);
    if let Some(v6) = v5 {
        if arg1 == I16 {
            let v22 = constructor_lshl_imm(ctx, I32, arg6, 0x10_u8);
            let v23 = constructor_push_alu_reg(ctx, arg0, arg3, arg4, arg5, v22);
            // Rule at src\isa\s390x\lower.isle line 3137.
            return v23;
        }
        let v2 = C::ty_32_or_64(ctx, arg1);
        if let Some(v3) = v2 {
            let v11 = constructor_push_alu_reg(ctx, arg0, arg3, arg4, arg5, arg6);
            // Rule at src\isa\s390x\lower.isle line 3123.
            return v11;
        }
    }
    let v12 = C::littleendian(ctx, arg2);
    if let Some(v13) = v12 {
        let v2 = C::ty_32_or_64(ctx, arg1);
        if let Some(v3) = v2 {
            let v14 = constructor_push_bswap_reg(ctx, arg0, v3, arg4, arg5);
            let v15 = constructor_push_alu_reg(ctx, arg0, arg3, arg4, v14, arg6);
            let v16 = constructor_push_bswap_reg(ctx, arg0, v3, arg4, v15);
            // Rule at src\isa\s390x\lower.isle line 3127.
            return v16;
        }
        if arg1 == I16 {
            let v22 = constructor_lshl_imm(ctx, I32, arg6, 0x10_u8);
            let v24 = constructor_push_bswap_reg(ctx, arg0, I32, arg4, arg5);
            let v25 = constructor_push_alu_reg(ctx, arg0, arg3, arg4, v24, v22);
            let v26 = constructor_push_bswap_reg(ctx, arg0, I32, arg4, v25);
            // Rule at src\isa\s390x\lower.isle line 3145.
            return v26;
        }
    }
    if arg1 == I8 {
        let v19 = constructor_lshl_imm(ctx, I32, arg6, 0x18_u8);
        let v20 = constructor_push_alu_reg(ctx, arg0, arg3, arg4, arg5, v19);
        // Rule at src\isa\s390x\lower.isle line 3133.
        return v20;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_body_addsub", "src\\isa\\s390x\\lower.isle line 3120")
}

// Generated as internal constructor for term atomic_rmw_body_minmax.
pub fn constructor_atomic_rmw_body_minmax<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: &CmpOp,
    arg4: &Cond,
    arg5: WritableReg,
    arg6: Reg,
    arg7: Reg,
) -> Reg {
    let v5 = C::bigendian(ctx, arg2);
    if let Some(v6) = v5 {
        if arg1 == I16 {
            let v33 = constructor_lshl_imm(ctx, I32, arg7, 0x10_u8);
            let v34 = &constructor_cmp_rr(ctx, arg3, v33, arg6);
            let v19 = &C::invert_cond(ctx, arg4);
            let v35 = constructor_push_break_if(ctx, arg0, v34, v19);
            let v37 = constructor_push_rxsbg(ctx, arg0, &RxSBGOp::Insert, arg5, arg6, v33, 0x20_u8, 0x30_u8, 0_i8);
            // Rule at src\isa\s390x\lower.isle line 3196.
            return v37;
        }
        let v2 = C::ty_32_or_64(ctx, arg1);
        if let Some(v3) = v2 {
            let v12 = &constructor_cmp_rr(ctx, arg3, arg7, arg6);
            let v13 = &C::invert_cond(ctx, arg4);
            let v14 = constructor_push_break_if(ctx, arg0, v12, v13);
            // Rule at src\isa\s390x\lower.isle line 3171.
            return arg7;
        }
    }
    let v15 = C::littleendian(ctx, arg2);
    if let Some(v16) = v15 {
        let v2 = C::ty_32_or_64(ctx, arg1);
        if let Some(v3) = v2 {
            let v17 = constructor_push_bswap_reg(ctx, arg0, v3, arg5, arg6);
            let v18 = &constructor_cmp_rr(ctx, arg3, arg7, v17);
            let v19 = &C::invert_cond(ctx, arg4);
            let v20 = constructor_push_break_if(ctx, arg0, v18, v19);
            let v21 = constructor_push_bswap_reg(ctx, arg0, v3, arg5, arg7);
            // Rule at src\isa\s390x\lower.isle line 3178.
            return v21;
        }
        if arg1 == I16 {
            let v33 = constructor_lshl_imm(ctx, I32, arg7, 0x10_u8);
            let v38 = constructor_push_bswap_reg(ctx, arg0, I32, arg5, arg6);
            let v39 = &constructor_cmp_rr(ctx, arg3, v33, v38);
            let v40 = &C::invert_cond(ctx, arg4);
            let v41 = constructor_push_break_if(ctx, arg0, v39, v40);
            let v42 = constructor_push_rxsbg(ctx, arg0, &RxSBGOp::Insert, arg5, v38, v33, 0x20_u8, 0x30_u8, 0_i8);
            let v43 = constructor_push_bswap_reg(ctx, arg0, I32, arg5, v42);
            // Rule at src\isa\s390x\lower.isle line 3203.
            return v43;
        }
    }
    if arg1 == I8 {
        let v24 = constructor_lshl_imm(ctx, I32, arg7, 0x18_u8);
        let v25 = &constructor_cmp_rr(ctx, arg3, v24, arg6);
        let v19 = &C::invert_cond(ctx, arg4);
        let v26 = constructor_push_break_if(ctx, arg0, v25, v19);
        let v31 = constructor_push_rxsbg(ctx, arg0, &RxSBGOp::Insert, arg5, arg6, v24, 0x20_u8, 0x28_u8, 0_i8);
        // Rule at src\isa\s390x\lower.isle line 3190.
        return v31;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_rmw_body_minmax", "src\\isa\\s390x\\lower.isle line 3166")
}

// Generated as internal constructor for term atomic_cas_body.
pub fn constructor_atomic_cas_body<C: Context>(
    ctx: &mut C,
    arg0: &VecMInstBuilder,
    arg1: Type,
    arg2: MemFlags,
    arg3: WritableReg,
    arg4: Reg,
    arg5: Reg,
    arg6: Reg,
) -> Reg {
    match arg1 {
        I8 => {
            let v11 = &constructor_rxsbg_test(ctx, &RxSBGOp::Xor, arg4, arg5, 0x20_u8, 0x28_u8, 24_i8);
            let v13 = &C::intcc_as_cond(ctx, &IntCC::NotEqual);
            let v14 = constructor_push_break_if(ctx, arg0, v11, v13);
            let v16 = constructor_push_rxsbg(ctx, arg0, &RxSBGOp::Insert, arg3, arg4, arg6, 0x20_u8, 0x28_u8, 24_i8);
            // Rule at src\isa\s390x\lower.isle line 3255.
            return v16;
        }
        I16 => {
            let v17 = C::bigendian(ctx, arg2);
            if let Some(v18) = v17 {
                let v21 = &constructor_rxsbg_test(ctx, &RxSBGOp::Xor, arg4, arg5, 0x20_u8, 0x30_u8, 16_i8);
                let v13 = &C::intcc_as_cond(ctx, &IntCC::NotEqual);
                let v22 = constructor_push_break_if(ctx, arg0, v21, v13);
                let v23 = constructor_push_rxsbg(ctx, arg0, &RxSBGOp::Insert, arg3, arg4, arg6, 0x20_u8, 0x30_u8, 16_i8);
                // Rule at src\isa\s390x\lower.isle line 3262.
                return v23;
            }
            let v24 = C::littleendian(ctx, arg2);
            if let Some(v25) = v24 {
                let v27 = constructor_bswap_reg(ctx, I32, arg5);
                let v28 = constructor_bswap_reg(ctx, I32, arg6);
                let v31 = &constructor_rxsbg_test(ctx, &RxSBGOp::Xor, arg4, v27, 0x30_u8, 0x40_u8, -16_i8);
                let v32 = &C::intcc_as_cond(ctx, &IntCC::NotEqual);
                let v33 = constructor_push_break_if(ctx, arg0, v31, v32);
                let v34 = constructor_push_rxsbg(ctx, arg0, &RxSBGOp::Insert, arg3, arg4, v28, 0x30_u8, 0x40_u8, -16_i8);
                // Rule at src\isa\s390x\lower.isle line 3273.
                return v34;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "atomic_cas_body", "src\\isa\\s390x\\lower.isle line 3248")
}

// Generated as internal constructor for term atomic_store_impl.
pub fn constructor_atomic_store_impl<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> InstOutput {
    let v1 = constructor_side_effect(ctx, arg0);
    let v2 = &constructor_fence_impl(ctx);
    let v3 = constructor_side_effect(ctx, v2);
    // Rule at src\isa\s390x\lower.isle line 3319.
    return v3;
}

// Generated as internal constructor for term icmp_val.
pub fn constructor_icmp_val<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> ProducesBool {
    match arg1 {
        &IntCC::Equal => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v19 = C::put_in_reg(ctx, arg2);
                let v20 = C::put_in_reg(ctx, arg3);
                let v21 = &constructor_vec_cmpeqs(ctx, I64X2, v19, v20);
                let v23 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                let v24 = &constructor_bool(ctx, v21, v23);
                // Rule at src\isa\s390x\lower.isle line 3465.
                return v24.clone();
            }
        }
        &IntCC::NotEqual => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v19 = C::put_in_reg(ctx, arg2);
                let v20 = C::put_in_reg(ctx, arg3);
                let v21 = &constructor_vec_cmpeqs(ctx, I64X2, v19, v20);
                let v26 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                let v27 = &constructor_bool(ctx, v21, v26);
                // Rule at src\isa\s390x\lower.isle line 3468.
                return v27.clone();
            }
        }
        &IntCC::SignedGreaterThan => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v19 = C::put_in_reg(ctx, arg2);
                let v20 = C::put_in_reg(ctx, arg3);
                let v28 = &constructor_vec_int128_scmphi(ctx, v19, v20);
                // Rule at src\isa\s390x\lower.isle line 3474.
                return v28.clone();
            }
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v29 = C::put_in_reg(ctx, arg3);
                let v30 = C::put_in_reg(ctx, arg2);
                let v31 = &constructor_vec_int128_scmphi(ctx, v29, v30);
                let v32 = &constructor_invert_bool(ctx, v31);
                // Rule at src\isa\s390x\lower.isle line 3478.
                return v32.clone();
            }
        }
        &IntCC::SignedLessThan => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v29 = C::put_in_reg(ctx, arg3);
                let v30 = C::put_in_reg(ctx, arg2);
                let v31 = &constructor_vec_int128_scmphi(ctx, v29, v30);
                // Rule at src\isa\s390x\lower.isle line 3476.
                return v31.clone();
            }
        }
        &IntCC::SignedLessThanOrEqual => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v19 = C::put_in_reg(ctx, arg2);
                let v20 = C::put_in_reg(ctx, arg3);
                let v28 = &constructor_vec_int128_scmphi(ctx, v19, v20);
                let v33 = &constructor_invert_bool(ctx, v28);
                // Rule at src\isa\s390x\lower.isle line 3480.
                return v33.clone();
            }
        }
        &IntCC::UnsignedGreaterThan => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v19 = C::put_in_reg(ctx, arg2);
                let v20 = C::put_in_reg(ctx, arg3);
                let v34 = &constructor_vec_int128_ucmphi(ctx, v19, v20);
                // Rule at src\isa\s390x\lower.isle line 3485.
                return v34.clone();
            }
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v29 = C::put_in_reg(ctx, arg3);
                let v30 = C::put_in_reg(ctx, arg2);
                let v35 = &constructor_vec_int128_ucmphi(ctx, v29, v30);
                let v36 = &constructor_invert_bool(ctx, v35);
                // Rule at src\isa\s390x\lower.isle line 3489.
                return v36.clone();
            }
        }
        &IntCC::UnsignedLessThan => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v29 = C::put_in_reg(ctx, arg3);
                let v30 = C::put_in_reg(ctx, arg2);
                let v35 = &constructor_vec_int128_ucmphi(ctx, v29, v30);
                // Rule at src\isa\s390x\lower.isle line 3487.
                return v35.clone();
            }
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v5 = C::value_type(ctx, arg2);
            let v16 = C::vr128_ty(ctx, v5);
            if let Some(v17) = v16 {
                let v19 = C::put_in_reg(ctx, arg2);
                let v20 = C::put_in_reg(ctx, arg3);
                let v34 = &constructor_vec_int128_ucmphi(ctx, v19, v20);
                let v37 = &constructor_invert_bool(ctx, v34);
                // Rule at src\isa\s390x\lower.isle line 3491.
                return v37.clone();
            }
        }
        _ => {}
    }
    let v5 = C::value_type(ctx, arg2);
    let v6 = C::fits_in_64(ctx, v5);
    if let Some(v7) = v6 {
        let v2 = C::signed(ctx, arg1);
        if let Some(v3) = v2 {
            let v9 = &constructor_icmps_val(ctx, arg0, arg2, arg3);
            let v10 = &C::intcc_as_cond(ctx, arg1);
            let v11 = &constructor_bool(ctx, v9, v10);
            // Rule at src\isa\s390x\lower.isle line 3386.
            return v11.clone();
        }
        let v12 = C::unsigned(ctx, arg1);
        if let Some(v13) = v12 {
            let v14 = &constructor_icmpu_val(ctx, arg0, arg2, arg3);
            let v10 = &C::intcc_as_cond(ctx, arg1);
            let v15 = &constructor_bool(ctx, v14, v10);
            // Rule at src\isa\s390x\lower.isle line 3389.
            return v15.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "icmp_val", "src\\isa\\s390x\\lower.isle line 3383")
}

// Generated as internal constructor for term icmps_val.
pub fn constructor_icmps_val<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: Value,
    arg2: Value,
) -> ProducesFlags {
    let v2 = C::value_type(ctx, arg1);
    let v3 = C::fits_in_64(ctx, v2);
    if let Some(v4) = v3 {
        if arg0 == true {
            let v28 = C::sinkable_inst(ctx, arg2);
            if let Some(v29) = v28 {
                let v30 = &C::inst_data_value(ctx, v29);
                if let &InstructionData::Load {
                    opcode: ref v31,
                    arg: v32,
                    flags: v33,
                    offset: v34,
                } = v30 {
                    match v31 {
                        &Opcode::Load => {
                            let v35 = C::bigendian(ctx, v33);
                            if let Some(v36) = v35 {
                                let v25 = C::value_type(ctx, arg2);
                                if v25 == I16 {
                                    let v6 = constructor_ty_ext32(ctx, v4);
                                    let v7 = constructor_put_in_reg_sext32(ctx, arg1);
                                    let v39 = &constructor_sink_load(ctx, v29);
                                    let v40 = &constructor_icmps_mem_sext16(ctx, v6, v7, v39);
                                    // Rule at src\isa\s390x\lower.isle line 3415.
                                    return v40.clone();
                                }
                                let v26 = C::ty_32_or_64(ctx, v25);
                                if let Some(v27) = v26 {
                                    let v16 = C::put_in_reg(ctx, arg1);
                                    let v37 = &constructor_sink_load(ctx, v29);
                                    let v38 = &constructor_icmps_mem(ctx, v4, v16, v37);
                                    // Rule at src\isa\s390x\lower.isle line 3411.
                                    return v38.clone();
                                }
                            }
                        }
                        &Opcode::Sload16 => {
                            let v35 = C::bigendian(ctx, v33);
                            if let Some(v36) = v35 {
                                let v16 = C::put_in_reg(ctx, arg1);
                                let v41 = &constructor_sink_sload16(ctx, v29);
                                let v42 = &constructor_icmps_mem_sext16(ctx, v4, v16, v41);
                                // Rule at src\isa\s390x\lower.isle line 3419.
                                return v42.clone();
                            }
                        }
                        &Opcode::Sload32 => {
                            let v35 = C::bigendian(ctx, v33);
                            if let Some(v36) = v35 {
                                let v16 = C::put_in_reg(ctx, arg1);
                                let v43 = &constructor_sink_sload32(ctx, v29);
                                let v44 = &constructor_icmps_mem_sext32(ctx, v4, v16, v43);
                                // Rule at src\isa\s390x\lower.isle line 3421.
                                return v44.clone();
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
        let v10 = C::def_inst(ctx, arg2);
        if let Some(v11) = v10 {
            let v12 = &C::inst_data_value(ctx, v11);
            if let &InstructionData::Unary {
                opcode: ref v13,
                arg: v14,
            } = v12 {
                if let &Opcode::Sextend = v13 {
                    let v15 = C::value_type(ctx, v14);
                    if v15 == I32 {
                        let v16 = C::put_in_reg(ctx, arg1);
                        let v17 = C::put_in_reg(ctx, v14);
                        let v18 = &constructor_icmps_reg_sext32(ctx, v4, v16, v17);
                        // Rule at src\isa\s390x\lower.isle line 3401.
                        return v18.clone();
                    }
                }
            }
        }
        let v19 = C::i16_from_value(ctx, arg2);
        if let Some(v20) = v19 {
            let v6 = constructor_ty_ext32(ctx, v4);
            let v7 = constructor_put_in_reg_sext32(ctx, arg1);
            let v21 = &constructor_icmps_simm16(ctx, v6, v7, v20);
            // Rule at src\isa\s390x\lower.isle line 3405.
            return v21.clone();
        }
        let v22 = C::i32_from_value(ctx, arg2);
        if let Some(v23) = v22 {
            let v6 = constructor_ty_ext32(ctx, v4);
            let v7 = constructor_put_in_reg_sext32(ctx, arg1);
            let v24 = &constructor_icmps_simm32(ctx, v6, v7, v23);
            // Rule at src\isa\s390x\lower.isle line 3407.
            return v24.clone();
        }
        let v6 = constructor_ty_ext32(ctx, v4);
        let v7 = constructor_put_in_reg_sext32(ctx, arg1);
        let v8 = constructor_put_in_reg_sext32(ctx, arg2);
        let v9 = &constructor_icmps_reg(ctx, v6, v7, v8);
        // Rule at src\isa\s390x\lower.isle line 3397.
        return v9.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "icmps_val", "src\\isa\\s390x\\lower.isle line 3394")
}

// Generated as internal constructor for term icmpu_val.
pub fn constructor_icmpu_val<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: Value,
    arg2: Value,
) -> ProducesFlags {
    let v2 = C::value_type(ctx, arg1);
    let v3 = C::fits_in_64(ctx, v2);
    if let Some(v4) = v3 {
        if arg0 == true {
            let v25 = C::sinkable_inst(ctx, arg2);
            if let Some(v26) = v25 {
                let v27 = &C::inst_data_value(ctx, v26);
                if let &InstructionData::Load {
                    opcode: ref v28,
                    arg: v29,
                    flags: v30,
                    offset: v31,
                } = v27 {
                    match v28 {
                        &Opcode::Load => {
                            let v32 = C::bigendian(ctx, v30);
                            if let Some(v33) = v32 {
                                let v22 = C::value_type(ctx, arg2);
                                let v23 = C::ty_32_or_64(ctx, v22);
                                if let Some(v24) = v23 {
                                    let v16 = C::put_in_reg(ctx, arg1);
                                    let v34 = &constructor_sink_load(ctx, v26);
                                    let v35 = &constructor_icmpu_mem(ctx, v4, v16, v34);
                                    // Rule at src\isa\s390x\lower.isle line 3441.
                                    return v35.clone();
                                }
                                if v22 == I16 {
                                    let v36 = constructor_load_sym(ctx, v26);
                                    if let Some(v37) = v36 {
                                        let v6 = constructor_ty_ext32(ctx, v4);
                                        let v7 = constructor_put_in_reg_zext32(ctx, arg1);
                                        let v38 = &constructor_sink_load(ctx, v37);
                                        let v39 = &constructor_icmpu_mem_zext16(ctx, v6, v7, v38);
                                        // Rule at src\isa\s390x\lower.isle line 3447.
                                        return v39.clone();
                                    }
                                }
                            }
                        }
                        &Opcode::Uload16 => {
                            let v32 = C::bigendian(ctx, v30);
                            if let Some(v33) = v32 {
                                let v40 = constructor_uload16_sym(ctx, v26);
                                if let Some(v41) = v40 {
                                    let v16 = C::put_in_reg(ctx, arg1);
                                    let v42 = &constructor_sink_uload16(ctx, v41);
                                    let v43 = &constructor_icmpu_mem_zext16(ctx, v4, v16, v42);
                                    // Rule at src\isa\s390x\lower.isle line 3455.
                                    return v43.clone();
                                }
                            }
                        }
                        &Opcode::Uload32 => {
                            let v32 = C::bigendian(ctx, v30);
                            if let Some(v33) = v32 {
                                let v16 = C::put_in_reg(ctx, arg1);
                                let v44 = &constructor_sink_uload32(ctx, v26);
                                let v45 = &constructor_icmpu_mem_zext32(ctx, v4, v16, v44);
                                // Rule at src\isa\s390x\lower.isle line 3459.
                                return v45.clone();
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
        let v19 = C::u32_from_value(ctx, arg2);
        if let Some(v20) = v19 {
            let v6 = constructor_ty_ext32(ctx, v4);
            let v7 = constructor_put_in_reg_zext32(ctx, arg1);
            let v21 = &constructor_icmpu_uimm32(ctx, v6, v7, v20);
            // Rule at src\isa\s390x\lower.isle line 3437.
            return v21.clone();
        }
        let v10 = C::def_inst(ctx, arg2);
        if let Some(v11) = v10 {
            let v12 = &C::inst_data_value(ctx, v11);
            if let &InstructionData::Unary {
                opcode: ref v13,
                arg: v14,
            } = v12 {
                if let &Opcode::Uextend = v13 {
                    let v15 = C::value_type(ctx, v14);
                    if v15 == I32 {
                        let v16 = C::put_in_reg(ctx, arg1);
                        let v17 = C::put_in_reg(ctx, v14);
                        let v18 = &constructor_icmpu_reg_zext32(ctx, v4, v16, v17);
                        // Rule at src\isa\s390x\lower.isle line 3433.
                        return v18.clone();
                    }
                }
            }
        }
        let v6 = constructor_ty_ext32(ctx, v4);
        let v7 = constructor_put_in_reg_zext32(ctx, arg1);
        let v8 = constructor_put_in_reg_zext32(ctx, arg2);
        let v9 = &constructor_icmpu_reg(ctx, v6, v7, v8);
        // Rule at src\isa\s390x\lower.isle line 3429.
        return v9.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "icmpu_val", "src\\isa\\s390x\\lower.isle line 3426")
}

// Generated as internal constructor for term fcmp_val.
pub fn constructor_fcmp_val<C: Context>(
    ctx: &mut C,
    arg0: &FloatCC,
    arg1: Value,
    arg2: Value,
) -> ProducesBool {
    let v4 = C::put_in_reg(ctx, arg1);
    let v5 = C::put_in_reg(ctx, arg2);
    let v2 = C::value_type(ctx, arg1);
    let v6 = &constructor_fcmp_reg(ctx, v2, v4, v5);
    let v7 = &C::floatcc_as_cond(ctx, arg0);
    let v8 = &constructor_bool(ctx, v6, v7);
    // Rule at src\isa\s390x\lower.isle line 3529.
    return v8.clone();
}

// Generated as internal constructor for term vall_true_val.
pub fn constructor_vall_true_val<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> ProducesBool {
    let v9 = C::def_inst(ctx, arg0);
    if let Some(v10) = v9 {
        let v11 = C::first_result(ctx, v10);
        if let Some(v12) = v11 {
            let v14 = &C::inst_data_value(ctx, v10);
            match v14 {
                &InstructionData::FloatCompare {
                    opcode: ref v42,
                    args: ref v43,
                    cond: ref v44,
                } => {
                    if let &Opcode::Fcmp = v42 {
                        match v44 {
                            &FloatCC::Equal => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v50 = &constructor_vec_fcmpeqs(ctx, v13, v48, v49);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v51 = &constructor_bool(ctx, v50, v25);
                                // Rule at src\isa\s390x\lower.isle line 3612.
                                return v51.clone();
                            }
                            &FloatCC::GreaterThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v53 = &constructor_vec_fcmphs(ctx, v13, v48, v49);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v54 = &constructor_bool(ctx, v53, v25);
                                // Rule at src\isa\s390x\lower.isle line 3618.
                                return v54.clone();
                            }
                            &FloatCC::GreaterThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v56 = &constructor_vec_fcmphes(ctx, v13, v48, v49);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v57 = &constructor_bool(ctx, v56, v25);
                                // Rule at src\isa\s390x\lower.isle line 3624.
                                return v57.clone();
                            }
                            &FloatCC::LessThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v61 = &constructor_vec_fcmphs(ctx, v13, v59, v60);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v62 = &constructor_bool(ctx, v61, v25);
                                // Rule at src\isa\s390x\lower.isle line 3630.
                                return v62.clone();
                            }
                            &FloatCC::LessThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v64 = &constructor_vec_fcmphes(ctx, v13, v59, v60);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v65 = &constructor_bool(ctx, v64, v25);
                                // Rule at src\isa\s390x\lower.isle line 3636.
                                return v65.clone();
                            }
                            &FloatCC::NotEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v50 = &constructor_vec_fcmpeqs(ctx, v13, v48, v49);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v52 = &constructor_bool(ctx, v50, v7);
                                // Rule at src\isa\s390x\lower.isle line 3615.
                                return v52.clone();
                            }
                            &FloatCC::UnorderedOrGreaterThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v64 = &constructor_vec_fcmphes(ctx, v13, v59, v60);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v66 = &constructor_bool(ctx, v64, v7);
                                // Rule at src\isa\s390x\lower.isle line 3639.
                                return v66.clone();
                            }
                            &FloatCC::UnorderedOrGreaterThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v61 = &constructor_vec_fcmphs(ctx, v13, v59, v60);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v63 = &constructor_bool(ctx, v61, v7);
                                // Rule at src\isa\s390x\lower.isle line 3633.
                                return v63.clone();
                            }
                            &FloatCC::UnorderedOrLessThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v56 = &constructor_vec_fcmphes(ctx, v13, v48, v49);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v58 = &constructor_bool(ctx, v56, v7);
                                // Rule at src\isa\s390x\lower.isle line 3627.
                                return v58.clone();
                            }
                            &FloatCC::UnorderedOrLessThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v53 = &constructor_vec_fcmphs(ctx, v13, v48, v49);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v55 = &constructor_bool(ctx, v53, v7);
                                // Rule at src\isa\s390x\lower.isle line 3621.
                                return v55.clone();
                            }
                            _ => {}
                        }
                    }
                }
                &InstructionData::IntCompare {
                    opcode: ref v15,
                    args: ref v16,
                    cond: ref v17,
                } => {
                    if let &Opcode::Icmp = v15 {
                        match v17 {
                            &IntCC::Equal => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v23 = &constructor_vec_cmpeqs(ctx, v13, v21, v22);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v26 = &constructor_bool(ctx, v23, v25);
                                // Rule at src\isa\s390x\lower.isle line 3580.
                                return v26.clone();
                            }
                            &IntCC::NotEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v23 = &constructor_vec_cmpeqs(ctx, v13, v21, v22);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v27 = &constructor_bool(ctx, v23, v7);
                                // Rule at src\isa\s390x\lower.isle line 3583.
                                return v27.clone();
                            }
                            &IntCC::SignedGreaterThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v28 = &constructor_vec_cmphs(ctx, v13, v21, v22);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v29 = &constructor_bool(ctx, v28, v25);
                                // Rule at src\isa\s390x\lower.isle line 3586.
                                return v29.clone();
                            }
                            &IntCC::SignedGreaterThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v33 = &constructor_vec_cmphs(ctx, v13, v31, v32);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v35 = &constructor_bool(ctx, v33, v7);
                                // Rule at src\isa\s390x\lower.isle line 3595.
                                return v35.clone();
                            }
                            &IntCC::SignedLessThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v33 = &constructor_vec_cmphs(ctx, v13, v31, v32);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v34 = &constructor_bool(ctx, v33, v25);
                                // Rule at src\isa\s390x\lower.isle line 3592.
                                return v34.clone();
                            }
                            &IntCC::SignedLessThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v28 = &constructor_vec_cmphs(ctx, v13, v21, v22);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v30 = &constructor_bool(ctx, v28, v7);
                                // Rule at src\isa\s390x\lower.isle line 3589.
                                return v30.clone();
                            }
                            &IntCC::UnsignedGreaterThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v36 = &constructor_vec_cmphls(ctx, v13, v21, v22);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v37 = &constructor_bool(ctx, v36, v25);
                                // Rule at src\isa\s390x\lower.isle line 3598.
                                return v37.clone();
                            }
                            &IntCC::UnsignedGreaterThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v39 = &constructor_vec_cmphls(ctx, v13, v31, v32);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v41 = &constructor_bool(ctx, v39, v7);
                                // Rule at src\isa\s390x\lower.isle line 3607.
                                return v41.clone();
                            }
                            &IntCC::UnsignedLessThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v39 = &constructor_vec_cmphls(ctx, v13, v31, v32);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Equal);
                                let v40 = &constructor_bool(ctx, v39, v25);
                                // Rule at src\isa\s390x\lower.isle line 3604.
                                return v40.clone();
                            }
                            &IntCC::UnsignedLessThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v36 = &constructor_vec_cmphls(ctx, v13, v21, v22);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
                                let v38 = &constructor_bool(ctx, v36, v7);
                                // Rule at src\isa\s390x\lower.isle line 3601.
                                return v38.clone();
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }
    }
    let v2 = C::put_in_reg(ctx, arg0);
    let v1 = C::value_type(ctx, arg0);
    let v4 = constructor_vec_imm(ctx, v1, 0x0_u128);
    let v5 = &constructor_vec_cmpeqs(ctx, v1, v2, v4);
    let v7 = &C::floatcc_as_cond(ctx, &FloatCC::Unordered);
    let v8 = &constructor_bool(ctx, v5, v7);
    // Rule at src\isa\s390x\lower.isle line 3575.
    return v8.clone();
}

// Generated as internal constructor for term vany_true_val.
pub fn constructor_vany_true_val<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> ProducesBool {
    let v9 = C::def_inst(ctx, arg0);
    if let Some(v10) = v9 {
        let v11 = C::first_result(ctx, v10);
        if let Some(v12) = v11 {
            let v14 = &C::inst_data_value(ctx, v10);
            match v14 {
                &InstructionData::FloatCompare {
                    opcode: ref v42,
                    args: ref v43,
                    cond: ref v44,
                } => {
                    if let &Opcode::Fcmp = v42 {
                        match v44 {
                            &FloatCC::Equal => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v50 = &constructor_vec_fcmpeqs(ctx, v13, v48, v49);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v51 = &constructor_bool(ctx, v50, v25);
                                // Rule at src\isa\s390x\lower.isle line 3690.
                                return v51.clone();
                            }
                            &FloatCC::GreaterThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v53 = &constructor_vec_fcmphs(ctx, v13, v48, v49);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v54 = &constructor_bool(ctx, v53, v25);
                                // Rule at src\isa\s390x\lower.isle line 3696.
                                return v54.clone();
                            }
                            &FloatCC::GreaterThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v56 = &constructor_vec_fcmphes(ctx, v13, v48, v49);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v57 = &constructor_bool(ctx, v56, v25);
                                // Rule at src\isa\s390x\lower.isle line 3702.
                                return v57.clone();
                            }
                            &FloatCC::LessThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v61 = &constructor_vec_fcmphs(ctx, v13, v59, v60);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v62 = &constructor_bool(ctx, v61, v25);
                                // Rule at src\isa\s390x\lower.isle line 3708.
                                return v62.clone();
                            }
                            &FloatCC::LessThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v64 = &constructor_vec_fcmphes(ctx, v13, v59, v60);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v65 = &constructor_bool(ctx, v64, v25);
                                // Rule at src\isa\s390x\lower.isle line 3714.
                                return v65.clone();
                            }
                            &FloatCC::NotEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v50 = &constructor_vec_fcmpeqs(ctx, v13, v48, v49);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v52 = &constructor_bool(ctx, v50, v7);
                                // Rule at src\isa\s390x\lower.isle line 3693.
                                return v52.clone();
                            }
                            &FloatCC::UnorderedOrGreaterThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v64 = &constructor_vec_fcmphes(ctx, v13, v59, v60);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v66 = &constructor_bool(ctx, v64, v7);
                                // Rule at src\isa\s390x\lower.isle line 3717.
                                return v66.clone();
                            }
                            &FloatCC::UnorderedOrGreaterThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v59 = C::put_in_reg(ctx, v45.1);
                                let v60 = C::put_in_reg(ctx, v45.0);
                                let v13 = C::value_type(ctx, v12);
                                let v61 = &constructor_vec_fcmphs(ctx, v13, v59, v60);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v63 = &constructor_bool(ctx, v61, v7);
                                // Rule at src\isa\s390x\lower.isle line 3711.
                                return v63.clone();
                            }
                            &FloatCC::UnorderedOrLessThan => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v56 = &constructor_vec_fcmphes(ctx, v13, v48, v49);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v58 = &constructor_bool(ctx, v56, v7);
                                // Rule at src\isa\s390x\lower.isle line 3705.
                                return v58.clone();
                            }
                            &FloatCC::UnorderedOrLessThanOrEqual => {
                                let v45 = C::unpack_value_array_2(ctx, v43);
                                let v48 = C::put_in_reg(ctx, v45.0);
                                let v49 = C::put_in_reg(ctx, v45.1);
                                let v13 = C::value_type(ctx, v12);
                                let v53 = &constructor_vec_fcmphs(ctx, v13, v48, v49);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v55 = &constructor_bool(ctx, v53, v7);
                                // Rule at src\isa\s390x\lower.isle line 3699.
                                return v55.clone();
                            }
                            _ => {}
                        }
                    }
                }
                &InstructionData::IntCompare {
                    opcode: ref v15,
                    args: ref v16,
                    cond: ref v17,
                } => {
                    if let &Opcode::Icmp = v15 {
                        match v17 {
                            &IntCC::Equal => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v23 = &constructor_vec_cmpeqs(ctx, v13, v21, v22);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v26 = &constructor_bool(ctx, v23, v25);
                                // Rule at src\isa\s390x\lower.isle line 3658.
                                return v26.clone();
                            }
                            &IntCC::NotEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v23 = &constructor_vec_cmpeqs(ctx, v13, v21, v22);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v27 = &constructor_bool(ctx, v23, v7);
                                // Rule at src\isa\s390x\lower.isle line 3661.
                                return v27.clone();
                            }
                            &IntCC::SignedGreaterThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v28 = &constructor_vec_cmphs(ctx, v13, v21, v22);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v29 = &constructor_bool(ctx, v28, v25);
                                // Rule at src\isa\s390x\lower.isle line 3664.
                                return v29.clone();
                            }
                            &IntCC::SignedGreaterThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v33 = &constructor_vec_cmphs(ctx, v13, v31, v32);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v35 = &constructor_bool(ctx, v33, v7);
                                // Rule at src\isa\s390x\lower.isle line 3673.
                                return v35.clone();
                            }
                            &IntCC::SignedLessThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v33 = &constructor_vec_cmphs(ctx, v13, v31, v32);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v34 = &constructor_bool(ctx, v33, v25);
                                // Rule at src\isa\s390x\lower.isle line 3670.
                                return v34.clone();
                            }
                            &IntCC::SignedLessThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v28 = &constructor_vec_cmphs(ctx, v13, v21, v22);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v30 = &constructor_bool(ctx, v28, v7);
                                // Rule at src\isa\s390x\lower.isle line 3667.
                                return v30.clone();
                            }
                            &IntCC::UnsignedGreaterThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v36 = &constructor_vec_cmphls(ctx, v13, v21, v22);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v37 = &constructor_bool(ctx, v36, v25);
                                // Rule at src\isa\s390x\lower.isle line 3676.
                                return v37.clone();
                            }
                            &IntCC::UnsignedGreaterThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v39 = &constructor_vec_cmphls(ctx, v13, v31, v32);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v41 = &constructor_bool(ctx, v39, v7);
                                // Rule at src\isa\s390x\lower.isle line 3685.
                                return v41.clone();
                            }
                            &IntCC::UnsignedLessThan => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v31 = C::put_in_reg(ctx, v18.1);
                                let v32 = C::put_in_reg(ctx, v18.0);
                                let v13 = C::value_type(ctx, v12);
                                let v39 = &constructor_vec_cmphls(ctx, v13, v31, v32);
                                let v25 = &C::floatcc_as_cond(ctx, &FloatCC::Ordered);
                                let v40 = &constructor_bool(ctx, v39, v25);
                                // Rule at src\isa\s390x\lower.isle line 3682.
                                return v40.clone();
                            }
                            &IntCC::UnsignedLessThanOrEqual => {
                                let v18 = C::unpack_value_array_2(ctx, v16);
                                let v21 = C::put_in_reg(ctx, v18.0);
                                let v22 = C::put_in_reg(ctx, v18.1);
                                let v13 = C::value_type(ctx, v12);
                                let v36 = &constructor_vec_cmphls(ctx, v13, v21, v22);
                                let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
                                let v38 = &constructor_bool(ctx, v36, v7);
                                // Rule at src\isa\s390x\lower.isle line 3679.
                                return v38.clone();
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }
    }
    let v2 = C::put_in_reg(ctx, arg0);
    let v1 = C::value_type(ctx, arg0);
    let v4 = constructor_vec_imm(ctx, v1, 0x0_u128);
    let v5 = &constructor_vec_cmpeqs(ctx, v1, v2, v4);
    let v7 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
    let v8 = &constructor_bool(ctx, v5, v7);
    // Rule at src\isa\s390x\lower.isle line 3653.
    return v8.clone();
}

// Generated as internal constructor for term value_nonzero.
pub fn constructor_value_nonzero<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> ProducesBool {
    let v1 = C::def_inst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = &C::inst_data_value(ctx, v2);
        match v3 {
            &InstructionData::FloatCompare {
                opcode: ref v12,
                args: ref v13,
                cond: ref v14,
            } => {
                if let &Opcode::Fcmp = v12 {
                    let v15 = C::unpack_value_array_2(ctx, v13);
                    let v18 = &constructor_fcmp_val(ctx, v14, v15.0, v15.1);
                    // Rule at src\isa\s390x\lower.isle line 3777.
                    return v18.clone();
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v4,
                args: ref v5,
                cond: ref v6,
            } => {
                if let &Opcode::Icmp = v4 {
                    let v10 = false;
                    let v7 = C::unpack_value_array_2(ctx, v5);
                    let v11 = &constructor_icmp_val(ctx, v10, v6, v7.0, v7.1);
                    // Rule at src\isa\s390x\lower.isle line 3776.
                    return v11.clone();
                }
            }
            _ => {}
        }
    }
    let v19 = C::value_type(ctx, arg0);
    let v20 = C::gpr32_ty(ctx, v19);
    if let Some(v21) = v20 {
        let v23 = constructor_put_in_reg_sext32(ctx, arg0);
        let v25 = &constructor_icmps_simm16(ctx, I32, v23, 0_i16);
        let v27 = &C::intcc_as_cond(ctx, &IntCC::NotEqual);
        let v28 = &constructor_bool(ctx, v25, v27);
        // Rule at src\isa\s390x\lower.isle line 3778.
        return v28.clone();
    }
    let v29 = C::gpr64_ty(ctx, v19);
    if let Some(v30) = v29 {
        let v32 = C::put_in_reg(ctx, arg0);
        let v33 = &constructor_icmps_simm16(ctx, I64, v32, 0_i16);
        let v27 = &C::intcc_as_cond(ctx, &IntCC::NotEqual);
        let v34 = &constructor_bool(ctx, v33, v27);
        // Rule at src\isa\s390x\lower.isle line 3781.
        return v34.clone();
    }
    let v35 = C::vr128_ty(ctx, v19);
    if let Some(v36) = v35 {
        let v32 = C::put_in_reg(ctx, arg0);
        let v39 = constructor_vec_imm(ctx, I64X2, 0x0_u128);
        let v40 = &constructor_vec_cmpeqs(ctx, I64X2, v32, v39);
        let v42 = &C::floatcc_as_cond(ctx, &FloatCC::NotEqual);
        let v43 = &constructor_bool(ctx, v40, v42);
        // Rule at src\isa\s390x\lower.isle line 3784.
        return v43.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "value_nonzero", "src\\isa\\s390x\\lower.isle line 3775")
}

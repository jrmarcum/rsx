// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src\prelude.isle
// - src\prelude_lower.isle
// - src\isa\pulley_shared\inst.isle
// - src\isa\pulley_shared\lower.isle
// - <OUT_DIR>\numerics.isle
// - <OUT_DIR>\pulley_gen.isle
// - <OUT_DIR>\clif_lower.isle

use super::*;  // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self, ) -> Unit;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> i32;
    fn checked_add_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> Option<u64>;
    fn add_overflows_with_type(&mut self, arg0: Type, arg1: u64, arg2: u64) -> bool;
    fn imm64_sdiv(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_srem(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Option<Imm64>;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn i64_sextend_u64(&mut self, arg0: Type, arg1: u64) -> i64;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn imm64_clz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn imm64_ctz(&mut self, arg0: Type, arg1: Imm64) -> Imm64;
    fn u128_replicated_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_replicated_u32(&mut self, arg0: u64) -> Option<u64>;
    fn u32_replicated_u16(&mut self, arg0: u64) -> Option<u64>;
    fn u16_replicated_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u128_low_bits(&mut self, arg0: u128) -> u64;
    fn u128_high_bits(&mut self, arg0: u128) -> u64;
    fn f16_min(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_max(&mut self, arg0: Ieee16, arg1: Ieee16) -> Option<Ieee16>;
    fn f16_neg(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_abs(&mut self, arg0: Ieee16) -> Ieee16;
    fn f16_copysign(&mut self, arg0: Ieee16, arg1: Ieee16) -> Ieee16;
    fn f32_add(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sub(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_mul(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_div(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_sqrt(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_ceil(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_floor(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_trunc(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_nearest(&mut self, arg0: Ieee32) -> Option<Ieee32>;
    fn f32_min(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_max(&mut self, arg0: Ieee32, arg1: Ieee32) -> Option<Ieee32>;
    fn f32_neg(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_abs(&mut self, arg0: Ieee32) -> Ieee32;
    fn f32_copysign(&mut self, arg0: Ieee32, arg1: Ieee32) -> Ieee32;
    fn f64_add(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sub(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_mul(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_div(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_sqrt(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_ceil(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_floor(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_trunc(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_nearest(&mut self, arg0: Ieee64) -> Option<Ieee64>;
    fn f64_min(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_max(&mut self, arg0: Ieee64, arg1: Ieee64) -> Option<Ieee64>;
    fn f64_neg(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_abs(&mut self, arg0: Ieee64) -> Ieee64;
    fn f64_copysign(&mut self, arg0: Ieee64, arg1: Ieee64) -> Ieee64;
    fn f128_min(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_max(&mut self, arg0: Ieee128, arg1: Ieee128) -> Option<Ieee128>;
    fn f128_neg(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_abs(&mut self, arg0: Ieee128) -> Ieee128;
    fn f128_copysign(&mut self, arg0: Ieee128, arg1: Ieee128) -> Ieee128;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_count(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn ty_half_lanes(&mut self, arg0: Type) -> Option<Type>;
    fn ty_half_width(&mut self, arg0: Type) -> Option<Type>;
    fn ty_equal(&mut self, arg0: Type, arg1: Type) -> bool;
    fn mem_flags_trusted(&mut self, ) -> MemFlags;
    fn little_or_native_endian(&mut self, arg0: MemFlags) -> Option<MemFlags>;
    fn intcc_swap_args(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_complement(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_without_eq(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_swap_args(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_complement(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn ty_16_or_32(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u16_from_ieee16(&mut self, arg0: Ieee16) -> u16;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_i32(&mut self, arg0: Offset32) -> i32;
    fn i32_to_offset32(&mut self, arg0: i32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self, ) -> TrapCode;
    fn trap_code_integer_overflow(&mut self, ) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self, ) -> TrapCode;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn writable_value_reg(&mut self, arg0: WritableReg) -> WritableValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn writable_value_regs(&mut self, arg0: WritableReg, arg1: WritableReg) -> WritableValueRegs;
    fn value_regs_invalid(&mut self, ) -> ValueRegs;
    fn output_none(&mut self, ) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_vec(&mut self, arg0: &ValueRegsVec) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn is_valid_reg(&mut self, arg0: Reg) -> bool;
    fn invalid_reg(&mut self, ) -> Reg;
    fn mark_value_used(&mut self, arg0: Value) -> Unit;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn put_in_regs_vec(&mut self, arg0: ValueSlice) -> ValueRegsVec;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn value_regs_len(&mut self, arg0: ValueRegs) -> usize;
    fn preg_to_reg(&mut self, arg0: PReg) -> Reg;
    fn add_range_fact(&mut self, arg0: Reg, arg1: u16, arg2: u64, arg3: u64) -> Reg;
    fn single_target(&mut self, arg0: &MachLabelSlice) -> Option<MachLabel>;
    fn two_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, MachLabel)>;
    fn jump_table_targets(&mut self, arg0: &MachLabelSlice) -> Option<(MachLabel, BoxVecMachLabel)>;
    fn jump_table_size(&mut self, arg0: &BoxVecMachLabel) -> u32;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn value_is_unused(&mut self, arg0: Value) -> bool;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data_value(&mut self, arg0: Inst) -> InstructionData;
    fn i64_from_iconst(&mut self, arg0: Value) -> Option<i64>;
    fn zero_value(&mut self, arg0: Value) -> Option<Value>;
    fn is_sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn maybe_uextend(&mut self, arg0: Value) -> Option<Value>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn block_exn_successor_label(&mut self, arg0: &Block, arg1: u64) -> MachLabel;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn sink_inst(&mut self, arg0: Inst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u64_be_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u128_le_const(&mut self, arg0: u128) -> VCodeConstant;
    fn emit_u128_be_const(&mut self, arg0: u128) -> VCodeConstant;
    fn const_to_vconst(&mut self, arg0: Constant) -> VCodeConstant;
    fn tls_model(&mut self, arg0: Type) -> TlsModel;
    fn tls_model_is_elf_gd(&mut self, ) -> Option<Unit>;
    fn tls_model_is_macho(&mut self, ) -> Option<Unit>;
    fn tls_model_is_coff(&mut self, ) -> Option<Unit>;
    fn preserve_frame_pointers(&mut self, ) -> Option<Unit>;
    fn stack_switch_model(&mut self, ) -> Option<StackSwitchModel>;
    fn box_external_name(&mut self, arg0: ExternalName) -> BoxExternalName;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn exception_sig(&mut self, arg0: ExceptionTable) -> SigRef;
    fn symbol_value_data(&mut self, arg0: GlobalValue) -> Option<(ExternalName, RelocDistance, i64)>;
    fn vec_mask_from_immediate(&mut self, arg0: Immediate) -> Option<VecMask>;
    fn u128_from_immediate(&mut self, arg0: Immediate) -> Option<u128>;
    fn vconst_from_immediate(&mut self, arg0: Immediate) -> Option<VCodeConstant>;
    fn u128_from_constant(&mut self, arg0: Constant) -> Option<u128>;
    fn u64_from_constant(&mut self, arg0: Constant) -> Option<u64>;
    fn shuffle64_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8)>;
    fn shuffle32_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8)>;
    fn shuffle16_from_imm(&mut self, arg0: Immediate) -> Option<(u8, u8, u8, u8, u8, u8, u8, u8)>;
    fn only_writable_reg(&mut self, arg0: WritableValueRegs) -> Option<WritableReg>;
    fn writable_regs_get(&mut self, arg0: WritableValueRegs, arg1: usize) -> WritableReg;
    fn abi_sig(&mut self, arg0: SigRef) -> Sig;
    fn abi_num_args(&mut self, arg0: Sig) -> usize;
    fn abi_get_arg(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_num_rets(&mut self, arg0: Sig) -> usize;
    fn abi_get_ret(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_ret_arg(&mut self, arg0: Sig) -> Option<ABIArg>;
    fn abi_no_ret_arg(&mut self, arg0: Sig) -> Option<()>;
    fn abi_unwrap_ret_area_ptr(&mut self, ) -> Reg;
    fn abi_stackslot_addr(&mut self, arg0: WritableReg, arg1: StackSlot, arg2: Offset32) -> MInst;
    fn abi_stackslot_offset_into_slot_region(&mut self, arg0: StackSlot, arg1: Offset32, arg2: Offset32) -> i32;
    fn abi_dynamic_stackslot_addr(&mut self, arg0: WritableReg, arg1: DynamicStackSlot) -> MInst;
    fn abi_arg_only_slot(&mut self, arg0: &ABIArg) -> Option<ABIArgSlot>;
    fn abi_arg_implicit_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, Type)>;
    fn real_reg_to_reg(&mut self, arg0: RealReg) -> Reg;
    fn real_reg_to_writable_reg(&mut self, arg0: RealReg) -> WritableReg;
    fn gen_move(&mut self, arg0: Type, arg1: WritableReg, arg2: Reg) -> MInst;
    fn gen_return(&mut self, arg0: &ValueRegsVec) -> Unit;
    fn gen_call_output(&mut self, arg0: SigRef) -> ValueRegsVec;
    fn gen_call_args(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallArgList;
    fn gen_return_call_args(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallArgList;
    fn gen_call_rets(&mut self, arg0: Sig, arg1: &ValueRegsVec) -> CallRetList;
    fn gen_try_call_rets(&mut self, arg0: Sig) -> CallRetList;
    fn gen_patchable_call_rets(&mut self, ) -> CallRetList;
    fn try_call_info(&mut self, arg0: ExceptionTable, arg1: &MachLabelSlice) -> OptionTryCallInfo;
    fn try_call_none(&mut self, ) -> OptionTryCallInfo;
    fn safe_divisor_from_imm64(&mut self, arg0: Type, arg1: Imm64) -> Option<u64>;
    fn cond_invert(&mut self, arg0: &Cond) -> Cond;
    fn endianness(&mut self, arg0: MemFlags) -> Endianness;
    fn is_native_endianness(&mut self, arg0: &Endianness) -> bool;
    fn pointer_width(&mut self, ) -> PointerWidth;
    fn memflags_nontrapping(&mut self, arg0: MemFlags) -> bool;
    fn memflags_is_wasm(&mut self, arg0: MemFlags) -> bool;
    fn g32_offset(&mut self, arg0: i32, arg1: Type, arg2: u64) -> Option<u16>;
    fn xreg_new(&mut self, arg0: Reg) -> XReg;
    fn writable_xreg_new(&mut self, arg0: WritableReg) -> WritableXReg;
    fn writable_xreg_to_xreg(&mut self, arg0: WritableXReg) -> XReg;
    fn writable_xreg_to_writable_reg(&mut self, arg0: WritableXReg) -> WritableReg;
    fn xreg_to_reg(&mut self, arg0: XReg) -> Reg;
    fn freg_new(&mut self, arg0: Reg) -> FReg;
    fn writable_freg_new(&mut self, arg0: WritableReg) -> WritableFReg;
    fn writable_freg_to_freg(&mut self, arg0: WritableFReg) -> FReg;
    fn writable_freg_to_writable_reg(&mut self, arg0: WritableFReg) -> WritableReg;
    fn freg_to_reg(&mut self, arg0: FReg) -> Reg;
    fn vreg_new(&mut self, arg0: Reg) -> VReg;
    fn writable_vreg_new(&mut self, arg0: WritableReg) -> WritableVReg;
    fn writable_vreg_to_vreg(&mut self, arg0: WritableVReg) -> VReg;
    fn writable_vreg_to_writable_reg(&mut self, arg0: WritableVReg) -> WritableReg;
    fn vreg_to_reg(&mut self, arg0: VReg) -> Reg;
    fn sp_reg(&mut self, ) -> XReg;
    fn gen_call_info(&mut self, arg0: Sig, arg1: ExternalName, arg2: CallArgList, arg3: CallRetList, arg4: OptionTryCallInfo) -> BoxCallInfo;
    fn gen_call_ind_info(&mut self, arg0: Sig, arg1: Reg, arg2: CallArgList, arg3: CallRetList, arg4: OptionTryCallInfo) -> BoxCallIndInfo;
    fn gen_call_host_info(&mut self, arg0: Sig, arg1: ExternalName, arg2: CallArgList, arg3: CallRetList, arg4: OptionTryCallInfo) -> BoxCallIndirectHostInfo;
    fn gen_return_call_info(&mut self, arg0: Sig, arg1: ExternalName, arg2: CallArgList) -> BoxReturnCallInfo;
    fn gen_return_call_ind_info(&mut self, arg0: Sig, arg1: Reg, arg2: CallArgList) -> BoxReturnCallIndInfo;
    fn u6_from_u8(&mut self, arg0: u8) -> Option<U6>;
    fn i8_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_ne(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_lt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_gt_eq(&mut self, arg0: i8, arg1: i8) -> bool;
    fn i8_checked_add(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_add(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_sub(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_sub(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_mul(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_mul(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_div(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_wrapping_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_div(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_checked_rem(&mut self, arg0: i8, arg1: i8) -> Option<i8>;
    fn i8_rem(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_and(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_or(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_xor(&mut self, arg0: i8, arg1: i8) -> i8;
    fn i8_not(&mut self, arg0: i8) -> i8;
    fn i8_checked_shl(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shl(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_checked_shr(&mut self, arg0: i8, arg1: u32) -> Option<i8>;
    fn i8_wrapping_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_shr(&mut self, arg0: i8, arg1: u32) -> i8;
    fn i8_is_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_non_zero(&mut self, arg0: i8) -> bool;
    fn i8_matches_non_zero(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_odd(&mut self, arg0: i8) -> bool;
    fn i8_matches_odd(&mut self, arg0: i8) -> Option<bool>;
    fn i8_is_even(&mut self, arg0: i8) -> bool;
    fn i8_matches_even(&mut self, arg0: i8) -> Option<bool>;
    fn i8_checked_ilog2(&mut self, arg0: i8) -> Option<u32>;
    fn i8_ilog2(&mut self, arg0: i8) -> u32;
    fn i8_trailing_zeros(&mut self, arg0: i8) -> u32;
    fn i8_trailing_ones(&mut self, arg0: i8) -> u32;
    fn i8_leading_zeros(&mut self, arg0: i8) -> u32;
    fn i8_leading_ones(&mut self, arg0: i8) -> u32;
    fn i8_checked_neg(&mut self, arg0: i8) -> Option<i8>;
    fn i8_wrapping_neg(&mut self, arg0: i8) -> i8;
    fn i8_neg(&mut self, arg0: i8) -> i8;
    fn u8_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_ne(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_lt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_gt_eq(&mut self, arg0: u8, arg1: u8) -> bool;
    fn u8_checked_add(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_add(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_sub(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_sub(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_mul(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_mul(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_div(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_wrapping_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_div(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_checked_rem(&mut self, arg0: u8, arg1: u8) -> Option<u8>;
    fn u8_rem(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_or(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_xor(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_not(&mut self, arg0: u8) -> u8;
    fn u8_checked_shl(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_checked_shr(&mut self, arg0: u8, arg1: u32) -> Option<u8>;
    fn u8_wrapping_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u32) -> u8;
    fn u8_is_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_non_zero(&mut self, arg0: u8) -> bool;
    fn u8_matches_non_zero(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_odd(&mut self, arg0: u8) -> bool;
    fn u8_matches_odd(&mut self, arg0: u8) -> Option<bool>;
    fn u8_is_even(&mut self, arg0: u8) -> bool;
    fn u8_matches_even(&mut self, arg0: u8) -> Option<bool>;
    fn u8_checked_ilog2(&mut self, arg0: u8) -> Option<u32>;
    fn u8_ilog2(&mut self, arg0: u8) -> u32;
    fn u8_trailing_zeros(&mut self, arg0: u8) -> u32;
    fn u8_trailing_ones(&mut self, arg0: u8) -> u32;
    fn u8_leading_zeros(&mut self, arg0: u8) -> u32;
    fn u8_leading_ones(&mut self, arg0: u8) -> u32;
    fn u8_is_power_of_two(&mut self, arg0: u8) -> bool;
    fn u8_matches_power_of_two(&mut self, arg0: u8) -> Option<bool>;
    fn i16_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_ne(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_lt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_gt_eq(&mut self, arg0: i16, arg1: i16) -> bool;
    fn i16_checked_add(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_add(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_sub(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_sub(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_mul(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_mul(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_div(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_wrapping_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_div(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_checked_rem(&mut self, arg0: i16, arg1: i16) -> Option<i16>;
    fn i16_rem(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_and(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_or(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_xor(&mut self, arg0: i16, arg1: i16) -> i16;
    fn i16_not(&mut self, arg0: i16) -> i16;
    fn i16_checked_shl(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shl(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_checked_shr(&mut self, arg0: i16, arg1: u32) -> Option<i16>;
    fn i16_wrapping_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_shr(&mut self, arg0: i16, arg1: u32) -> i16;
    fn i16_is_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_non_zero(&mut self, arg0: i16) -> bool;
    fn i16_matches_non_zero(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_odd(&mut self, arg0: i16) -> bool;
    fn i16_matches_odd(&mut self, arg0: i16) -> Option<bool>;
    fn i16_is_even(&mut self, arg0: i16) -> bool;
    fn i16_matches_even(&mut self, arg0: i16) -> Option<bool>;
    fn i16_checked_ilog2(&mut self, arg0: i16) -> Option<u32>;
    fn i16_ilog2(&mut self, arg0: i16) -> u32;
    fn i16_trailing_zeros(&mut self, arg0: i16) -> u32;
    fn i16_trailing_ones(&mut self, arg0: i16) -> u32;
    fn i16_leading_zeros(&mut self, arg0: i16) -> u32;
    fn i16_leading_ones(&mut self, arg0: i16) -> u32;
    fn i16_checked_neg(&mut self, arg0: i16) -> Option<i16>;
    fn i16_wrapping_neg(&mut self, arg0: i16) -> i16;
    fn i16_neg(&mut self, arg0: i16) -> i16;
    fn u16_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_ne(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_lt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_gt_eq(&mut self, arg0: u16, arg1: u16) -> bool;
    fn u16_checked_add(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_add(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_sub(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_sub(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_mul(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_mul(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_div(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_wrapping_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_div(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_checked_rem(&mut self, arg0: u16, arg1: u16) -> Option<u16>;
    fn u16_rem(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_and(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_or(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_xor(&mut self, arg0: u16, arg1: u16) -> u16;
    fn u16_not(&mut self, arg0: u16) -> u16;
    fn u16_checked_shl(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shl(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_checked_shr(&mut self, arg0: u16, arg1: u32) -> Option<u16>;
    fn u16_wrapping_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_shr(&mut self, arg0: u16, arg1: u32) -> u16;
    fn u16_is_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_non_zero(&mut self, arg0: u16) -> bool;
    fn u16_matches_non_zero(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_odd(&mut self, arg0: u16) -> bool;
    fn u16_matches_odd(&mut self, arg0: u16) -> Option<bool>;
    fn u16_is_even(&mut self, arg0: u16) -> bool;
    fn u16_matches_even(&mut self, arg0: u16) -> Option<bool>;
    fn u16_checked_ilog2(&mut self, arg0: u16) -> Option<u32>;
    fn u16_ilog2(&mut self, arg0: u16) -> u32;
    fn u16_trailing_zeros(&mut self, arg0: u16) -> u32;
    fn u16_trailing_ones(&mut self, arg0: u16) -> u32;
    fn u16_leading_zeros(&mut self, arg0: u16) -> u32;
    fn u16_leading_ones(&mut self, arg0: u16) -> u32;
    fn u16_is_power_of_two(&mut self, arg0: u16) -> bool;
    fn u16_matches_power_of_two(&mut self, arg0: u16) -> Option<bool>;
    fn i32_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_ne(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_lt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_gt_eq(&mut self, arg0: i32, arg1: i32) -> bool;
    fn i32_checked_add(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_add(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_sub(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_sub(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_mul(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_mul(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_div(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_wrapping_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_div(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_checked_rem(&mut self, arg0: i32, arg1: i32) -> Option<i32>;
    fn i32_rem(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_and(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_or(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_xor(&mut self, arg0: i32, arg1: i32) -> i32;
    fn i32_not(&mut self, arg0: i32) -> i32;
    fn i32_checked_shl(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shl(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_checked_shr(&mut self, arg0: i32, arg1: u32) -> Option<i32>;
    fn i32_wrapping_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_shr(&mut self, arg0: i32, arg1: u32) -> i32;
    fn i32_is_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_non_zero(&mut self, arg0: i32) -> bool;
    fn i32_matches_non_zero(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_odd(&mut self, arg0: i32) -> bool;
    fn i32_matches_odd(&mut self, arg0: i32) -> Option<bool>;
    fn i32_is_even(&mut self, arg0: i32) -> bool;
    fn i32_matches_even(&mut self, arg0: i32) -> Option<bool>;
    fn i32_checked_ilog2(&mut self, arg0: i32) -> Option<u32>;
    fn i32_ilog2(&mut self, arg0: i32) -> u32;
    fn i32_trailing_zeros(&mut self, arg0: i32) -> u32;
    fn i32_trailing_ones(&mut self, arg0: i32) -> u32;
    fn i32_leading_zeros(&mut self, arg0: i32) -> u32;
    fn i32_leading_ones(&mut self, arg0: i32) -> u32;
    fn i32_checked_neg(&mut self, arg0: i32) -> Option<i32>;
    fn i32_wrapping_neg(&mut self, arg0: i32) -> i32;
    fn i32_neg(&mut self, arg0: i32) -> i32;
    fn u32_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_ne(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_lt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_gt_eq(&mut self, arg0: u32, arg1: u32) -> bool;
    fn u32_checked_add(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_sub(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_mul(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_mul(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_div(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_div(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_rem(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_rem(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_or(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_xor(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_not(&mut self, arg0: u32) -> u32;
    fn u32_checked_shl(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shl(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_checked_shr(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_wrapping_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_shr(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_is_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_non_zero(&mut self, arg0: u32) -> bool;
    fn u32_matches_non_zero(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_odd(&mut self, arg0: u32) -> bool;
    fn u32_matches_odd(&mut self, arg0: u32) -> Option<bool>;
    fn u32_is_even(&mut self, arg0: u32) -> bool;
    fn u32_matches_even(&mut self, arg0: u32) -> Option<bool>;
    fn u32_checked_ilog2(&mut self, arg0: u32) -> Option<u32>;
    fn u32_ilog2(&mut self, arg0: u32) -> u32;
    fn u32_trailing_zeros(&mut self, arg0: u32) -> u32;
    fn u32_trailing_ones(&mut self, arg0: u32) -> u32;
    fn u32_leading_zeros(&mut self, arg0: u32) -> u32;
    fn u32_leading_ones(&mut self, arg0: u32) -> u32;
    fn u32_is_power_of_two(&mut self, arg0: u32) -> bool;
    fn u32_matches_power_of_two(&mut self, arg0: u32) -> Option<bool>;
    fn i64_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_ne(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_lt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_gt_eq(&mut self, arg0: i64, arg1: i64) -> bool;
    fn i64_checked_add(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_add(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_sub(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_sub(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_mul(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_mul(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_div(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_wrapping_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_div(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_checked_rem(&mut self, arg0: i64, arg1: i64) -> Option<i64>;
    fn i64_rem(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_and(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_or(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_xor(&mut self, arg0: i64, arg1: i64) -> i64;
    fn i64_not(&mut self, arg0: i64) -> i64;
    fn i64_checked_shl(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shl(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_checked_shr(&mut self, arg0: i64, arg1: u32) -> Option<i64>;
    fn i64_wrapping_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_shr(&mut self, arg0: i64, arg1: u32) -> i64;
    fn i64_is_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_non_zero(&mut self, arg0: i64) -> bool;
    fn i64_matches_non_zero(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_odd(&mut self, arg0: i64) -> bool;
    fn i64_matches_odd(&mut self, arg0: i64) -> Option<bool>;
    fn i64_is_even(&mut self, arg0: i64) -> bool;
    fn i64_matches_even(&mut self, arg0: i64) -> Option<bool>;
    fn i64_checked_ilog2(&mut self, arg0: i64) -> Option<u32>;
    fn i64_ilog2(&mut self, arg0: i64) -> u32;
    fn i64_trailing_zeros(&mut self, arg0: i64) -> u32;
    fn i64_trailing_ones(&mut self, arg0: i64) -> u32;
    fn i64_leading_zeros(&mut self, arg0: i64) -> u32;
    fn i64_leading_ones(&mut self, arg0: i64) -> u32;
    fn i64_checked_neg(&mut self, arg0: i64) -> Option<i64>;
    fn i64_wrapping_neg(&mut self, arg0: i64) -> i64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_ne(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_gt_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_checked_add(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_sub(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_mul(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_div(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_wrapping_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_div(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_checked_rem(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_rem(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_checked_shl(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_checked_shr(&mut self, arg0: u64, arg1: u32) -> Option<u64>;
    fn u64_wrapping_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_shr(&mut self, arg0: u64, arg1: u32) -> u64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_non_zero(&mut self, arg0: u64) -> bool;
    fn u64_matches_non_zero(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn u64_matches_odd(&mut self, arg0: u64) -> Option<bool>;
    fn u64_is_even(&mut self, arg0: u64) -> bool;
    fn u64_matches_even(&mut self, arg0: u64) -> Option<bool>;
    fn u64_checked_ilog2(&mut self, arg0: u64) -> Option<u32>;
    fn u64_ilog2(&mut self, arg0: u64) -> u32;
    fn u64_trailing_zeros(&mut self, arg0: u64) -> u32;
    fn u64_trailing_ones(&mut self, arg0: u64) -> u32;
    fn u64_leading_zeros(&mut self, arg0: u64) -> u32;
    fn u64_leading_ones(&mut self, arg0: u64) -> u32;
    fn u64_is_power_of_two(&mut self, arg0: u64) -> bool;
    fn u64_matches_power_of_two(&mut self, arg0: u64) -> Option<bool>;
    fn i128_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_ne(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_lt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_gt_eq(&mut self, arg0: i128, arg1: i128) -> bool;
    fn i128_checked_add(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_add(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_sub(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_sub(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_mul(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_mul(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_div(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_wrapping_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_div(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_checked_rem(&mut self, arg0: i128, arg1: i128) -> Option<i128>;
    fn i128_rem(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_and(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_or(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_xor(&mut self, arg0: i128, arg1: i128) -> i128;
    fn i128_not(&mut self, arg0: i128) -> i128;
    fn i128_checked_shl(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shl(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_checked_shr(&mut self, arg0: i128, arg1: u32) -> Option<i128>;
    fn i128_wrapping_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_shr(&mut self, arg0: i128, arg1: u32) -> i128;
    fn i128_is_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_non_zero(&mut self, arg0: i128) -> bool;
    fn i128_matches_non_zero(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_odd(&mut self, arg0: i128) -> bool;
    fn i128_matches_odd(&mut self, arg0: i128) -> Option<bool>;
    fn i128_is_even(&mut self, arg0: i128) -> bool;
    fn i128_matches_even(&mut self, arg0: i128) -> Option<bool>;
    fn i128_checked_ilog2(&mut self, arg0: i128) -> Option<u32>;
    fn i128_ilog2(&mut self, arg0: i128) -> u32;
    fn i128_trailing_zeros(&mut self, arg0: i128) -> u32;
    fn i128_trailing_ones(&mut self, arg0: i128) -> u32;
    fn i128_leading_zeros(&mut self, arg0: i128) -> u32;
    fn i128_leading_ones(&mut self, arg0: i128) -> u32;
    fn i128_checked_neg(&mut self, arg0: i128) -> Option<i128>;
    fn i128_wrapping_neg(&mut self, arg0: i128) -> i128;
    fn i128_neg(&mut self, arg0: i128) -> i128;
    fn u128_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_ne(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_lt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_gt_eq(&mut self, arg0: u128, arg1: u128) -> bool;
    fn u128_checked_add(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_add(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_sub(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_sub(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_mul(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_mul(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_div(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_wrapping_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_div(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_checked_rem(&mut self, arg0: u128, arg1: u128) -> Option<u128>;
    fn u128_rem(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_and(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_or(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_xor(&mut self, arg0: u128, arg1: u128) -> u128;
    fn u128_not(&mut self, arg0: u128) -> u128;
    fn u128_checked_shl(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shl(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_checked_shr(&mut self, arg0: u128, arg1: u32) -> Option<u128>;
    fn u128_wrapping_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_shr(&mut self, arg0: u128, arg1: u32) -> u128;
    fn u128_is_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_non_zero(&mut self, arg0: u128) -> bool;
    fn u128_matches_non_zero(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_odd(&mut self, arg0: u128) -> bool;
    fn u128_matches_odd(&mut self, arg0: u128) -> Option<bool>;
    fn u128_is_even(&mut self, arg0: u128) -> bool;
    fn u128_matches_even(&mut self, arg0: u128) -> Option<bool>;
    fn u128_checked_ilog2(&mut self, arg0: u128) -> Option<u32>;
    fn u128_ilog2(&mut self, arg0: u128) -> u32;
    fn u128_trailing_zeros(&mut self, arg0: u128) -> u32;
    fn u128_trailing_ones(&mut self, arg0: u128) -> u32;
    fn u128_leading_zeros(&mut self, arg0: u128) -> u32;
    fn u128_leading_ones(&mut self, arg0: u128) -> u32;
    fn u128_is_power_of_two(&mut self, arg0: u128) -> bool;
    fn u128_matches_power_of_two(&mut self, arg0: u128) -> Option<bool>;
    fn i8_try_into_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_unwrap_into_u8(&mut self, arg0: i8) -> u8;
    fn i8_cast_unsigned(&mut self, arg0: i8) -> u8;
    fn i8_from_u8(&mut self, arg0: i8) -> Option<u8>;
    fn i8_into_i16(&mut self, arg0: i8) -> i16;
    fn i8_from_i16(&mut self, arg0: i8) -> Option<i16>;
    fn i8_try_into_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_unwrap_into_u16(&mut self, arg0: i8) -> u16;
    fn i8_from_u16(&mut self, arg0: i8) -> Option<u16>;
    fn i8_into_i32(&mut self, arg0: i8) -> i32;
    fn i8_from_i32(&mut self, arg0: i8) -> Option<i32>;
    fn i8_try_into_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_unwrap_into_u32(&mut self, arg0: i8) -> u32;
    fn i8_from_u32(&mut self, arg0: i8) -> Option<u32>;
    fn i8_into_i64(&mut self, arg0: i8) -> i64;
    fn i8_from_i64(&mut self, arg0: i8) -> Option<i64>;
    fn i8_try_into_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_unwrap_into_u64(&mut self, arg0: i8) -> u64;
    fn i8_from_u64(&mut self, arg0: i8) -> Option<u64>;
    fn i8_into_i128(&mut self, arg0: i8) -> i128;
    fn i8_from_i128(&mut self, arg0: i8) -> Option<i128>;
    fn i8_try_into_u128(&mut self, arg0: i8) -> Option<u128>;
    fn i8_unwrap_into_u128(&mut self, arg0: i8) -> u128;
    fn i8_from_u128(&mut self, arg0: i8) -> Option<u128>;
    fn u8_try_into_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_unwrap_into_i8(&mut self, arg0: u8) -> i8;
    fn u8_cast_signed(&mut self, arg0: u8) -> i8;
    fn u8_from_i8(&mut self, arg0: u8) -> Option<i8>;
    fn u8_into_i16(&mut self, arg0: u8) -> i16;
    fn u8_from_i16(&mut self, arg0: u8) -> Option<i16>;
    fn u8_into_u16(&mut self, arg0: u8) -> u16;
    fn u8_from_u16(&mut self, arg0: u8) -> Option<u16>;
    fn u8_into_i32(&mut self, arg0: u8) -> i32;
    fn u8_from_i32(&mut self, arg0: u8) -> Option<i32>;
    fn u8_into_u32(&mut self, arg0: u8) -> u32;
    fn u8_from_u32(&mut self, arg0: u8) -> Option<u32>;
    fn u8_into_i64(&mut self, arg0: u8) -> i64;
    fn u8_from_i64(&mut self, arg0: u8) -> Option<i64>;
    fn u8_into_u64(&mut self, arg0: u8) -> u64;
    fn u8_from_u64(&mut self, arg0: u8) -> Option<u64>;
    fn u8_into_i128(&mut self, arg0: u8) -> i128;
    fn u8_from_i128(&mut self, arg0: u8) -> Option<i128>;
    fn u8_into_u128(&mut self, arg0: u8) -> u128;
    fn u8_from_u128(&mut self, arg0: u8) -> Option<u128>;
    fn i16_try_into_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_unwrap_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_truncate_into_i8(&mut self, arg0: i16) -> i8;
    fn i16_from_i8(&mut self, arg0: i16) -> Option<i8>;
    fn i16_try_into_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_unwrap_into_u8(&mut self, arg0: i16) -> u8;
    fn i16_from_u8(&mut self, arg0: i16) -> Option<u8>;
    fn i16_try_into_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_unwrap_into_u16(&mut self, arg0: i16) -> u16;
    fn i16_cast_unsigned(&mut self, arg0: i16) -> u16;
    fn i16_from_u16(&mut self, arg0: i16) -> Option<u16>;
    fn i16_into_i32(&mut self, arg0: i16) -> i32;
    fn i16_from_i32(&mut self, arg0: i16) -> Option<i32>;
    fn i16_try_into_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_unwrap_into_u32(&mut self, arg0: i16) -> u32;
    fn i16_from_u32(&mut self, arg0: i16) -> Option<u32>;
    fn i16_into_i64(&mut self, arg0: i16) -> i64;
    fn i16_from_i64(&mut self, arg0: i16) -> Option<i64>;
    fn i16_try_into_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_unwrap_into_u64(&mut self, arg0: i16) -> u64;
    fn i16_from_u64(&mut self, arg0: i16) -> Option<u64>;
    fn i16_into_i128(&mut self, arg0: i16) -> i128;
    fn i16_from_i128(&mut self, arg0: i16) -> Option<i128>;
    fn i16_try_into_u128(&mut self, arg0: i16) -> Option<u128>;
    fn i16_unwrap_into_u128(&mut self, arg0: i16) -> u128;
    fn i16_from_u128(&mut self, arg0: i16) -> Option<u128>;
    fn u16_try_into_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_unwrap_into_i8(&mut self, arg0: u16) -> i8;
    fn u16_from_i8(&mut self, arg0: u16) -> Option<i8>;
    fn u16_try_into_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_unwrap_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_truncate_into_u8(&mut self, arg0: u16) -> u8;
    fn u16_from_u8(&mut self, arg0: u16) -> Option<u8>;
    fn u16_try_into_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_unwrap_into_i16(&mut self, arg0: u16) -> i16;
    fn u16_cast_signed(&mut self, arg0: u16) -> i16;
    fn u16_from_i16(&mut self, arg0: u16) -> Option<i16>;
    fn u16_into_i32(&mut self, arg0: u16) -> i32;
    fn u16_from_i32(&mut self, arg0: u16) -> Option<i32>;
    fn u16_into_u32(&mut self, arg0: u16) -> u32;
    fn u16_from_u32(&mut self, arg0: u16) -> Option<u32>;
    fn u16_into_i64(&mut self, arg0: u16) -> i64;
    fn u16_from_i64(&mut self, arg0: u16) -> Option<i64>;
    fn u16_into_u64(&mut self, arg0: u16) -> u64;
    fn u16_from_u64(&mut self, arg0: u16) -> Option<u64>;
    fn u16_into_i128(&mut self, arg0: u16) -> i128;
    fn u16_from_i128(&mut self, arg0: u16) -> Option<i128>;
    fn u16_into_u128(&mut self, arg0: u16) -> u128;
    fn u16_from_u128(&mut self, arg0: u16) -> Option<u128>;
    fn i32_try_into_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_unwrap_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_truncate_into_i8(&mut self, arg0: i32) -> i8;
    fn i32_from_i8(&mut self, arg0: i32) -> Option<i8>;
    fn i32_try_into_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_unwrap_into_u8(&mut self, arg0: i32) -> u8;
    fn i32_from_u8(&mut self, arg0: i32) -> Option<u8>;
    fn i32_try_into_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_unwrap_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_truncate_into_i16(&mut self, arg0: i32) -> i16;
    fn i32_from_i16(&mut self, arg0: i32) -> Option<i16>;
    fn i32_try_into_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_unwrap_into_u16(&mut self, arg0: i32) -> u16;
    fn i32_from_u16(&mut self, arg0: i32) -> Option<u16>;
    fn i32_try_into_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_unwrap_into_u32(&mut self, arg0: i32) -> u32;
    fn i32_cast_unsigned(&mut self, arg0: i32) -> u32;
    fn i32_from_u32(&mut self, arg0: i32) -> Option<u32>;
    fn i32_into_i64(&mut self, arg0: i32) -> i64;
    fn i32_from_i64(&mut self, arg0: i32) -> Option<i64>;
    fn i32_try_into_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_unwrap_into_u64(&mut self, arg0: i32) -> u64;
    fn i32_from_u64(&mut self, arg0: i32) -> Option<u64>;
    fn i32_into_i128(&mut self, arg0: i32) -> i128;
    fn i32_from_i128(&mut self, arg0: i32) -> Option<i128>;
    fn i32_try_into_u128(&mut self, arg0: i32) -> Option<u128>;
    fn i32_unwrap_into_u128(&mut self, arg0: i32) -> u128;
    fn i32_from_u128(&mut self, arg0: i32) -> Option<u128>;
    fn u32_try_into_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_unwrap_into_i8(&mut self, arg0: u32) -> i8;
    fn u32_from_i8(&mut self, arg0: u32) -> Option<i8>;
    fn u32_try_into_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_unwrap_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_truncate_into_u8(&mut self, arg0: u32) -> u8;
    fn u32_from_u8(&mut self, arg0: u32) -> Option<u8>;
    fn u32_try_into_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_unwrap_into_i16(&mut self, arg0: u32) -> i16;
    fn u32_from_i16(&mut self, arg0: u32) -> Option<i16>;
    fn u32_try_into_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_unwrap_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_truncate_into_u16(&mut self, arg0: u32) -> u16;
    fn u32_from_u16(&mut self, arg0: u32) -> Option<u16>;
    fn u32_try_into_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_unwrap_into_i32(&mut self, arg0: u32) -> i32;
    fn u32_cast_signed(&mut self, arg0: u32) -> i32;
    fn u32_from_i32(&mut self, arg0: u32) -> Option<i32>;
    fn u32_into_i64(&mut self, arg0: u32) -> i64;
    fn u32_from_i64(&mut self, arg0: u32) -> Option<i64>;
    fn u32_into_u64(&mut self, arg0: u32) -> u64;
    fn u32_from_u64(&mut self, arg0: u32) -> Option<u64>;
    fn u32_into_i128(&mut self, arg0: u32) -> i128;
    fn u32_from_i128(&mut self, arg0: u32) -> Option<i128>;
    fn u32_into_u128(&mut self, arg0: u32) -> u128;
    fn u32_from_u128(&mut self, arg0: u32) -> Option<u128>;
    fn i64_try_into_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_unwrap_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_truncate_into_i8(&mut self, arg0: i64) -> i8;
    fn i64_from_i8(&mut self, arg0: i64) -> Option<i8>;
    fn i64_try_into_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_unwrap_into_u8(&mut self, arg0: i64) -> u8;
    fn i64_from_u8(&mut self, arg0: i64) -> Option<u8>;
    fn i64_try_into_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_unwrap_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_truncate_into_i16(&mut self, arg0: i64) -> i16;
    fn i64_from_i16(&mut self, arg0: i64) -> Option<i16>;
    fn i64_try_into_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_unwrap_into_u16(&mut self, arg0: i64) -> u16;
    fn i64_from_u16(&mut self, arg0: i64) -> Option<u16>;
    fn i64_try_into_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_unwrap_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_truncate_into_i32(&mut self, arg0: i64) -> i32;
    fn i64_from_i32(&mut self, arg0: i64) -> Option<i32>;
    fn i64_try_into_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_unwrap_into_u32(&mut self, arg0: i64) -> u32;
    fn i64_from_u32(&mut self, arg0: i64) -> Option<u32>;
    fn i64_try_into_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_unwrap_into_u64(&mut self, arg0: i64) -> u64;
    fn i64_cast_unsigned(&mut self, arg0: i64) -> u64;
    fn i64_from_u64(&mut self, arg0: i64) -> Option<u64>;
    fn i64_into_i128(&mut self, arg0: i64) -> i128;
    fn i64_from_i128(&mut self, arg0: i64) -> Option<i128>;
    fn i64_try_into_u128(&mut self, arg0: i64) -> Option<u128>;
    fn i64_unwrap_into_u128(&mut self, arg0: i64) -> u128;
    fn i64_from_u128(&mut self, arg0: i64) -> Option<u128>;
    fn u64_try_into_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_unwrap_into_i8(&mut self, arg0: u64) -> i8;
    fn u64_from_i8(&mut self, arg0: u64) -> Option<i8>;
    fn u64_try_into_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_unwrap_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_truncate_into_u8(&mut self, arg0: u64) -> u8;
    fn u64_from_u8(&mut self, arg0: u64) -> Option<u8>;
    fn u64_try_into_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_unwrap_into_i16(&mut self, arg0: u64) -> i16;
    fn u64_from_i16(&mut self, arg0: u64) -> Option<i16>;
    fn u64_try_into_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_unwrap_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_truncate_into_u16(&mut self, arg0: u64) -> u16;
    fn u64_from_u16(&mut self, arg0: u64) -> Option<u16>;
    fn u64_try_into_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_unwrap_into_i32(&mut self, arg0: u64) -> i32;
    fn u64_from_i32(&mut self, arg0: u64) -> Option<i32>;
    fn u64_try_into_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_unwrap_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_truncate_into_u32(&mut self, arg0: u64) -> u32;
    fn u64_from_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_try_into_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_unwrap_into_i64(&mut self, arg0: u64) -> i64;
    fn u64_cast_signed(&mut self, arg0: u64) -> i64;
    fn u64_from_i64(&mut self, arg0: u64) -> Option<i64>;
    fn u64_into_i128(&mut self, arg0: u64) -> i128;
    fn u64_from_i128(&mut self, arg0: u64) -> Option<i128>;
    fn u64_into_u128(&mut self, arg0: u64) -> u128;
    fn u64_from_u128(&mut self, arg0: u64) -> Option<u128>;
    fn i128_try_into_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_unwrap_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_truncate_into_i8(&mut self, arg0: i128) -> i8;
    fn i128_from_i8(&mut self, arg0: i128) -> Option<i8>;
    fn i128_try_into_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_unwrap_into_u8(&mut self, arg0: i128) -> u8;
    fn i128_from_u8(&mut self, arg0: i128) -> Option<u8>;
    fn i128_try_into_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_unwrap_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_truncate_into_i16(&mut self, arg0: i128) -> i16;
    fn i128_from_i16(&mut self, arg0: i128) -> Option<i16>;
    fn i128_try_into_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_unwrap_into_u16(&mut self, arg0: i128) -> u16;
    fn i128_from_u16(&mut self, arg0: i128) -> Option<u16>;
    fn i128_try_into_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_unwrap_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_truncate_into_i32(&mut self, arg0: i128) -> i32;
    fn i128_from_i32(&mut self, arg0: i128) -> Option<i32>;
    fn i128_try_into_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_unwrap_into_u32(&mut self, arg0: i128) -> u32;
    fn i128_from_u32(&mut self, arg0: i128) -> Option<u32>;
    fn i128_try_into_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_unwrap_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_truncate_into_i64(&mut self, arg0: i128) -> i64;
    fn i128_from_i64(&mut self, arg0: i128) -> Option<i64>;
    fn i128_try_into_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_unwrap_into_u64(&mut self, arg0: i128) -> u64;
    fn i128_from_u64(&mut self, arg0: i128) -> Option<u64>;
    fn i128_try_into_u128(&mut self, arg0: i128) -> Option<u128>;
    fn i128_unwrap_into_u128(&mut self, arg0: i128) -> u128;
    fn i128_cast_unsigned(&mut self, arg0: i128) -> u128;
    fn i128_from_u128(&mut self, arg0: i128) -> Option<u128>;
    fn u128_try_into_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_unwrap_into_i8(&mut self, arg0: u128) -> i8;
    fn u128_from_i8(&mut self, arg0: u128) -> Option<i8>;
    fn u128_try_into_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_unwrap_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_truncate_into_u8(&mut self, arg0: u128) -> u8;
    fn u128_from_u8(&mut self, arg0: u128) -> Option<u8>;
    fn u128_try_into_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_unwrap_into_i16(&mut self, arg0: u128) -> i16;
    fn u128_from_i16(&mut self, arg0: u128) -> Option<i16>;
    fn u128_try_into_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_unwrap_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_truncate_into_u16(&mut self, arg0: u128) -> u16;
    fn u128_from_u16(&mut self, arg0: u128) -> Option<u16>;
    fn u128_try_into_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_unwrap_into_i32(&mut self, arg0: u128) -> i32;
    fn u128_from_i32(&mut self, arg0: u128) -> Option<i32>;
    fn u128_try_into_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_unwrap_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_truncate_into_u32(&mut self, arg0: u128) -> u32;
    fn u128_from_u32(&mut self, arg0: u128) -> Option<u32>;
    fn u128_try_into_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_unwrap_into_i64(&mut self, arg0: u128) -> i64;
    fn u128_from_i64(&mut self, arg0: u128) -> Option<i64>;
    fn u128_try_into_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_unwrap_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_truncate_into_u64(&mut self, arg0: u128) -> u64;
    fn u128_from_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u128_try_into_i128(&mut self, arg0: u128) -> Option<i128>;
    fn u128_unwrap_into_i128(&mut self, arg0: u128) -> i128;
    fn u128_cast_signed(&mut self, arg0: u128) -> i128;
    fn u128_from_i128(&mut self, arg0: u128) -> Option<i128>;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
    fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }
}

pub trait IntoContextIter {
    type Context;
    type Output;
    type IntoIter: ContextIter<Context = Self::Context, Output = Self::Output>;
    fn into_context_iter(self) -> Self::IntoIter;
}

pub trait Length {
    fn len(&self) -> usize;
}

impl<T> Length for std::vec::Vec<T> {
    fn len(&self) -> usize {
        std::vec::Vec::len(self)
    }
}

pub struct ContextIterWrapper<I, C> {
    iter: I,
    _ctx: std::marker::PhantomData<C>,
}
impl<I: Default, C> Default for ContextIterWrapper<I, C> {
    fn default() -> Self {
        ContextIterWrapper {
            iter: I::default(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<I, C> std::ops::Deref for ContextIterWrapper<I, C> {
    type Target = I;
    fn deref(&self) -> &I {
        &self.iter
    }
}
impl<I, C> std::ops::DerefMut for ContextIterWrapper<I, C> {
    fn deref_mut(&mut self) -> &mut I {
        &mut self.iter
    }
}
impl<I: Iterator, C: Context> From<I> for ContextIterWrapper<I, C> {
    fn from(iter: I) -> Self {
        Self { iter, _ctx: std::marker::PhantomData }
    }
}
impl<I: Iterator, C: Context> ContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}
impl<I: IntoIterator, C: Context> IntoContextIter for ContextIterWrapper<I, C> {
    type Context = C;
    type Output = I::Item;
    type IntoIter = ContextIterWrapper<I::IntoIter, C>;
    fn into_context_iter(self) -> Self::IntoIter {
        ContextIterWrapper {
            iter: self.iter.into_iter(),
            _ctx: std::marker::PhantomData
        }
    }
}
impl<T, E: Extend<T>, C> Extend<T> for ContextIterWrapper<E, C> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        self.iter.extend(iter);
    }
}
impl<L: Length, C> Length for ContextIterWrapper<L, C> {
    fn len(&self) -> usize {
        self.iter.len()
    }
}
           

/// Internal type MultiReg: defined at src\prelude_lower.isle line 16.
#[derive(Clone, Debug)]
pub enum MultiReg {
    Empty,
    One {
        a: Reg,
    },
    Two {
        a: Reg,
        b: Reg,
    },
    Three {
        a: Reg,
        b: Reg,
        c: Reg,
    },
    Four {
        a: Reg,
        b: Reg,
        c: Reg,
        d: Reg,
    },
}

/// Internal type SideEffectNoResult: defined at src\prelude_lower.isle line 439.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst {
        inst: MInst,
    },
    Inst2 {
        inst1: MInst,
        inst2: MInst,
    },
    Inst3 {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
    },
}

/// Internal type ProducesFlags: defined at src\prelude_lower.isle line 492.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    AlreadyExistingFlags,
    ProducesFlagsSideEffect {
        inst: MInst,
    },
    ProducesFlagsTwiceSideEffect {
        inst1: MInst,
        inst2: MInst,
    },
    ProducesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ProducesFlagsReturnsResultWithConsumer {
        inst: MInst,
        result: Reg,
    },
}

/// Internal type ConsumesAndProducesFlags: defined at src\prelude_lower.isle line 511.
#[derive(Clone, Debug)]
pub enum ConsumesAndProducesFlags {
    SideEffect {
        inst: MInst,
    },
    ReturnsReg {
        inst: MInst,
        result: Reg,
    },
}

/// Internal type ConsumesFlags: defined at src\prelude_lower.isle line 519.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsSideEffect {
        inst: MInst,
    },
    ConsumesFlagsSideEffect2 {
        inst1: MInst,
        inst2: MInst,
    },
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src\isa\pulley_shared\inst.isle line 10.
#[derive(Clone, Debug)]
pub enum MInst {
    Args {
        args: VecArgPair,
    },
    Rets {
        rets: VecRetPair,
    },
    DummyUse {
        reg: Reg,
    },
    BrTable {
        idx: XReg,
        default: MachLabel,
        targets: BoxVecMachLabel,
    },
    TrapIf {
        cond: Cond,
        code: TrapCode,
    },
    Nop,
    GetSpecial {
        dst: WritableXReg,
        reg: XReg,
    },
    LoadExtNameNear {
        dst: WritableXReg,
        name: BoxExternalName,
        offset: i64,
    },
    LoadExtNameFar {
        dst: WritableXReg,
        name: BoxExternalName,
        offset: i64,
    },
    Call {
        info: BoxCallInfo,
    },
    IndirectCall {
        info: BoxCallIndInfo,
    },
    PatchableCall {
        info: BoxCallInfo,
    },
    ReturnCall {
        info: BoxReturnCallInfo,
    },
    ReturnIndirectCall {
        info: BoxReturnCallIndInfo,
    },
    IndirectCallHost {
        info: BoxCallIndirectHostInfo,
    },
    Jump {
        label: MachLabel,
    },
    BrIf {
        cond: Cond,
        taken: MachLabel,
        not_taken: MachLabel,
    },
    LoadAddr {
        dst: WritableXReg,
        mem: Amode,
    },
    XLoad {
        dst: WritableXReg,
        mem: Amode,
        ty: Type,
        flags: MemFlags,
    },
    FLoad {
        dst: WritableFReg,
        mem: Amode,
        ty: Type,
        flags: MemFlags,
    },
    VLoad {
        dst: WritableVReg,
        mem: Amode,
        ty: Type,
        flags: MemFlags,
    },
    XStore {
        mem: Amode,
        src: XReg,
        ty: Type,
        flags: MemFlags,
    },
    FStore {
        mem: Amode,
        src: FReg,
        ty: Type,
        flags: MemFlags,
    },
    VStore {
        mem: Amode,
        src: VReg,
        ty: Type,
        flags: MemFlags,
    },
    Raw {
        raw: RawInst,
    },
    EmitIsland {
        space_needed: u32,
    },
    LabelAddress {
        dst: WritableXReg,
        label: MachLabel,
    },
    SequencePoint,
}

/// Internal type Cond: defined at src\isa\pulley_shared\inst.isle line 110.
#[derive(Clone, Debug)]
pub enum Cond {
    If32 {
        reg: XReg,
    },
    IfNot32 {
        reg: XReg,
    },
    IfXeq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXneq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXslt32 {
        src1: XReg,
        src2: XReg,
    },
    IfXslteq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXult32 {
        src1: XReg,
        src2: XReg,
    },
    IfXulteq32 {
        src1: XReg,
        src2: XReg,
    },
    IfXeq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXneq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslt32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslteq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXult32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXulteq32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXsgt32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXsgteq32I32 {
        src1: XReg,
        src2: i32,
    },
    IfXugt32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXugteq32I32 {
        src1: XReg,
        src2: u32,
    },
    IfXeq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXneq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXslt64 {
        src1: XReg,
        src2: XReg,
    },
    IfXslteq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXult64 {
        src1: XReg,
        src2: XReg,
    },
    IfXulteq64 {
        src1: XReg,
        src2: XReg,
    },
    IfXeq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXneq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslt64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXslteq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXult64I32 {
        src1: XReg,
        src2: u32,
    },
    IfXulteq64I32 {
        src1: XReg,
        src2: u32,
    },
    IfXsgt64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXsgteq64I32 {
        src1: XReg,
        src2: i32,
    },
    IfXugt64I32 {
        src1: XReg,
        src2: u32,
    },
    IfXugteq64I32 {
        src1: XReg,
        src2: u32,
    },
}

/// Internal type ExtKind: defined at src\isa\pulley_shared\inst.isle line 175.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ExtKind {
    None,
    Sign32,
    Sign64,
    Zero32,
    Zero64,
}

/// Internal type VExtKind: defined at src\isa\pulley_shared\inst.isle line 176.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum VExtKind {
    None,
    S8x8,
    U8x8,
    S16x4,
    U16x4,
    S32x2,
    U32x2,
}

/// Internal type ValueOffset: defined at src\isa\pulley_shared\inst.isle line 184.
#[derive(Clone, Debug)]
pub enum ValueOffset {
    Both {
        value: Value,
        offset: i32,
    },
}

/// Internal type Amode: defined at src\isa\pulley_shared\inst.isle line 193.
#[derive(Clone, Debug)]
pub enum Amode {
    SpOffset {
        offset: i32,
    },
    RegOffset {
        base: XReg,
        offset: i32,
    },
    Stack {
        amode: StackAMode,
    },
}

/// Internal type AddrO32: defined at src\isa\pulley_shared\inst.isle line 207.
#[derive(Clone, Debug)]
pub enum AddrO32 {
    Base {
        addr: XReg,
        offset: i32,
    },
}

/// Internal type AddrZ: defined at src\isa\pulley_shared\inst.isle line 220.
#[derive(Clone, Debug)]
pub enum AddrZ {
    Base {
        addr: XReg,
        offset: i32,
    },
}

/// Internal type AddrG32: defined at src\isa\pulley_shared\inst.isle line 233.
#[derive(Clone, Debug)]
pub enum AddrG32 {
    RegisterBound {
        host_heap_base: XReg,
        host_heap_bound: XReg,
        wasm_addr: XReg,
        offset: u16,
    },
}

/// Internal type AddrG32Bne: defined at src\isa\pulley_shared\inst.isle line 242.
#[derive(Clone, Debug)]
pub enum AddrG32Bne {
    BoundNe {
        host_heap_base: XReg,
        host_heap_bound_addr: XReg,
        host_heap_bound_offset: u8,
        wasm_addr: XReg,
        offset: u8,
    },
}

/// Internal type SinkableLoad: defined at src\isa\pulley_shared\inst.isle line 272.
#[derive(Clone, Debug)]
pub enum SinkableLoad {
    Load {
        inst: Inst,
        ty: Type,
        addr: Value,
        offset: u8,
    },
}

/// Internal type SunkLoad: defined at src\isa\pulley_shared\inst.isle line 287.
#[derive(Clone, Debug)]
pub enum SunkLoad {
    Load {
        ty: Type,
        addr: Value,
        offset: u8,
    },
}

/// Internal type G32: defined at src\isa\pulley_shared\inst.isle line 307.
#[derive(Clone, Debug)]
pub enum G32 {
    All {
        heap_base: Value,
        heap_bound: Value,
        wasm_addr: Value,
        offset: u16,
    },
}

/// Internal type G32Bne: defined at src\isa\pulley_shared\inst.isle line 316.
#[derive(Clone, Debug)]
pub enum G32Bne {
    All {
        heap_base: Value,
        heap_bound: SinkableLoad,
        wasm_addr: Value,
        offset: u8,
    },
}

/// Internal type HostOffset: defined at src\isa\pulley_shared\inst.isle line 384.
#[derive(Clone, Debug)]
pub enum HostOffset {
    All {
        a: Value,
        b: i32,
    },
}

/// Internal type OobSelect: defined at src\isa\pulley_shared\inst.isle line 393.
#[derive(Clone, Debug)]
pub enum OobSelect {
    All {
        a: Value,
        b: Value,
        c: Value,
        d: u64,
    },
}

/// Internal type OobCond: defined at src\isa\pulley_shared\inst.isle line 431.
#[derive(Clone, Debug)]
pub enum OobCond {
    All {
        a: Value,
        b: u64,
    },
}

/// Internal type RawInst: defined at <OUT_DIR>\pulley_gen.isle line 0.
#[derive(Clone, Debug)]
pub enum RawInst {
    Nop,
    Ret,
    XJump {
        reg: XReg,
    },
    Xmov {
        dst: WritableXReg,
        src: XReg,
    },
    Xzero {
        dst: WritableXReg,
    },
    Xone {
        dst: WritableXReg,
    },
    Xconst8 {
        dst: WritableXReg,
        imm: i8,
    },
    Xconst16 {
        dst: WritableXReg,
        imm: i16,
    },
    Xconst32 {
        dst: WritableXReg,
        imm: i32,
    },
    Xconst64 {
        dst: WritableXReg,
        imm: i64,
    },
    Xadd32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xadd32U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xadd32U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    Xadd64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xadd64U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xadd64U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    Xmadd32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        src3: XReg,
    },
    Xmadd64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        src3: XReg,
    },
    Xsub32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xsub32U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xsub32U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    Xsub64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xsub64U8 {
        dst: WritableXReg,
        src1: XReg,
        src2: u8,
    },
    Xsub64U32 {
        dst: WritableXReg,
        src1: XReg,
        src2: u32,
    },
    XMul32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmul32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xmul32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XMul64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmul64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xmul64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    Xctz32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xctz64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xclz32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xclz64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xpopcnt32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xpopcnt64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xrotl32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xrotl64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xrotr32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xrotr64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshl32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshl64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshr64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xshl32U6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr32SU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr32UU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshl64U6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr64SU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xshr64UU6 {
        dst: WritableXReg,
        src1: XReg,
        src2: U6,
    },
    Xneg32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xneg64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xeq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xneq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslt64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslteq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xult64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xulteq64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xeq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xneq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslt32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xslteq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xult32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xulteq32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XLoad8U32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad8S32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad16LeU32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad16LeS32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad32LeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad64LeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XStore8O32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore16LeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore32LeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore64LeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XLoad8U32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad8S32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad16LeU32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad16LeS32Z {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad32LeZ {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XLoad64LeZ {
        dst: WritableXReg,
        addr: AddrZ,
    },
    XStore8Z {
        addr: AddrZ,
        src: XReg,
    },
    XStore16LeZ {
        addr: AddrZ,
        src: XReg,
    },
    XStore32LeZ {
        addr: AddrZ,
        src: XReg,
    },
    XStore64LeZ {
        addr: AddrZ,
        src: XReg,
    },
    XLoad8U32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad8S32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad16LeU32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad16LeS32G32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad32LeG32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XLoad64LeG32 {
        dst: WritableXReg,
        addr: AddrG32,
    },
    XStore8G32 {
        addr: AddrG32,
        src: XReg,
    },
    XStore16LeG32 {
        addr: AddrG32,
        src: XReg,
    },
    XStore32LeG32 {
        addr: AddrG32,
        src: XReg,
    },
    XStore64LeG32 {
        addr: AddrG32,
        src: XReg,
    },
    XLoad8U32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad8S32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad16LeU32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad16LeS32G32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad32LeG32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XLoad64LeG32Bne {
        dst: WritableXReg,
        addr: AddrG32Bne,
    },
    XStore8G32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    XStore16LeG32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    XStore32LeG32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    XStore64LeG32Bne {
        addr: AddrG32Bne,
        src: XReg,
    },
    PushFrame,
    PopFrame,
    PushFrameSave {
        amt: u16,
        regs: UpperXRegSet,
    },
    PopFrameRestore {
        amt: u16,
        regs: UpperXRegSet,
    },
    StackAlloc32 {
        amt: u32,
    },
    StackFree32 {
        amt: u32,
    },
    Zext8 {
        dst: WritableXReg,
        src: XReg,
    },
    Zext16 {
        dst: WritableXReg,
        src: XReg,
    },
    Zext32 {
        dst: WritableXReg,
        src: XReg,
    },
    Sext8 {
        dst: WritableXReg,
        src: XReg,
    },
    Sext16 {
        dst: WritableXReg,
        src: XReg,
    },
    Sext32 {
        dst: WritableXReg,
        src: XReg,
    },
    XAbs32 {
        dst: WritableXReg,
        src: XReg,
    },
    XAbs64 {
        dst: WritableXReg,
        src: XReg,
    },
    XDiv32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XDiv64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XDiv32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XDiv64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XRem64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XBand32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xband32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xband32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBand64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xband64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xband64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBor32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbor32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbor32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBor64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbor64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbor64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBxor32 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbxor32S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbxor32S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBxor64 {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbxor64S8 {
        dst: WritableXReg,
        src1: XReg,
        src2: i8,
    },
    Xbxor64S32 {
        dst: WritableXReg,
        src1: XReg,
        src2: i32,
    },
    XBnot32 {
        dst: WritableXReg,
        src: XReg,
    },
    XBnot64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xmin32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmin32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax32U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax32S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmin64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmin64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xmax64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XSelect32 {
        dst: WritableXReg,
        cond: XReg,
        if_nonzero: XReg,
        if_zero: XReg,
    },
    XSelect64 {
        dst: WritableXReg,
        cond: XReg,
        if_nonzero: XReg,
        if_zero: XReg,
    },
    Trap {
        code: TrapCode,
    },
    Xpcadd {
        dst: WritableXReg,
        offset: PcRelOffset,
    },
    XmovFp {
        dst: WritableXReg,
    },
    XmovLr {
        dst: WritableXReg,
    },
    Bswap32 {
        dst: WritableXReg,
        src: XReg,
    },
    Bswap64 {
        dst: WritableXReg,
        src: XReg,
    },
    Xadd32UoverflowTrap {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        code: TrapCode,
    },
    Xadd64UoverflowTrap {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
        code: TrapCode,
    },
    XMulHi64S {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    XMulHi64U {
        dst: WritableXReg,
        src1: XReg,
        src2: XReg,
    },
    Xbmask32 {
        dst: WritableXReg,
        src: XReg,
    },
    Xbmask64 {
        dst: WritableXReg,
        src: XReg,
    },
    XLoad16BeU32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad16BeS32O32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad32BeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XLoad64BeO32 {
        dst: WritableXReg,
        addr: AddrO32,
    },
    XStore16BeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore32BeO32 {
        addr: AddrO32,
        src: XReg,
    },
    XStore64BeO32 {
        addr: AddrO32,
        src: XReg,
    },
    Fload32BeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fload64BeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fstore32BeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fstore64BeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fload32LeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fload64LeO32 {
        dst: WritableFReg,
        addr: AddrO32,
    },
    Fstore32LeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fstore64LeO32 {
        addr: AddrO32,
        src: FReg,
    },
    Fload32LeZ {
        dst: WritableFReg,
        addr: AddrZ,
    },
    Fload64LeZ {
        dst: WritableFReg,
        addr: AddrZ,
    },
    Fstore32LeZ {
        addr: AddrZ,
        src: FReg,
    },
    Fstore64LeZ {
        addr: AddrZ,
        src: FReg,
    },
    Fload32LeG32 {
        dst: WritableFReg,
        addr: AddrG32,
    },
    Fload64LeG32 {
        dst: WritableFReg,
        addr: AddrG32,
    },
    Fstore32LeG32 {
        addr: AddrG32,
        src: FReg,
    },
    Fstore64LeG32 {
        addr: AddrG32,
        src: FReg,
    },
    VLoad128O32 {
        dst: WritableVReg,
        addr: AddrO32,
    },
    Vstore128LeO32 {
        addr: AddrO32,
        src: VReg,
    },
    VLoad128Z {
        dst: WritableVReg,
        addr: AddrZ,
    },
    Vstore128LeZ {
        addr: AddrZ,
        src: VReg,
    },
    VLoad128G32 {
        dst: WritableVReg,
        addr: AddrG32,
    },
    Vstore128LeG32 {
        addr: AddrG32,
        src: VReg,
    },
    Fmov {
        dst: WritableFReg,
        src: FReg,
    },
    Vmov {
        dst: WritableVReg,
        src: VReg,
    },
    BitcastIntFromFloat32 {
        dst: WritableXReg,
        src: FReg,
    },
    BitcastIntFromFloat64 {
        dst: WritableXReg,
        src: FReg,
    },
    BitcastFloatFromInt32 {
        dst: WritableFReg,
        src: XReg,
    },
    BitcastFloatFromInt64 {
        dst: WritableFReg,
        src: XReg,
    },
    FConst32 {
        dst: WritableFReg,
        bits: u32,
    },
    FConst64 {
        dst: WritableFReg,
        bits: u64,
    },
    Feq32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Fneq32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flt32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flteq32 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Feq64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Fneq64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flt64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    Flteq64 {
        dst: WritableXReg,
        src1: FReg,
        src2: FReg,
    },
    FSelect32 {
        dst: WritableFReg,
        cond: XReg,
        if_nonzero: FReg,
        if_zero: FReg,
    },
    FSelect64 {
        dst: WritableFReg,
        cond: XReg,
        if_nonzero: FReg,
        if_zero: FReg,
    },
    F32FromF64 {
        dst: WritableFReg,
        src: FReg,
    },
    F64FromF32 {
        dst: WritableFReg,
        src: FReg,
    },
    F32FromX32S {
        dst: WritableFReg,
        src: XReg,
    },
    F32FromX32U {
        dst: WritableFReg,
        src: XReg,
    },
    F32FromX64S {
        dst: WritableFReg,
        src: XReg,
    },
    F32FromX64U {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX32S {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX32U {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX64S {
        dst: WritableFReg,
        src: XReg,
    },
    F64FromX64U {
        dst: WritableFReg,
        src: XReg,
    },
    X32FromF32S {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF32U {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64S {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64U {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32S {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32U {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64S {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64U {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF32SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF32USat {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X32FromF64USat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF32USat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64SSat {
        dst: WritableXReg,
        src: FReg,
    },
    X64FromF64USat {
        dst: WritableXReg,
        src: FReg,
    },
    FCopySign32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    FCopySign64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fadd32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fsub32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Vsubf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fmul32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Vmulf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fdiv32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Vdivf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fmaximum32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fminimum32 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Ftrunc32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vtrunc32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vtrunc64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Ffloor32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vfloor32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vfloor64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fceil32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vceil32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vceil64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fnearest32 {
        dst: WritableFReg,
        src: FReg,
    },
    Fsqrt32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vsqrt32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vsqrt64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fneg32 {
        dst: WritableFReg,
        src: FReg,
    },
    Vnegf32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Fabs32 {
        dst: WritableFReg,
        src: FReg,
    },
    Fadd64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fsub64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fmul64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fdiv64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    VDivF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Fmaximum64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Fminimum64 {
        dst: WritableFReg,
        src1: FReg,
        src2: FReg,
    },
    Ftrunc64 {
        dst: WritableFReg,
        src: FReg,
    },
    Ffloor64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fceil64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fnearest64 {
        dst: WritableFReg,
        src: FReg,
    },
    Vnearest32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vnearest64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Fsqrt64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fneg64 {
        dst: WritableFReg,
        src: FReg,
    },
    Fabs64 {
        dst: WritableFReg,
        src: FReg,
    },
    Vconst128 {
        dst: WritableVReg,
        imm: u128,
    },
    VAddI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddU8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddI16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddU16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddpairwiseI16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VAddpairwiseI32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VShlI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShlI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShlI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShlI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI8x16S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI64x2S {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI8x16U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VShrI64x2U {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
    },
    VSplatX8 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatX16 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatX32 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatX64 {
        dst: WritableVReg,
        src: XReg,
    },
    VSplatF32 {
        dst: WritableVReg,
        src: FReg,
    },
    VSplatF64 {
        dst: WritableVReg,
        src: FReg,
    },
    VLoad8x8SZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad8x8UZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad16x4LeSZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad16x4LeUZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad32x2LeSZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VLoad32x2LeUZ {
        dst: WritableVReg,
        addr: AddrZ,
    },
    VBand128 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VBor128 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VBxor128 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VBnot128 {
        dst: WritableVReg,
        src: VReg,
    },
    VBitselect128 {
        dst: WritableVReg,
        c: VReg,
        x: VReg,
        y: VReg,
    },
    Vbitmask8x16 {
        dst: WritableXReg,
        src: VReg,
    },
    Vbitmask16x8 {
        dst: WritableXReg,
        src: VReg,
    },
    Vbitmask32x4 {
        dst: WritableXReg,
        src: VReg,
    },
    Vbitmask64x2 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue8x16 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue16x8 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue32x4 {
        dst: WritableXReg,
        src: VReg,
    },
    Valltrue64x2 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue8x16 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue16x8 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue32x4 {
        dst: WritableXReg,
        src: VReg,
    },
    Vanytrue64x2 {
        dst: WritableXReg,
        src: VReg,
    },
    VF32x4FromI32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VF32x4FromI32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    VF64x2FromI64x2S {
        dst: WritableVReg,
        src: VReg,
    },
    VF64x2FromI64x2U {
        dst: WritableVReg,
        src: VReg,
    },
    VI32x4FromF32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VI32x4FromF32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    VI64x2FromF64x2S {
        dst: WritableVReg,
        src: VReg,
    },
    VI64x2FromF64x2U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow8x16S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow8x16U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow16x8S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow16x8U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenLow32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh8x16S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh8x16U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh16x8S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh16x8U {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh32x4S {
        dst: WritableVReg,
        src: VReg,
    },
    VWidenHigh32x4U {
        dst: WritableVReg,
        src: VReg,
    },
    Vnarrow16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow64x2S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vnarrow64x2U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vunarrow64x2U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VFpromoteLow {
        dst: WritableVReg,
        src: VReg,
    },
    VFdemote {
        dst: WritableVReg,
        src: VReg,
    },
    VSubI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubU8x16Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubI16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VSubU16x8Sat {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulI64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VMulF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VQmulrsI16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VPopcnt8x16 {
        dst: WritableVReg,
        src: VReg,
    },
    XExtractV8x16 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    XExtractV16x8 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    XExtractV32x4 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    XExtractV64x2 {
        dst: WritableXReg,
        src: VReg,
        lane: u8,
    },
    FExtractV32x4 {
        dst: WritableFReg,
        src: VReg,
        lane: u8,
    },
    FExtractV64x2 {
        dst: WritableFReg,
        src: VReg,
        lane: u8,
    },
    VInsertX8 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertX16 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertX32 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertX64 {
        dst: WritableVReg,
        src1: VReg,
        src2: XReg,
        lane: u8,
    },
    VInsertF32 {
        dst: WritableVReg,
        src1: VReg,
        src2: FReg,
        lane: u8,
    },
    VInsertF64 {
        dst: WritableVReg,
        src1: VReg,
        src2: FReg,
        lane: u8,
    },
    Veq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Veq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Veq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Veq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslt64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vslteq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vult64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vulteq64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vneg8x16 {
        dst: WritableVReg,
        src: VReg,
    },
    Vneg16x8 {
        dst: WritableVReg,
        src: VReg,
    },
    Vneg32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vneg64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    VnegF64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Vmin8x16S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin8x16U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax8x16S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax8x16U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax16x8S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax16x8U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmin32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax32x4S {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmax32x4U {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vabs8x16 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabs16x8 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabs32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabs64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabsf32x4 {
        dst: WritableVReg,
        src: VReg,
    },
    Vabsf64x2 {
        dst: WritableVReg,
        src: VReg,
    },
    Vmaximumf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vmaximumf64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vminimumf32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vminimumf64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VShuffle {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
        mask: u128,
    },
    Vswizzlei8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vavground8x16 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vavground16x8 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VeqF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VneqF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VltF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VlteqF32x4 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VeqF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VneqF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VltF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    VlteqF64x2 {
        dst: WritableVReg,
        src1: VReg,
        src2: VReg,
    },
    Vfma32x4 {
        dst: WritableVReg,
        a: VReg,
        b: VReg,
        c: VReg,
    },
    Vfma64x2 {
        dst: WritableVReg,
        a: VReg,
        b: VReg,
        c: VReg,
    },
    Vselect {
        dst: WritableVReg,
        cond: XReg,
        if_nonzero: VReg,
        if_zero: VReg,
    },
    Xadd128 {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs_lo: XReg,
        lhs_hi: XReg,
        rhs_lo: XReg,
        rhs_hi: XReg,
    },
    Xsub128 {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs_lo: XReg,
        lhs_hi: XReg,
        rhs_lo: XReg,
        rhs_hi: XReg,
    },
    Xwidemul64S {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs: XReg,
        rhs: XReg,
    },
    Xwidemul64U {
        dst_lo: WritableXReg,
        dst_hi: WritableXReg,
        lhs: XReg,
        rhs: XReg,
    },
}

// Generated as internal constructor for term ty_shift_mask.
pub fn constructor_ty_shift_mask<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> u64 {
    let v1 = C::lane_type(ctx, arg0);
    let v2 = C::ty_bits(ctx, v1);
    let v3 = C::u8_into_u64(ctx, v2);
    let v5 = C::u64_sub(ctx, v3, 0x1_u64);
    // Rule at src\prelude.isle line 293.
    return v5;
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(
    ctx: &mut C,
    arg0: Reg,
) -> InstOutput {
    let v1 = C::value_reg(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src\prelude_lower.isle line 81.
    return v2;
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> InstOutput {
    let v1 = C::put_in_regs(ctx, arg0);
    let v2 = C::output(ctx, v1);
    // Rule at src\prelude_lower.isle line 85.
    return v2;
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> Reg {
    let v1 = C::temp_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src\prelude_lower.isle line 97.
    return v2;
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Reg {
    let v1 = C::put_in_regs(ctx, arg0);
    let v3 = C::value_regs_get(ctx, v1, 0x0_usize);
    // Rule at src\prelude_lower.isle line 162.
    return v3;
}

// Generated as internal constructor for term multi_reg_to_pair_and_single.
pub fn constructor_multi_reg_to_pair_and_single<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::Three {
        a: v1,
        b: v2,
        c: v3,
    } = arg0 {
        let v4 = C::value_regs(ctx, v1, v2);
        let v5 = C::value_reg(ctx, v3);
        let v6 = C::output_pair(ctx, v4, v5);
        // Rule at src\prelude_lower.isle line 173.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_pair_and_single", "src\\prelude_lower.isle line 172")
}

// Generated as internal constructor for term multi_reg_to_pair.
pub fn constructor_multi_reg_to_pair<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::Two {
        a: v1,
        b: v2,
    } = arg0 {
        let v3 = C::value_regs(ctx, v1, v2);
        let v4 = C::output(ctx, v3);
        // Rule at src\prelude_lower.isle line 178.
        return v4;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_pair", "src\\prelude_lower.isle line 177")
}

// Generated as internal constructor for term multi_reg_to_single.
pub fn constructor_multi_reg_to_single<C: Context>(
    ctx: &mut C,
    arg0: &MultiReg,
) -> InstOutput {
    if let &MultiReg::One {
        a: v1,
    } = arg0 {
        let v2 = C::value_reg(ctx, v1);
        let v3 = C::output(ctx, v2);
        // Rule at src\prelude_lower.isle line 183.
        return v3;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "multi_reg_to_single", "src\\prelude_lower.isle line 182")
}

// Generated as internal constructor for term emit_side_effect.
pub fn constructor_emit_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> Unit {
    match arg0 {
        &SideEffectNoResult::Inst {
            inst: ref v1,
        } => {
            let v2 = C::emit(ctx, v1);
            // Rule at src\prelude_lower.isle line 451.
            return v2;
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v3,
            inst2: ref v4,
        } => {
            let v5 = C::emit(ctx, v3);
            let v6 = C::emit(ctx, v4);
            // Rule at src\prelude_lower.isle line 453.
            return v6;
        }
        &SideEffectNoResult::Inst3 {
            inst1: ref v7,
            inst2: ref v8,
            inst3: ref v9,
        } => {
            let v10 = C::emit(ctx, v7);
            let v11 = C::emit(ctx, v8);
            let v12 = C::emit(ctx, v9);
            // Rule at src\prelude_lower.isle line 456.
            return v12;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_side_effect", "src\\prelude_lower.isle line 450")
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> InstOutput {
    let v1 = constructor_emit_side_effect(ctx, arg0);
    let v2 = C::output_none(ctx);
    // Rule at src\prelude_lower.isle line 466.
    return v2;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> SideEffectNoResult {
    match arg0 {
        &SideEffectNoResult::Inst {
            inst: ref v1,
        } => {
            match arg1 {
                &SideEffectNoResult::Inst {
                    inst: ref v3,
                } => {
                    let v4 = SideEffectNoResult::Inst2 {
                        inst1: v1.clone(),
                        inst2: v3.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 471.
                    return v4;
                }
                &SideEffectNoResult::Inst2 {
                    inst1: ref v5,
                    inst2: ref v6,
                } => {
                    let v7 = SideEffectNoResult::Inst3 {
                        inst1: v1.clone(),
                        inst2: v5.clone(),
                        inst3: v6.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 473.
                    return v7;
                }
                _ => {}
            }
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref v8,
            inst2: ref v9,
        } => {
            if let &SideEffectNoResult::Inst {
                inst: ref v3,
            } = arg1 {
                let v10 = SideEffectNoResult::Inst3 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                    inst3: v3.clone(),
                };
                // Rule at src\prelude_lower.isle line 475.
                return v10;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "side_effect_concat", "src\\prelude_lower.isle line 470")
}

// Generated as internal constructor for term side_effect_as_invalid.
pub fn constructor_side_effect_as_invalid<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
) -> InstOutput {
    let v1 = constructor_side_effect(ctx, arg0);
    let v2 = C::invalid_reg(ctx);
    let v3 = constructor_output_reg(ctx, v2);
    // Rule at src\prelude_lower.isle line 481.
    return v3;
}

// Generated as internal constructor for term produces_flags_concat.
pub fn constructor_produces_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ProducesFlags,
) -> ProducesFlags {
    if let &ProducesFlags::ProducesFlagsSideEffect {
        inst: ref v1,
    } = arg0 {
        if let &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v3,
        } = arg1 {
            let v4 = ProducesFlags::ProducesFlagsTwiceSideEffect {
                inst1: v1.clone(),
                inst2: v3.clone(),
            };
            // Rule at src\prelude_lower.isle line 507.
            return v4;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_concat", "src\\prelude_lower.isle line 506")
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> Reg {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            // Rule at src\prelude_lower.isle line 537.
            return v2;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v3,
            result: v4,
        } => {
            // Rule at src\prelude_lower.isle line 538.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_get_reg", "src\\prelude_lower.isle line 536")
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> ProducesFlags {
    match arg0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            let v3 = ProducesFlags::ProducesFlagsSideEffect {
                inst: v1.clone(),
            };
            // Rule at src\prelude_lower.isle line 543.
            return v3;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v4,
            result: v5,
        } => {
            let v6 = ProducesFlags::ProducesFlagsSideEffect {
                inst: v4.clone(),
            };
            // Rule at src\prelude_lower.isle line 545.
            return v6;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "produces_flags_ignore", "src\\prelude_lower.isle line 542")
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> ConsumesFlags {
    match arg0 {
        &ConsumesFlags::ConsumesFlagsSideEffect {
            inst: ref v8,
        } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref v9,
            } = arg1 {
                let v10 = ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: v8.clone(),
                    inst2: v9.clone(),
                };
                // Rule at src\prelude_lower.isle line 558.
                return v10;
            }
        }
        &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref v1,
            result: v2,
        } => {
            if let &ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: ref v4,
                result: v5,
            } = arg1 {
                let v6 = C::value_regs(ctx, v2, v5);
                let v7 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: v1.clone(),
                    inst2: v4.clone(),
                    result: v6,
                };
                // Rule at src\prelude_lower.isle line 552.
                return v7;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_concat", "src\\prelude_lower.isle line 551")
}

// Generated as internal constructor for term consumes_flags_get_reg.
pub fn constructor_consumes_flags_get_reg<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
) -> Reg {
    if let &ConsumesFlags::ConsumesFlagsReturnsReg {
        inst: ref v1,
        result: v2,
    } = arg0 {
        // Rule at src\prelude_lower.isle line 565.
        return v2;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_get_reg", "src\\prelude_lower.isle line 564")
}

// Generated as internal constructor for term consumes_flags_get_regs.
pub fn constructor_consumes_flags_get_regs<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
) -> ValueRegs {
    if let &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
        inst1: ref v1,
        inst2: ref v2,
        result: v3,
    } = arg0 {
        // Rule at src\prelude_lower.isle line 567.
        return v3;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "consumes_flags_get_regs", "src\\prelude_lower.isle line 566")
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> ValueRegs {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v12,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v16 = C::emit(ctx, v13);
                    let v17 = C::value_reg(ctx, v14);
                    // Rule at src\prelude_lower.isle line 595.
                    return v17;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v21 = C::emit(ctx, v18);
                    let v22 = C::emit(ctx, v19);
                    // Rule at src\prelude_lower.isle line 601.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v15 = C::emit(ctx, v12);
                    let v28 = C::emit(ctx, v23);
                    let v29 = C::emit(ctx, v24);
                    let v30 = C::emit(ctx, v25);
                    let v31 = C::emit(ctx, v26);
                    // Rule at src\prelude_lower.isle line 613.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v32,
            inst2: ref v33,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref v13,
                    result: v14,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v36 = C::emit(ctx, v13);
                    let v37 = C::value_reg(ctx, v14);
                    // Rule at src\prelude_lower.isle line 629.
                    return v37;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref v18,
                    inst2: ref v19,
                    result: v20,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v38 = C::emit(ctx, v18);
                    let v39 = C::emit(ctx, v19);
                    // Rule at src\prelude_lower.isle line 636.
                    return v20;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref v23,
                    inst2: ref v24,
                    inst3: ref v25,
                    inst4: ref v26,
                    result: v27,
                } => {
                    let v34 = C::emit(ctx, v32);
                    let v35 = C::emit(ctx, v33);
                    let v40 = C::emit(ctx, v23);
                    let v41 = C::emit(ctx, v24);
                    let v42 = C::emit(ctx, v25);
                    let v43 = C::emit(ctx, v26);
                    // Rule at src\prelude_lower.isle line 649.
                    return v27;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v1,
            result: v2,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v9,
                } => {
                    let v6 = C::emit(ctx, v1);
                    let v10 = C::emit(ctx, v9);
                    let v11 = C::value_reg(ctx, v2);
                    // Rule at src\prelude_lower.isle line 589.
                    return v11;
                }
                &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                    inst: ref v4,
                    result: v5,
                } => {
                    let v6 = C::emit(ctx, v1);
                    let v7 = C::emit(ctx, v4);
                    let v8 = C::value_regs(ctx, v2, v5);
                    // Rule at src\prelude_lower.isle line 581.
                    return v8;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags", "src\\prelude_lower.isle line 579")
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Reg {
    let v2 = constructor_with_flags(ctx, arg0, arg1);
    let v4 = C::value_regs_get(ctx, v2, 0x0_usize);
    // Rule at src\prelude_lower.isle line 667.
    return v4;
}

// Generated as internal constructor for term flags_to_producesflags.
pub fn constructor_flags_to_producesflags<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> ProducesFlags {
    let v1 = C::mark_value_used(ctx, arg0);
    // Rule at src\prelude_lower.isle line 674.
    return ProducesFlags::AlreadyExistingFlags;
}

// Generated as internal constructor for term with_flags_side_effect.
pub fn constructor_with_flags_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> SideEffectNoResult {
    match arg0 {
        &ProducesFlags::AlreadyExistingFlags => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v2,
                } => {
                    let v3 = SideEffectNoResult::Inst {
                        inst: v2.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 685.
                    return v3;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v6 = SideEffectNoResult::Inst2 {
                        inst1: v4.clone(),
                        inst2: v5.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 690.
                    return v6;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v7,
        } => {
            match arg1 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref v2,
                } => {
                    let v8 = SideEffectNoResult::Inst2 {
                        inst1: v7.clone(),
                        inst2: v2.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 695.
                    return v8;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref v4,
                    inst2: ref v5,
                } => {
                    let v9 = SideEffectNoResult::Inst3 {
                        inst1: v7.clone(),
                        inst2: v4.clone(),
                        inst3: v5.clone(),
                    };
                    // Rule at src\prelude_lower.isle line 700.
                    return v9;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref v10,
            inst2: ref v11,
        } => {
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref v2,
            } = arg1 {
                let v12 = SideEffectNoResult::Inst3 {
                    inst1: v10.clone(),
                    inst2: v11.clone(),
                    inst3: v2.clone(),
                };
                // Rule at src\prelude_lower.isle line 705.
                return v12;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags_side_effect", "src\\prelude_lower.isle line 683")
}

// Generated as internal constructor for term with_flags_chained.
pub fn constructor_with_flags_chained<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesAndProducesFlags,
    arg2: &ConsumesFlags,
) -> MultiReg {
    match arg0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref v1,
        } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect {
                    inst: ref v3,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            // Rule at src\prelude_lower.isle line 714.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            // Rule at src\prelude_lower.isle line 722.
                            return MultiReg::Empty;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v17 = MultiReg::One {
                                a: v15,
                            };
                            // Rule at src\prelude_lower.isle line 731.
                            return v17;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v27 = MultiReg::Two {
                                a: v24,
                                b: v26,
                            };
                            // Rule at src\prelude_lower.isle line 739.
                            return v27;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v39 = MultiReg::Two {
                                a: v37,
                                b: v38,
                            };
                            // Rule at src\prelude_lower.isle line 748.
                            return v39;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v50 = MultiReg::One {
                                a: v48,
                            };
                            // Rule at src\prelude_lower.isle line 808.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v50 = MultiReg::One {
                                a: v48,
                            };
                            // Rule at src\prelude_lower.isle line 816.
                            return v50;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v51 = MultiReg::Two {
                                a: v48,
                                b: v15,
                            };
                            // Rule at src\prelude_lower.isle line 825.
                            return v51;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v52 = MultiReg::Three {
                                a: v48,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src\prelude_lower.isle line 833.
                            return v52;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v6 = C::emit(ctx, v1);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v53 = MultiReg::Three {
                                a: v48,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src\prelude_lower.isle line 842.
                            return v53;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref v40,
            result: v41,
        } => {
            match arg1 {
                &ConsumesAndProducesFlags::SideEffect {
                    inst: ref v3,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v8 = C::emit(ctx, v5);
                            let v43 = MultiReg::One {
                                a: v41,
                            };
                            // Rule at src\prelude_lower.isle line 761.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v43 = MultiReg::One {
                                a: v41,
                            };
                            // Rule at src\prelude_lower.isle line 769.
                            return v43;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v16 = C::emit(ctx, v14);
                            let v44 = MultiReg::Two {
                                a: v41,
                                b: v15,
                            };
                            // Rule at src\prelude_lower.isle line 778.
                            return v44;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v45 = MultiReg::Three {
                                a: v41,
                                b: v24,
                                c: v26,
                            };
                            // Rule at src\prelude_lower.isle line 786.
                            return v45;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v7 = C::emit(ctx, v3);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v46 = MultiReg::Three {
                                a: v41,
                                b: v37,
                                c: v38,
                            };
                            // Rule at src\prelude_lower.isle line 795.
                            return v46;
                        }
                        _ => {}
                    }
                }
                &ConsumesAndProducesFlags::ReturnsReg {
                    inst: ref v47,
                    result: v48,
                } => {
                    match arg2 {
                        &ConsumesFlags::ConsumesFlagsSideEffect {
                            inst: ref v5,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v8 = C::emit(ctx, v5);
                            let v54 = MultiReg::Two {
                                a: v41,
                                b: v48,
                            };
                            // Rule at src\prelude_lower.isle line 855.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsSideEffect2 {
                            inst1: ref v10,
                            inst2: ref v11,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v12 = C::emit(ctx, v10);
                            let v13 = C::emit(ctx, v11);
                            let v54 = MultiReg::Two {
                                a: v41,
                                b: v48,
                            };
                            // Rule at src\prelude_lower.isle line 863.
                            return v54;
                        }
                        &ConsumesFlags::ConsumesFlagsReturnsReg {
                            inst: ref v14,
                            result: v15,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v16 = C::emit(ctx, v14);
                            let v55 = MultiReg::Three {
                                a: v41,
                                b: v48,
                                c: v15,
                            };
                            // Rule at src\prelude_lower.isle line 872.
                            return v55;
                        }
                        &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                            inst1: ref v18,
                            inst2: ref v19,
                            result: v20,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v21 = C::emit(ctx, v18);
                            let v22 = C::emit(ctx, v19);
                            let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                            let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                            let v56 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v24,
                                d: v26,
                            };
                            // Rule at src\prelude_lower.isle line 880.
                            return v56;
                        }
                        &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                            inst1: ref v28,
                            inst2: ref v29,
                            inst3: ref v30,
                            inst4: ref v31,
                            result: v32,
                        } => {
                            let v42 = C::emit(ctx, v40);
                            let v49 = C::emit(ctx, v47);
                            let v33 = C::emit(ctx, v28);
                            let v34 = C::emit(ctx, v29);
                            let v35 = C::emit(ctx, v30);
                            let v36 = C::emit(ctx, v31);
                            let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                            let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                            let v57 = MultiReg::Four {
                                a: v41,
                                b: v48,
                                c: v37,
                                d: v38,
                            };
                            // Rule at src\prelude_lower.isle line 889.
                            return v57;
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref v58,
            result: v59,
        } => {
            if let &ConsumesAndProducesFlags::ReturnsReg {
                inst: ref v47,
                result: v48,
            } = arg1 {
                match arg2 {
                    &ConsumesFlags::ConsumesFlagsSideEffect {
                        inst: ref v5,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v8 = C::emit(ctx, v5);
                        let v61 = MultiReg::Two {
                            a: v59,
                            b: v48,
                        };
                        // Rule at src\prelude_lower.isle line 901.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsSideEffect2 {
                        inst1: ref v10,
                        inst2: ref v11,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v12 = C::emit(ctx, v10);
                        let v13 = C::emit(ctx, v11);
                        let v61 = MultiReg::Two {
                            a: v59,
                            b: v48,
                        };
                        // Rule at src\prelude_lower.isle line 909.
                        return v61;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                        inst: ref v63,
                        result: v64,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v65 = C::emit(ctx, v63);
                        let v66 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v64,
                        };
                        // Rule at src\prelude_lower.isle line 926.
                        return v66;
                    }
                    &ConsumesFlags::ConsumesFlagsReturnsReg {
                        inst: ref v14,
                        result: v15,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v16 = C::emit(ctx, v14);
                        let v62 = MultiReg::Three {
                            a: v59,
                            b: v48,
                            c: v15,
                        };
                        // Rule at src\prelude_lower.isle line 918.
                        return v62;
                    }
                    &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                        inst1: ref v18,
                        inst2: ref v19,
                        result: v20,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v21 = C::emit(ctx, v18);
                        let v22 = C::emit(ctx, v19);
                        let v24 = C::value_regs_get(ctx, v20, 0x0_usize);
                        let v26 = C::value_regs_get(ctx, v20, 0x1_usize);
                        let v67 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v24,
                            d: v26,
                        };
                        // Rule at src\prelude_lower.isle line 934.
                        return v67;
                    }
                    &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                        inst1: ref v28,
                        inst2: ref v29,
                        inst3: ref v30,
                        inst4: ref v31,
                        result: v32,
                    } => {
                        let v60 = C::emit(ctx, v58);
                        let v49 = C::emit(ctx, v47);
                        let v33 = C::emit(ctx, v28);
                        let v34 = C::emit(ctx, v29);
                        let v35 = C::emit(ctx, v30);
                        let v36 = C::emit(ctx, v31);
                        let v37 = C::value_regs_get(ctx, v32, 0x0_usize);
                        let v38 = C::value_regs_get(ctx, v32, 0x1_usize);
                        let v68 = MultiReg::Four {
                            a: v59,
                            b: v48,
                            c: v37,
                            d: v38,
                        };
                        // Rule at src\prelude_lower.isle line 943.
                        return v68;
                    }
                    _ => {}
                }
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "with_flags_chained", "src\\prelude_lower.isle line 711")
}

// Generated as internal constructor for term lower_return.
pub fn constructor_lower_return<C: Context>(
    ctx: &mut C,
    arg0: ValueSlice,
) -> InstOutput {
    let v1 = &C::put_in_regs_vec(ctx, arg0);
    let v2 = C::gen_return(ctx, v1);
    let v3 = C::output_none(ctx);
    // Rule at src\prelude_lower.isle line 1153.
    return v3;
}

// Generated as internal constructor for term ty_to_operand_size.
pub fn constructor_ty_to_operand_size<C: Context>(
    ctx: &mut C,
    arg0: Type,
) -> OperandSize {
    match arg0 {
        I32 => {
            // Rule at src\isa\pulley_shared\inst.isle line 5.
            return OperandSize::Size32;
        }
        I64 => {
            // Rule at src\isa\pulley_shared\inst.isle line 6.
            return OperandSize::Size64;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "ty_to_operand_size", "src\\isa\\pulley_shared\\inst.isle line 4")
}

// Generated as internal constructor for term raw_inst_to_inst.
pub fn constructor_raw_inst_to_inst<C: Context>(
    ctx: &mut C,
    arg0: &RawInst,
) -> MInst {
    let v1 = MInst::Raw {
        raw: arg0.clone(),
    };
    // Rule at src\isa\pulley_shared\inst.isle line 161.
    return v1;
}

// Generated as internal constructor for term amode_base.
pub fn constructor_amode_base<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> ValueOffset {
    let v4 = C::def_inst(ctx, arg0);
    if let Some(v5) = v4 {
        let v6 = &C::inst_data_value(ctx, v5);
        if let &InstructionData::Binary {
            opcode: ref v7,
            args: ref v8,
        } = v6 {
            if let &Opcode::Iadd = v7 {
                let v9 = C::unpack_value_array_2(ctx, v8);
                let v12 = C::i64_from_iconst(ctx, v9.1);
                if let Some(v13) = v12 {
                    let v14 = C::i64_from_i32(ctx, v13);
                    if let Some(v15) = v14 {
                        let v2 = C::offset32(ctx, arg1);
                        let v16 = C::i32_checked_add(ctx, v15, v2);
                        if let Some(v17) = v16 {
                            let v18 = ValueOffset::Both {
                                value: v9.0,
                                offset: v17,
                            };
                            // Rule at src\isa\pulley_shared\inst.isle line 187.
                            return v18;
                        }
                    }
                }
            }
        }
    }
    let v2 = C::offset32(ctx, arg1);
    let v3 = ValueOffset::Both {
        value: arg0,
        offset: v2,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 186.
    return v3;
}

// Generated as internal constructor for term amode.
pub fn constructor_amode<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> Amode {
    let v2 = &constructor_amode_base(ctx, arg0, arg1);
    if let &ValueOffset::Both {
        value: v3,
        offset: v4,
    } = v2 {
        let v5 = constructor_put_in_xreg(ctx, v3);
        let v6 = Amode::RegOffset {
            base: v5,
            offset: v4,
        };
        // Rule at src\isa\pulley_shared\inst.isle line 202.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "amode", "src\\isa\\pulley_shared\\inst.isle line 201")
}

// Generated as internal constructor for term addro32.
pub fn constructor_addro32<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> AddrO32 {
    let v2 = &constructor_amode_base(ctx, arg0, arg1);
    if let &ValueOffset::Both {
        value: v3,
        offset: v4,
    } = v2 {
        let v5 = constructor_put_in_xreg(ctx, v3);
        let v6 = AddrO32::Base {
            addr: v5,
            offset: v4,
        };
        // Rule at src\isa\pulley_shared\inst.isle line 215.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "addro32", "src\\isa\\pulley_shared\\inst.isle line 214")
}

// Generated as internal constructor for term addrz.
pub fn constructor_addrz<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
) -> AddrZ {
    let v2 = &constructor_amode_base(ctx, arg0, arg1);
    if let &ValueOffset::Both {
        value: v3,
        offset: v4,
    } = v2 {
        let v5 = constructor_put_in_xreg(ctx, v3);
        let v6 = AddrZ::Base {
            addr: v5,
            offset: v4,
        };
        // Rule at src\isa\pulley_shared\inst.isle line 228.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "addrz", "src\\isa\\pulley_shared\\inst.isle line 227")
}

// Generated as internal constructor for term sinkable_load.
pub fn constructor_sinkable_load<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<SinkableLoad> {
    let v2 = C::is_sinkable_inst(ctx, arg0);
    if let Some(v3) = v2 {
        let v4 = &C::inst_data_value(ctx, v3);
        if let &InstructionData::Load {
            opcode: ref v5,
            arg: v6,
            flags: v7,
            offset: v8,
        } = v4 {
            if let &Opcode::Load = v5 {
                let v10 = &C::endianness(ctx, v7);
                let v11 = C::is_native_endianness(ctx, v10);
                if v11 == true {
                    let v12 = C::memflags_nontrapping(ctx, v7);
                    if v12 == true {
                        let v9 = C::offset32(ctx, v8);
                        let v13 = C::i32_try_into_u8(ctx, v9);
                        if let Some(v14) = v13 {
                            let v1 = C::value_type(ctx, arg0);
                            let v15 = SinkableLoad::Load {
                                inst: v3,
                                ty: v1,
                                addr: v6,
                                offset: v14,
                            };
                            let v16 = Some(v15);
                            // Rule at src\isa\pulley_shared\inst.isle line 274.
                            return v16;
                        }
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term sink_load.
pub fn constructor_sink_load<C: Context>(
    ctx: &mut C,
    arg0: &SinkableLoad,
) -> SunkLoad {
    if let &SinkableLoad::Load {
        inst: v1,
        ty: v2,
        addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = C::sink_inst(ctx, v1);
        let v6 = SunkLoad::Load {
            ty: v2,
            addr: v3,
            offset: v4,
        };
        // Rule at src\isa\pulley_shared\inst.isle line 289.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sink_load", "src\\isa\\pulley_shared\\inst.isle line 288")
}

// Generated as internal constructor for term gen_addrg32.
pub fn constructor_gen_addrg32<C: Context>(
    ctx: &mut C,
    arg0: &G32,
) -> AddrG32 {
    if let &G32::All {
        heap_base: v1,
        heap_bound: v2,
        wasm_addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = constructor_put_in_xreg(ctx, v1);
        let v6 = constructor_put_in_xreg(ctx, v2);
        let v7 = constructor_put_in_xreg(ctx, v3);
        let v8 = AddrG32::RegisterBound {
            host_heap_base: v5,
            host_heap_bound: v6,
            wasm_addr: v7,
            offset: v4,
        };
        // Rule at src\isa\pulley_shared\inst.isle line 311.
        return v8;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_addrg32", "src\\isa\\pulley_shared\\inst.isle line 310")
}

// Generated as internal constructor for term gen_addrg32bne.
pub fn constructor_gen_addrg32bne<C: Context>(
    ctx: &mut C,
    arg0: &G32Bne,
) -> AddrG32Bne {
    if let &G32Bne::All {
        heap_base: v1,
        heap_bound: ref v2,
        wasm_addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = constructor_put_in_xreg(ctx, v1);
        let v6 = &constructor_sink_load(ctx, v2);
        let v7 = constructor_put_in_xreg(ctx, v3);
        let v8 = &constructor_gen_addrg32bne_for_real(ctx, v5, v6, v7, v4);
        // Rule at src\isa\pulley_shared\inst.isle line 320.
        return v8.clone();
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_addrg32bne", "src\\isa\\pulley_shared\\inst.isle line 319")
}

// Generated as internal constructor for term gen_addrg32bne_for_real.
pub fn constructor_gen_addrg32bne_for_real<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: &SunkLoad,
    arg2: XReg,
    arg3: u8,
) -> AddrG32Bne {
    if let &SunkLoad::Load {
        ty: v2,
        addr: v3,
        offset: v4,
    } = arg1 {
        let v7 = constructor_put_in_xreg(ctx, v3);
        let v8 = AddrG32Bne::BoundNe {
            host_heap_base: arg0,
            host_heap_bound_addr: v7,
            host_heap_bound_offset: v4,
            wasm_addr: arg2,
            offset: arg3,
        };
        // Rule at src\isa\pulley_shared\inst.isle line 326.
        return v8;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_addrg32bne_for_real", "src\\isa\\pulley_shared\\inst.isle line 325")
}

// Generated as internal constructor for term addrg32bne.
pub fn constructor_addrg32bne<C: Context>(
    ctx: &mut C,
    arg0: &G32,
) -> Option<G32Bne> {
    if let &G32::All {
        heap_base: v1,
        heap_bound: v2,
        wasm_addr: v3,
        offset: v4,
    } = arg0 {
        let v5 = &constructor_sinkable_load(ctx, v2);
        if let Some(v6) = v5 {
            let v7 = C::u16_try_into_u8(ctx, v4);
            if let Some(v8) = v7 {
                let v9 = G32Bne::All {
                    heap_base: v1,
                    heap_bound: v6.clone(),
                    wasm_addr: v3,
                    offset: v8,
                };
                let v10 = Some(v9);
                // Rule at src\isa\pulley_shared\inst.isle line 334.
                return v10;
            }
        }
    }
    None
}

// Generated as internal constructor for term wasm_g32.
pub fn constructor_wasm_g32<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
) -> Option<G32> {
    let v1 = C::def_inst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = &C::inst_data_value(ctx, v2);
        if let &InstructionData::Ternary {
            opcode: ref v4,
            args: ref v5,
        } = v3 {
            if let &Opcode::Select = v4 {
                let v6 = C::unpack_value_array_3(ctx, v5);
                let v10 = C::def_inst(ctx, v6.1);
                if let Some(v11) = v10 {
                    let v12 = &C::inst_data_value(ctx, v11);
                    if let &InstructionData::UnaryImm {
                        opcode: ref v13,
                        imm: v14,
                    } = v12 {
                        if let &Opcode::Iconst = v13 {
                            let v15 = C::u64_from_imm64(ctx, v14);
                            if v15 == 0x0_u64 {
                                let v17 = C::offset32(ctx, arg1);
                                if v17 == 0_i32 {
                                    let v20 = C::memflags_is_wasm(ctx, arg2);
                                    if v20 == true {
                                        let v21 = &constructor_host_offset(ctx, v6.2);
                                        if let &HostOffset::All {
                                            a: v22,
                                            b: v23,
                                        } = v21 {
                                            let v24 = &constructor_wasm_oob_select(ctx, v6.0, v22);
                                            if let Some(v25) = v24 {
                                                if let &OobSelect::All {
                                                    a: v26,
                                                    b: v27,
                                                    c: v28,
                                                    d: v29,
                                                } = v25 {
                                                    let v30 = C::g32_offset(ctx, v23, arg3, v29);
                                                    if let Some(v31) = v30 {
                                                        let v32 = G32::All {
                                                            heap_base: v26,
                                                            heap_bound: v27,
                                                            wasm_addr: v28,
                                                            offset: v31,
                                                        };
                                                        let v33 = Some(v32);
                                                        // Rule at src\isa\pulley_shared\inst.isle line 350.
                                                        return v33;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term host_offset.
pub fn constructor_host_offset<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> HostOffset {
    let v3 = C::def_inst(ctx, arg0);
    if let Some(v4) = v3 {
        let v5 = &C::inst_data_value(ctx, v4);
        if let &InstructionData::Binary {
            opcode: ref v6,
            args: ref v7,
        } = v5 {
            if let &Opcode::Iadd = v6 {
                let v8 = C::unpack_value_array_2(ctx, v7);
                let v24 = C::i64_from_iconst(ctx, v8.0);
                if let Some(v25) = v24 {
                    let v26 = C::i64_from_i32(ctx, v25);
                    if let Some(v27) = v26 {
                        let v28 = C::def_inst(ctx, v8.1);
                        if let Some(v29) = v28 {
                            let v30 = &C::inst_data_value(ctx, v29);
                            if let &InstructionData::Binary {
                                opcode: ref v31,
                                args: ref v32,
                            } = v30 {
                                if let &Opcode::Iadd = v31 {
                                    let v36 = HostOffset::All {
                                        a: v8.1,
                                        b: v27,
                                    };
                                    // Rule at src\isa\pulley_shared\inst.isle line 387.
                                    return v36;
                                }
                            }
                        }
                    }
                }
                let v11 = C::def_inst(ctx, v8.0);
                if let Some(v12) = v11 {
                    let v13 = &C::inst_data_value(ctx, v12);
                    if let &InstructionData::Binary {
                        opcode: ref v14,
                        args: ref v15,
                    } = v13 {
                        if let &Opcode::Iadd = v14 {
                            let v19 = C::i64_from_iconst(ctx, v8.1);
                            if let Some(v20) = v19 {
                                let v21 = C::i64_from_i32(ctx, v20);
                                if let Some(v22) = v21 {
                                    let v23 = HostOffset::All {
                                        a: v8.0,
                                        b: v22,
                                    };
                                    // Rule at src\isa\pulley_shared\inst.isle line 386.
                                    return v23;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let v2 = HostOffset::All {
        a: arg0,
        b: 0_i32,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 385.
    return v2;
}

// Generated as internal constructor for term wasm_oob_select.
pub fn constructor_wasm_oob_select<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Option<OobSelect> {
    let v2 = C::def_inst(ctx, arg1);
    if let Some(v3) = v2 {
        let v4 = &C::inst_data_value(ctx, v3);
        if let &InstructionData::Binary {
            opcode: ref v5,
            args: ref v6,
        } = v4 {
            if let &Opcode::Iadd = v5 {
                let v15 = &C::pointer_width(ctx);
                match v15 {
                    &PointerWidth::PointerWidth32 => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::value_type(ctx, v7.0);
                        if v18 == I32 {
                            let v19 = &constructor_wasm_oob_cond(ctx, v7.0, arg0);
                            if let Some(v20) = v19 {
                                if let &OobCond::All {
                                    a: v21,
                                    b: v22,
                                } = v20 {
                                    let v23 = OobSelect::All {
                                        a: v7.1,
                                        b: v21,
                                        c: v7.0,
                                        d: v22,
                                    };
                                    let v24 = Some(v23);
                                    // Rule at src\isa\pulley_shared\inst.isle line 401.
                                    return v24;
                                }
                            }
                        }
                        let v10 = C::value_type(ctx, v7.1);
                        if v10 == I32 {
                            let v11 = &constructor_wasm_oob_cond(ctx, v7.1, arg0);
                            if let Some(v12) = v11 {
                                if let &OobCond::All {
                                    a: v13,
                                    b: v14,
                                } = v12 {
                                    let v16 = OobSelect::All {
                                        a: v7.0,
                                        b: v13,
                                        c: v7.1,
                                        d: v14,
                                    };
                                    let v17 = Some(v16);
                                    // Rule at src\isa\pulley_shared\inst.isle line 397.
                                    return v17;
                                }
                            }
                        }
                    }
                    &PointerWidth::PointerWidth64 => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::value_type(ctx, v7.0);
                        if v18 == I64 {
                            let v19 = &constructor_wasm_oob_cond(ctx, v7.0, arg0);
                            if let Some(v20) = v19 {
                                if let &OobCond::All {
                                    a: v21,
                                    b: v22,
                                } = v20 {
                                    let v29 = constructor_wasm32_addr_for_host64(ctx, v7.0);
                                    if let Some(v30) = v29 {
                                        let v31 = OobSelect::All {
                                            a: v7.1,
                                            b: v21,
                                            c: v30,
                                            d: v22,
                                        };
                                        let v32 = Some(v31);
                                        // Rule at src\isa\pulley_shared\inst.isle line 413.
                                        return v32;
                                    }
                                }
                            }
                        }
                        let v10 = C::value_type(ctx, v7.1);
                        if v10 == I64 {
                            let v11 = &constructor_wasm_oob_cond(ctx, v7.1, arg0);
                            if let Some(v12) = v11 {
                                if let &OobCond::All {
                                    a: v13,
                                    b: v14,
                                } = v12 {
                                    let v25 = constructor_wasm32_addr_for_host64(ctx, v7.1);
                                    if let Some(v26) = v25 {
                                        let v27 = OobSelect::All {
                                            a: v7.0,
                                            b: v13,
                                            c: v26,
                                            d: v14,
                                        };
                                        let v28 = Some(v27);
                                        // Rule at src\isa\pulley_shared\inst.isle line 408.
                                        return v28;
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term wasm32_addr_for_host64.
pub fn constructor_wasm32_addr_for_host64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<Value> {
    let v1 = C::def_inst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = &C::inst_data_value(ctx, v2);
        match v3 {
            &InstructionData::Unary {
                opcode: ref v4,
                arg: v5,
            } => {
                if let &Opcode::Uextend = v4 {
                    let v6 = C::value_type(ctx, v5);
                    if v6 == I32 {
                        let v7 = Some(v5);
                        // Rule at src\isa\pulley_shared\inst.isle line 424.
                        return v7;
                    }
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v8,
                imm: v9,
            } => {
                if let &Opcode::Iconst = v8 {
                    let v10 = C::u64_from_imm64(ctx, v9);
                    let v11 = C::u64_from_u32(ctx, v10);
                    if let Some(v12) = v11 {
                        let v13 = Some(arg0);
                        // Rule at src\isa\pulley_shared\inst.isle line 425.
                        return v13;
                    }
                }
            }
            _ => {}
        }
    }
    None
}

// Generated as internal constructor for term wasm_oob_cond.
pub fn constructor_wasm_oob_cond<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
) -> Option<OobCond> {
    let v2 = C::def_inst(ctx, arg1);
    if let Some(v3) = v2 {
        let v4 = &C::inst_data_value(ctx, v3);
        if let &InstructionData::IntCompare {
            opcode: ref v5,
            args: ref v6,
            cond: ref v7,
        } = v4 {
            if let &Opcode::Icmp = v5 {
                match v7 {
                    &IntCC::UnsignedGreaterThan => {
                        let v8 = C::unpack_value_array_2(ctx, v6);
                        let v11 = C::def_inst(ctx, v8.1);
                        if let Some(v12) = v11 {
                            let v13 = &C::inst_data_value(ctx, v12);
                            if let &InstructionData::Binary {
                                opcode: ref v14,
                                args: ref v15,
                            } = v13 {
                                if let &Opcode::Isub = v14 {
                                    let v16 = C::unpack_value_array_2(ctx, v15);
                                    let v19 = C::def_inst(ctx, v16.1);
                                    if let Some(v20) = v19 {
                                        let v21 = &C::inst_data_value(ctx, v20);
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v22,
                                            imm: v23,
                                        } = v21 {
                                            if let &Opcode::Iconst = v22 {
                                                if arg0 == v8.0 {
                                                    let v24 = C::u64_from_imm64(ctx, v23);
                                                    let v25 = OobCond::All {
                                                        a: v16.0,
                                                        b: v24,
                                                    };
                                                    let v26 = Some(v25);
                                                    // Rule at src\isa\pulley_shared\inst.isle line 432.
                                                    return v26;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &IntCC::UnsignedLessThan => {
                        let v8 = C::unpack_value_array_2(ctx, v6);
                        let v27 = C::def_inst(ctx, v8.0);
                        if let Some(v28) = v27 {
                            let v29 = &C::inst_data_value(ctx, v28);
                            if let &InstructionData::Binary {
                                opcode: ref v30,
                                args: ref v31,
                            } = v29 {
                                if let &Opcode::Isub = v30 {
                                    let v32 = C::unpack_value_array_2(ctx, v31);
                                    let v35 = C::def_inst(ctx, v32.1);
                                    if let Some(v36) = v35 {
                                        let v37 = &C::inst_data_value(ctx, v36);
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v38,
                                            imm: v39,
                                        } = v37 {
                                            if let &Opcode::Iconst = v38 {
                                                if arg0 == v8.1 {
                                                    let v40 = C::u64_from_imm64(ctx, v39);
                                                    let v41 = OobCond::All {
                                                        a: v32.0,
                                                        b: v40,
                                                    };
                                                    let v42 = Some(v41);
                                                    // Rule at src\isa\pulley_shared\inst.isle line 434.
                                                    return v42;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term put_in_xreg.
pub fn constructor_put_in_xreg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::xreg_new(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 466.
    return v2;
}

// Generated as internal constructor for term output_xreg.
pub fn constructor_output_xreg<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> InstOutput {
    let v1 = C::xreg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 471.
    return v2;
}

// Generated as internal constructor for term writable_xreg_to_reg.
pub fn constructor_writable_xreg_to_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableXReg,
) -> Reg {
    let v1 = C::writable_xreg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 486.
    return v2;
}

// Generated as internal constructor for term xreg_to_value_regs.
pub fn constructor_xreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> ValueRegs {
    let v1 = C::xreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 496.
    return v2;
}

// Generated as internal constructor for term writable_xreg_to_value_regs.
pub fn constructor_writable_xreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableXReg,
) -> ValueRegs {
    let v1 = constructor_writable_xreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 501.
    return v2;
}

// Generated as internal constructor for term temp_writable_xreg.
pub fn constructor_temp_writable_xreg<C: Context>(
    ctx: &mut C,
) -> WritableXReg {
    let v1 = C::temp_writable_reg(ctx, I64);
    let v2 = C::writable_xreg_new(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 506.
    return v2;
}

// Generated as internal constructor for term put_in_freg.
pub fn constructor_put_in_freg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> FReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::freg_new(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 526.
    return v2;
}

// Generated as internal constructor for term output_freg.
pub fn constructor_output_freg<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> InstOutput {
    let v1 = C::freg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 531.
    return v2;
}

// Generated as internal constructor for term writable_freg_to_reg.
pub fn constructor_writable_freg_to_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableFReg,
) -> Reg {
    let v1 = C::writable_freg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 546.
    return v2;
}

// Generated as internal constructor for term freg_to_value_regs.
pub fn constructor_freg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> ValueRegs {
    let v1 = C::freg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 556.
    return v2;
}

// Generated as internal constructor for term writable_freg_to_value_regs.
pub fn constructor_writable_freg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableFReg,
) -> ValueRegs {
    let v1 = constructor_writable_freg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 561.
    return v2;
}

// Generated as internal constructor for term temp_writable_freg.
pub fn constructor_temp_writable_freg<C: Context>(
    ctx: &mut C,
) -> WritableFReg {
    let v1 = C::temp_writable_reg(ctx, F64);
    let v2 = C::writable_freg_new(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 566.
    return v2;
}

// Generated as internal constructor for term put_in_vreg.
pub fn constructor_put_in_vreg<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> VReg {
    let v1 = C::put_in_reg(ctx, arg0);
    let v2 = C::vreg_new(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 586.
    return v2;
}

// Generated as internal constructor for term output_vreg.
pub fn constructor_output_vreg<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> InstOutput {
    let v1 = C::vreg_to_reg(ctx, arg0);
    let v2 = constructor_output_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 591.
    return v2;
}

// Generated as internal constructor for term writable_vreg_to_reg.
pub fn constructor_writable_vreg_to_reg<C: Context>(
    ctx: &mut C,
    arg0: WritableVReg,
) -> Reg {
    let v1 = C::writable_vreg_to_writable_reg(ctx, arg0);
    let v2 = C::writable_reg_to_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 606.
    return v2;
}

// Generated as internal constructor for term vreg_to_value_regs.
pub fn constructor_vreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> ValueRegs {
    let v1 = C::vreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 616.
    return v2;
}

// Generated as internal constructor for term writable_vreg_to_value_regs.
pub fn constructor_writable_vreg_to_value_regs<C: Context>(
    ctx: &mut C,
    arg0: WritableVReg,
) -> ValueRegs {
    let v1 = constructor_writable_vreg_to_reg(ctx, arg0);
    let v2 = C::value_reg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 621.
    return v2;
}

// Generated as internal constructor for term temp_writable_vreg.
pub fn constructor_temp_writable_vreg<C: Context>(
    ctx: &mut C,
) -> WritableVReg {
    let v1 = C::temp_writable_reg(ctx, I8X16);
    let v2 = C::writable_vreg_new(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 626.
    return v2;
}

// Generated as internal constructor for term imm.
pub fn constructor_imm<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> Reg {
    match arg0 {
        0_i64 => {
            let v1 = constructor_pulley_xzero(ctx);
            let v2 = C::xreg_to_reg(ctx, v1);
            // Rule at src\isa\pulley_shared\inst.isle line 634.
            return v2;
        }
        1_i64 => {
            let v3 = constructor_pulley_xone(ctx);
            let v4 = C::xreg_to_reg(ctx, v3);
            // Rule at src\isa\pulley_shared\inst.isle line 635.
            return v4;
        }
        _ => {}
    }
    let v5 = C::i64_from_i8(ctx, arg0);
    if let Some(v6) = v5 {
        let v7 = constructor_pulley_xconst8(ctx, v6);
        let v8 = C::xreg_to_reg(ctx, v7);
        // Rule at src\isa\pulley_shared\inst.isle line 639.
        return v8;
    }
    let v9 = C::i64_from_i16(ctx, arg0);
    if let Some(v10) = v9 {
        let v11 = constructor_pulley_xconst16(ctx, v10);
        let v12 = C::xreg_to_reg(ctx, v11);
        // Rule at src\isa\pulley_shared\inst.isle line 640.
        return v12;
    }
    let v13 = C::i64_from_i32(ctx, arg0);
    if let Some(v14) = v13 {
        let v15 = constructor_pulley_xconst32(ctx, v14);
        let v16 = C::xreg_to_reg(ctx, v15);
        // Rule at src\isa\pulley_shared\inst.isle line 641.
        return v16;
    }
    let v17 = constructor_pulley_xconst64(ctx, arg0);
    let v18 = C::xreg_to_reg(ctx, v17);
    // Rule at src\isa\pulley_shared\inst.isle line 642.
    return v18;
}

// Generated as internal constructor for term pulley_trap_if.
pub fn constructor_pulley_trap_if<C: Context>(
    ctx: &mut C,
    arg0: &Cond,
    arg1: &TrapCode,
) -> SideEffectNoResult {
    let v2 = MInst::TrapIf {
        cond: arg0.clone(),
        code: arg1.clone(),
    };
    let v3 = SideEffectNoResult::Inst {
        inst: v2,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 647.
    return v3;
}

// Generated as internal constructor for term pulley_get_special.
pub fn constructor_pulley_get_special<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = MInst::GetSpecial {
        dst: v1,
        reg: arg0,
    };
    let v3 = C::emit(ctx, &v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at src\isa\pulley_shared\inst.isle line 654.
    return v4;
}

// Generated as internal constructor for term pulley_jump.
pub fn constructor_pulley_jump<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
) -> SideEffectNoResult {
    let v1 = MInst::Jump {
        label: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 660.
    return v2;
}

// Generated as internal constructor for term pulley_br_if.
pub fn constructor_pulley_br_if<C: Context>(
    ctx: &mut C,
    arg0: &Cond,
    arg1: MachLabel,
    arg2: MachLabel,
) -> SideEffectNoResult {
    let v3 = MInst::BrIf {
        cond: arg0.clone(),
        taken: arg1,
        not_taken: arg2,
    };
    let v4 = SideEffectNoResult::Inst {
        inst: v3,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 664.
    return v4;
}

// Generated as internal constructor for term pulley_xload.
pub fn constructor_pulley_xload<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Type,
    arg2: MemFlags,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = MInst::XLoad {
        dst: v3,
        mem: arg0.clone(),
        ty: arg1,
        flags: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at src\isa\pulley_shared\inst.isle line 668.
    return v6;
}

// Generated as internal constructor for term pulley_xstore.
pub fn constructor_pulley_xstore<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: XReg,
    arg2: Type,
    arg3: MemFlags,
) -> SideEffectNoResult {
    let v4 = MInst::XStore {
        mem: arg0.clone(),
        src: arg1,
        ty: arg2,
        flags: arg3,
    };
    let v5 = SideEffectNoResult::Inst {
        inst: v4,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 674.
    return v5;
}

// Generated as internal constructor for term pulley_fload.
pub fn constructor_pulley_fload<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Type,
    arg2: MemFlags,
) -> FReg {
    let v3 = constructor_temp_writable_freg(ctx);
    let v4 = MInst::FLoad {
        dst: v3,
        mem: arg0.clone(),
        ty: arg1,
        flags: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_freg_to_freg(ctx, v3);
    // Rule at src\isa\pulley_shared\inst.isle line 678.
    return v6;
}

// Generated as internal constructor for term pulley_fstore.
pub fn constructor_pulley_fstore<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: FReg,
    arg2: Type,
    arg3: MemFlags,
) -> SideEffectNoResult {
    let v4 = MInst::FStore {
        mem: arg0.clone(),
        src: arg1,
        ty: arg2,
        flags: arg3,
    };
    let v5 = SideEffectNoResult::Inst {
        inst: v4,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 684.
    return v5;
}

// Generated as internal constructor for term pulley_vload.
pub fn constructor_pulley_vload<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: Type,
    arg2: MemFlags,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = MInst::VLoad {
        dst: v3,
        mem: arg0.clone(),
        ty: arg1,
        flags: arg2,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at src\isa\pulley_shared\inst.isle line 688.
    return v6;
}

// Generated as internal constructor for term pulley_vstore.
pub fn constructor_pulley_vstore<C: Context>(
    ctx: &mut C,
    arg0: &Amode,
    arg1: VReg,
    arg2: Type,
    arg3: MemFlags,
) -> SideEffectNoResult {
    let v4 = MInst::VStore {
        mem: arg0.clone(),
        src: arg1,
        ty: arg2,
        flags: arg3,
    };
    let v5 = SideEffectNoResult::Inst {
        inst: v4,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 694.
    return v5;
}

// Generated as internal constructor for term gen_br_table.
pub fn constructor_gen_br_table<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: MachLabel,
    arg2: &BoxVecMachLabel,
) -> Unit {
    let v3 = MInst::BrTable {
        idx: arg0,
        default: arg1,
        targets: arg2.clone(),
    };
    let v4 = C::emit(ctx, &v3);
    // Rule at src\isa\pulley_shared\inst.isle line 698.
    return v4;
}

// Generated as internal constructor for term load_ext_name_near.
pub fn constructor_load_ext_name_near<C: Context>(
    ctx: &mut C,
    arg0: BoxExternalName,
    arg1: i64,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::LoadExtNameNear {
        dst: v2,
        name: arg0,
        offset: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src\isa\pulley_shared\inst.isle line 703.
    return v5;
}

// Generated as internal constructor for term load_ext_name_far.
pub fn constructor_load_ext_name_far<C: Context>(
    ctx: &mut C,
    arg0: BoxExternalName,
    arg1: i64,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = MInst::LoadExtNameFar {
        dst: v2,
        name: arg0,
        offset: arg1,
    };
    let v4 = C::emit(ctx, &v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src\isa\pulley_shared\inst.isle line 710.
    return v5;
}

// Generated as internal constructor for term load_ext_name.
pub fn constructor_load_ext_name<C: Context>(
    ctx: &mut C,
    arg0: BoxExternalName,
    arg1: i64,
    arg2: &RelocDistance,
) -> XReg {
    match arg2 {
        &RelocDistance::Near => {
            let v3 = constructor_load_ext_name_near(ctx, arg0, arg1);
            // Rule at src\isa\pulley_shared\inst.isle line 717.
            return v3;
        }
        &RelocDistance::Far => {
            let v4 = constructor_load_ext_name_far(ctx, arg0, arg1);
            // Rule at src\isa\pulley_shared\inst.isle line 719.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "load_ext_name", "src\\isa\\pulley_shared\\inst.isle line 716")
}

// Generated as internal constructor for term call_impl.
pub fn constructor_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxCallInfo,
) -> SideEffectNoResult {
    let v1 = MInst::Call {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 741.
    return v2;
}

// Generated as internal constructor for term indirect_call_impl.
pub fn constructor_indirect_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxCallIndInfo,
) -> SideEffectNoResult {
    let v1 = MInst::IndirectCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 746.
    return v2;
}

// Generated as internal constructor for term indirect_call_host_impl.
pub fn constructor_indirect_call_host_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxCallIndirectHostInfo,
) -> SideEffectNoResult {
    let v1 = MInst::IndirectCallHost {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 751.
    return v2;
}

// Generated as internal constructor for term patchable_call_impl.
pub fn constructor_patchable_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxCallInfo,
) -> SideEffectNoResult {
    let v1 = MInst::PatchableCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 756.
    return v2;
}

// Generated as internal constructor for term return_call_impl.
pub fn constructor_return_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxReturnCallInfo,
) -> SideEffectNoResult {
    let v1 = MInst::ReturnCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 761.
    return v2;
}

// Generated as internal constructor for term return_indirect_call_impl.
pub fn constructor_return_indirect_call_impl<C: Context>(
    ctx: &mut C,
    arg0: BoxReturnCallIndInfo,
) -> SideEffectNoResult {
    let v1 = MInst::ReturnIndirectCall {
        info: arg0,
    };
    let v2 = SideEffectNoResult::Inst {
        inst: v1,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 766.
    return v2;
}

// Generated as internal constructor for term zext32.
pub fn constructor_zext32<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_zext8(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 773.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_zext16(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 774.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src\isa\pulley_shared\inst.isle line 775.
            return v2;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src\isa\pulley_shared\inst.isle line 776.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "zext32", "src\\isa\\pulley_shared\\inst.isle line 772")
}

// Generated as internal constructor for term sext32.
pub fn constructor_sext32<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_sext8(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 780.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_sext16(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 781.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src\isa\pulley_shared\inst.isle line 782.
            return v2;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src\isa\pulley_shared\inst.isle line 783.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sext32", "src\\isa\\pulley_shared\\inst.isle line 779")
}

// Generated as internal constructor for term zext64.
pub fn constructor_zext64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_zext8(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 787.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_zext16(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 788.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v5 = constructor_pulley_zext32(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 789.
            return v5;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src\isa\pulley_shared\inst.isle line 790.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "zext64", "src\\isa\\pulley_shared\\inst.isle line 786")
}

// Generated as internal constructor for term sext64.
pub fn constructor_sext64<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> XReg {
    let v1 = C::value_type(ctx, arg0);
    match v1 {
        I8 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v3 = constructor_pulley_sext8(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 794.
            return v3;
        }
        I16 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v4 = constructor_pulley_sext16(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 795.
            return v4;
        }
        I32 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            let v5 = constructor_pulley_sext32(ctx, v2);
            // Rule at src\isa\pulley_shared\inst.isle line 796.
            return v5;
        }
        I64 => {
            let v2 = constructor_put_in_xreg(ctx, arg0);
            // Rule at src\isa\pulley_shared\inst.isle line 797.
            return v2;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "sext64", "src\\isa\\pulley_shared\\inst.isle line 793")
}

// Generated as internal constructor for term pulley_label_address.
pub fn constructor_pulley_label_address<C: Context>(
    ctx: &mut C,
    arg0: MachLabel,
) -> Reg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = C::writable_xreg_to_writable_reg(ctx, v1);
    let v3 = C::writable_xreg_new(ctx, v2);
    let v4 = MInst::LabelAddress {
        dst: v3,
        label: arg0,
    };
    let v5 = C::emit(ctx, &v4);
    let v6 = C::writable_reg_to_reg(ctx, v2);
    // Rule at src\isa\pulley_shared\inst.isle line 801.
    return v6;
}

// Generated as internal constructor for term pulley_sequence_point.
pub fn constructor_pulley_sequence_point<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = SideEffectNoResult::Inst {
        inst: MInst::SequencePoint,
    };
    // Rule at src\isa\pulley_shared\inst.isle line 808.
    return v1;
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(
    ctx: &mut C,
    arg0: Inst,
) -> Option<InstOutput> {
    let v1 = &C::inst_data_value(ctx, arg0);
    match v1 {
        &InstructionData::Binary {
            opcode: ref v132,
            args: ref v133,
        } => {
            match v132 {
                &Opcode::Swizzle => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I8X16 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v1619 = constructor_pulley_vswizzlei8x16(ctx, v200, v201);
                            let v1620 = constructor_output_vreg(ctx, v1619);
                            let v1621 = Some(v1620);
                            // Rule at src\isa\pulley_shared\lower.isle line 1838.
                            return v1621;
                        }
                    }
                }
                &Opcode::Smin => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v683 = constructor_pulley_xmin64_s(ctx, v137, v138);
                                let v684 = constructor_output_xreg(ctx, v683);
                                let v685 = Some(v684);
                                // Rule at src\isa\pulley_shared\lower.isle line 679.
                                return v685;
                            }
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v686 = constructor_pulley_vmin8x16_s(ctx, v200, v201);
                                let v687 = constructor_output_vreg(ctx, v686);
                                let v688 = Some(v687);
                                // Rule at src\isa\pulley_shared\lower.isle line 680.
                                return v688;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v689 = constructor_pulley_vmin16x8_s(ctx, v200, v201);
                                let v690 = constructor_output_vreg(ctx, v689);
                                let v691 = Some(v690);
                                // Rule at src\isa\pulley_shared\lower.isle line 681.
                                return v691;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v692 = constructor_pulley_vmin32x4_s(ctx, v200, v201);
                                let v693 = constructor_output_vreg(ctx, v692);
                                let v694 = Some(v693);
                                // Rule at src\isa\pulley_shared\lower.isle line 682.
                                return v694;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v426 = constructor_sext32(ctx, v134.0);
                            let v427 = constructor_sext32(ctx, v134.1);
                            let v680 = constructor_pulley_xmin32_s(ctx, v426, v427);
                            let v681 = constructor_output_xreg(ctx, v680);
                            let v682 = Some(v681);
                            // Rule at src\isa\pulley_shared\lower.isle line 677.
                            return v682;
                        }
                    }
                }
                &Opcode::Umin => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v668 = constructor_pulley_xmin64_u(ctx, v137, v138);
                                let v669 = constructor_output_xreg(ctx, v668);
                                let v670 = Some(v669);
                                // Rule at src\isa\pulley_shared\lower.isle line 670.
                                return v670;
                            }
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v671 = constructor_pulley_vmin8x16_u(ctx, v200, v201);
                                let v672 = constructor_output_vreg(ctx, v671);
                                let v673 = Some(v672);
                                // Rule at src\isa\pulley_shared\lower.isle line 671.
                                return v673;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v674 = constructor_pulley_vmin16x8_u(ctx, v200, v201);
                                let v675 = constructor_output_vreg(ctx, v674);
                                let v676 = Some(v675);
                                // Rule at src\isa\pulley_shared\lower.isle line 672.
                                return v676;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v677 = constructor_pulley_vmin32x4_u(ctx, v200, v201);
                                let v678 = constructor_output_vreg(ctx, v677);
                                let v679 = Some(v678);
                                // Rule at src\isa\pulley_shared\lower.isle line 673.
                                return v679;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v398 = constructor_zext32(ctx, v134.0);
                            let v399 = constructor_zext32(ctx, v134.1);
                            let v665 = constructor_pulley_xmin32_u(ctx, v398, v399);
                            let v666 = constructor_output_xreg(ctx, v665);
                            let v667 = Some(v666);
                            // Rule at src\isa\pulley_shared\lower.isle line 668.
                            return v667;
                        }
                    }
                }
                &Opcode::Smax => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v713 = constructor_pulley_xmax64_s(ctx, v137, v138);
                                let v714 = constructor_output_xreg(ctx, v713);
                                let v715 = Some(v714);
                                // Rule at src\isa\pulley_shared\lower.isle line 697.
                                return v715;
                            }
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v716 = constructor_pulley_vmax8x16_s(ctx, v200, v201);
                                let v717 = constructor_output_vreg(ctx, v716);
                                let v718 = Some(v717);
                                // Rule at src\isa\pulley_shared\lower.isle line 698.
                                return v718;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v719 = constructor_pulley_vmax16x8_s(ctx, v200, v201);
                                let v720 = constructor_output_vreg(ctx, v719);
                                let v721 = Some(v720);
                                // Rule at src\isa\pulley_shared\lower.isle line 699.
                                return v721;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v722 = constructor_pulley_vmax32x4_s(ctx, v200, v201);
                                let v723 = constructor_output_vreg(ctx, v722);
                                let v724 = Some(v723);
                                // Rule at src\isa\pulley_shared\lower.isle line 700.
                                return v724;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v426 = constructor_sext32(ctx, v134.0);
                            let v427 = constructor_sext32(ctx, v134.1);
                            let v710 = constructor_pulley_xmax32_s(ctx, v426, v427);
                            let v711 = constructor_output_xreg(ctx, v710);
                            let v712 = Some(v711);
                            // Rule at src\isa\pulley_shared\lower.isle line 695.
                            return v712;
                        }
                    }
                }
                &Opcode::Umax => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v698 = constructor_pulley_xmax64_u(ctx, v137, v138);
                                let v699 = constructor_output_xreg(ctx, v698);
                                let v700 = Some(v699);
                                // Rule at src\isa\pulley_shared\lower.isle line 688.
                                return v700;
                            }
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v701 = constructor_pulley_vmax8x16_u(ctx, v200, v201);
                                let v702 = constructor_output_vreg(ctx, v701);
                                let v703 = Some(v702);
                                // Rule at src\isa\pulley_shared\lower.isle line 689.
                                return v703;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v704 = constructor_pulley_vmax16x8_u(ctx, v200, v201);
                                let v705 = constructor_output_vreg(ctx, v704);
                                let v706 = Some(v705);
                                // Rule at src\isa\pulley_shared\lower.isle line 690.
                                return v706;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v707 = constructor_pulley_vmax32x4_u(ctx, v200, v201);
                                let v708 = constructor_output_vreg(ctx, v707);
                                let v709 = Some(v708);
                                // Rule at src\isa\pulley_shared\lower.isle line 691.
                                return v709;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v398 = constructor_zext32(ctx, v134.0);
                            let v399 = constructor_zext32(ctx, v134.1);
                            let v695 = constructor_pulley_xmax32_u(ctx, v398, v399);
                            let v696 = constructor_output_xreg(ctx, v695);
                            let v697 = Some(v696);
                            // Rule at src\isa\pulley_shared\lower.isle line 686.
                            return v697;
                        }
                    }
                }
                &Opcode::AvgRound => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v473 = constructor_pulley_vavground8x16(ctx, v200, v201);
                                let v474 = constructor_output_vreg(ctx, v473);
                                let v475 = Some(v474);
                                // Rule at src\isa\pulley_shared\lower.isle line 499.
                                return v475;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v476 = constructor_pulley_vavground16x8(ctx, v200, v201);
                                let v477 = constructor_output_vreg(ctx, v476);
                                let v478 = Some(v477);
                                // Rule at src\isa\pulley_shared\lower.isle line 500.
                                return v478;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::UaddSat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v217 = constructor_pulley_vaddu8x16_sat(ctx, v200, v201);
                                let v218 = constructor_output_vreg(ctx, v217);
                                let v219 = Some(v218);
                                // Rule at src\isa\pulley_shared\lower.isle line 315.
                                return v219;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v223 = constructor_pulley_vaddu16x8_sat(ctx, v200, v201);
                                let v224 = constructor_output_vreg(ctx, v223);
                                let v225 = Some(v224);
                                // Rule at src\isa\pulley_shared\lower.isle line 317.
                                return v225;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::SaddSat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v214 = constructor_pulley_vaddi8x16_sat(ctx, v200, v201);
                                let v215 = constructor_output_vreg(ctx, v214);
                                let v216 = Some(v215);
                                // Rule at src\isa\pulley_shared\lower.isle line 314.
                                return v216;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v220 = constructor_pulley_vaddi16x8_sat(ctx, v200, v201);
                                let v221 = constructor_output_vreg(ctx, v220);
                                let v222 = Some(v221);
                                // Rule at src\isa\pulley_shared\lower.isle line 316.
                                return v222;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::UsubSat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v311 = constructor_pulley_vsubu8x16_sat(ctx, v200, v201);
                                let v312 = constructor_output_vreg(ctx, v311);
                                let v313 = Some(v312);
                                // Rule at src\isa\pulley_shared\lower.isle line 378.
                                return v313;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v317 = constructor_pulley_vsubu16x8_sat(ctx, v200, v201);
                                let v318 = constructor_output_vreg(ctx, v317);
                                let v319 = Some(v318);
                                // Rule at src\isa\pulley_shared\lower.isle line 380.
                                return v319;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::SsubSat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v308 = constructor_pulley_vsubi8x16_sat(ctx, v200, v201);
                                let v309 = constructor_output_vreg(ctx, v308);
                                let v310 = Some(v309);
                                // Rule at src\isa\pulley_shared\lower.isle line 377.
                                return v310;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v314 = constructor_pulley_vsubi16x8_sat(ctx, v200, v201);
                                let v315 = constructor_output_vreg(ctx, v314);
                                let v316 = Some(v315);
                                // Rule at src\isa\pulley_shared\lower.isle line 379.
                                return v316;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Iadd => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v134 = C::unpack_value_array_2(ctx, v133);
                        let v177 = constructor_u8_from_negated_iconst(ctx, v134.1);
                        if let Some(v178) = v177 {
                            let v109 = C::value_type(ctx, v108);
                            if v109 == I64 {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v182 = constructor_pulley_xsub64_u8(ctx, v137, v178);
                                let v183 = constructor_output_xreg(ctx, v182);
                                let v184 = Some(v183);
                                // Rule at src\isa\pulley_shared\lower.isle line 278.
                                return v184;
                            }
                            let v128 = C::ty_int(ctx, v109);
                            if let Some(v129) = v128 {
                                let v145 = C::fits_in_32(ctx, v129);
                                if let Some(v146) = v145 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v179 = constructor_pulley_xsub32_u8(ctx, v137, v178);
                                    let v180 = constructor_output_xreg(ctx, v179);
                                    let v181 = Some(v180);
                                    // Rule at src\isa\pulley_shared\lower.isle line 275.
                                    return v181;
                                }
                            }
                        }
                        let v169 = constructor_u32_from_negated_iconst(ctx, v134.1);
                        if let Some(v170) = v169 {
                            let v109 = C::value_type(ctx, v108);
                            if v109 == I64 {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v174 = constructor_pulley_xsub64_u32(ctx, v137, v170);
                                let v175 = constructor_output_xreg(ctx, v174);
                                let v176 = Some(v175);
                                // Rule at src\isa\pulley_shared\lower.isle line 272.
                                return v176;
                            }
                            let v128 = C::ty_int(ctx, v109);
                            if let Some(v129) = v128 {
                                let v145 = C::fits_in_32(ctx, v129);
                                if let Some(v146) = v145 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v171 = constructor_pulley_xsub32_u32(ctx, v137, v170);
                                    let v172 = constructor_output_xreg(ctx, v171);
                                    let v173 = Some(v172);
                                    // Rule at src\isa\pulley_shared\lower.isle line 269.
                                    return v173;
                                }
                            }
                        }
                        let v147 = C::def_inst(ctx, v134.1);
                        if let Some(v148) = v147 {
                            let v149 = &C::inst_data_value(ctx, v148);
                            match v149 {
                                &InstructionData::Binary {
                                    opcode: ref v240,
                                    args: ref v241,
                                } => {
                                    if let &Opcode::Imul = v240 {
                                        let v109 = C::value_type(ctx, v108);
                                        match v109 {
                                            I32 => {
                                                let v242 = C::unpack_value_array_2(ctx, v241);
                                                let v245 = constructor_put_in_xreg(ctx, v242.0);
                                                let v246 = constructor_put_in_xreg(ctx, v242.1);
                                                let v247 = constructor_put_in_xreg(ctx, v134.0);
                                                let v248 = constructor_pulley_xmadd32(ctx, v245, v246, v247);
                                                let v249 = constructor_output_xreg(ctx, v248);
                                                let v250 = Some(v249);
                                                // Rule at src\isa\pulley_shared\lower.isle line 322.
                                                return v250;
                                            }
                                            I64 => {
                                                let v242 = C::unpack_value_array_2(ctx, v241);
                                                let v245 = constructor_put_in_xreg(ctx, v242.0);
                                                let v246 = constructor_put_in_xreg(ctx, v242.1);
                                                let v247 = constructor_put_in_xreg(ctx, v134.0);
                                                let v254 = constructor_pulley_xmadd64(ctx, v245, v246, v247);
                                                let v255 = constructor_output_xreg(ctx, v254);
                                                let v256 = Some(v255);
                                                // Rule at src\isa\pulley_shared\lower.isle line 324.
                                                return v256;
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v150,
                                    imm: v151,
                                } => {
                                    if let &Opcode::Iconst = v150 {
                                        let v109 = C::value_type(ctx, v108);
                                        if v109 == I64 {
                                            let v152 = C::u64_from_imm64(ctx, v151);
                                            let v158 = C::u64_from_u8(ctx, v152);
                                            if let Some(v159) = v158 {
                                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                                let v166 = constructor_pulley_xadd64_u8(ctx, v137, v159);
                                                let v167 = constructor_output_xreg(ctx, v166);
                                                let v168 = Some(v167);
                                                // Rule at src\isa\pulley_shared\lower.isle line 264.
                                                return v168;
                                            }
                                            let v153 = C::u64_from_u32(ctx, v152);
                                            if let Some(v154) = v153 {
                                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                                let v163 = constructor_pulley_xadd64_u32(ctx, v137, v154);
                                                let v164 = constructor_output_xreg(ctx, v163);
                                                let v165 = Some(v164);
                                                // Rule at src\isa\pulley_shared\lower.isle line 262.
                                                return v165;
                                            }
                                        }
                                        let v128 = C::ty_int(ctx, v109);
                                        if let Some(v129) = v128 {
                                            let v145 = C::fits_in_32(ctx, v129);
                                            if let Some(v146) = v145 {
                                                let v152 = C::u64_from_imm64(ctx, v151);
                                                let v158 = C::u64_from_u8(ctx, v152);
                                                if let Some(v159) = v158 {
                                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                                    let v160 = constructor_pulley_xadd32_u8(ctx, v137, v159);
                                                    let v161 = constructor_output_xreg(ctx, v160);
                                                    let v162 = Some(v161);
                                                    // Rule at src\isa\pulley_shared\lower.isle line 260.
                                                    return v162;
                                                }
                                                let v153 = C::u64_from_u32(ctx, v152);
                                                if let Some(v154) = v153 {
                                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                                    let v155 = constructor_pulley_xadd32_u32(ctx, v137, v154);
                                                    let v156 = constructor_output_xreg(ctx, v155);
                                                    let v157 = Some(v156);
                                                    // Rule at src\isa\pulley_shared\lower.isle line 258.
                                                    return v157;
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v226 = C::def_inst(ctx, v134.0);
                                if let Some(v227) = v226 {
                                    let v228 = &C::inst_data_value(ctx, v227);
                                    if let &InstructionData::Binary {
                                        opcode: ref v229,
                                        args: ref v230,
                                    } = v228 {
                                        if let &Opcode::Imul = v229 {
                                            let v231 = C::unpack_value_array_2(ctx, v230);
                                            let v234 = constructor_put_in_xreg(ctx, v231.0);
                                            let v235 = constructor_put_in_xreg(ctx, v231.1);
                                            let v236 = constructor_put_in_xreg(ctx, v134.1);
                                            let v237 = constructor_pulley_xmadd32(ctx, v234, v235, v236);
                                            let v238 = constructor_output_xreg(ctx, v237);
                                            let v239 = Some(v238);
                                            // Rule at src\isa\pulley_shared\lower.isle line 321.
                                            return v239;
                                        }
                                    }
                                }
                            }
                            I64 => {
                                let v226 = C::def_inst(ctx, v134.0);
                                if let Some(v227) = v226 {
                                    let v228 = &C::inst_data_value(ctx, v227);
                                    if let &InstructionData::Binary {
                                        opcode: ref v229,
                                        args: ref v230,
                                    } = v228 {
                                        if let &Opcode::Imul = v229 {
                                            let v231 = C::unpack_value_array_2(ctx, v230);
                                            let v234 = constructor_put_in_xreg(ctx, v231.0);
                                            let v235 = constructor_put_in_xreg(ctx, v231.1);
                                            let v236 = constructor_put_in_xreg(ctx, v134.1);
                                            let v251 = constructor_pulley_xmadd64(ctx, v234, v235, v236);
                                            let v252 = constructor_output_xreg(ctx, v251);
                                            let v253 = Some(v252);
                                            // Rule at src\isa\pulley_shared\lower.isle line 323.
                                            return v253;
                                        }
                                    }
                                }
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v142 = constructor_pulley_xadd64(ctx, v137, v138);
                                let v143 = constructor_output_xreg(ctx, v142);
                                let v144 = Some(v143);
                                // Rule at src\isa\pulley_shared\lower.isle line 255.
                                return v144;
                            }
                            I128 => {
                                let v185 = C::put_in_regs(ctx, v134.0);
                                let v186 = C::put_in_regs(ctx, v134.1);
                                let v188 = C::value_regs_get(ctx, v185, 0x0_usize);
                                let v189 = C::xreg_new(ctx, v188);
                                let v191 = C::value_regs_get(ctx, v185, 0x1_usize);
                                let v192 = C::xreg_new(ctx, v191);
                                let v193 = C::value_regs_get(ctx, v186, 0x0_usize);
                                let v194 = C::xreg_new(ctx, v193);
                                let v195 = C::value_regs_get(ctx, v186, 0x1_usize);
                                let v196 = C::xreg_new(ctx, v195);
                                let v197 = constructor_pulley_xadd128(ctx, v189, v192, v194, v196);
                                let v198 = C::output(ctx, v197);
                                let v199 = Some(v198);
                                // Rule at src\isa\pulley_shared\lower.isle line 299.
                                return v199;
                            }
                            I8X16 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v202 = constructor_pulley_vaddi8x16(ctx, v200, v201);
                                let v203 = constructor_output_vreg(ctx, v202);
                                let v204 = Some(v203);
                                // Rule at src\isa\pulley_shared\lower.isle line 309.
                                return v204;
                            }
                            I16X8 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v205 = constructor_pulley_vaddi16x8(ctx, v200, v201);
                                let v206 = constructor_output_vreg(ctx, v205);
                                let v207 = Some(v206);
                                // Rule at src\isa\pulley_shared\lower.isle line 310.
                                return v207;
                            }
                            I32X4 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v208 = constructor_pulley_vaddi32x4(ctx, v200, v201);
                                let v209 = constructor_output_vreg(ctx, v208);
                                let v210 = Some(v209);
                                // Rule at src\isa\pulley_shared\lower.isle line 311.
                                return v210;
                            }
                            I64X2 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v211 = constructor_pulley_vaddi64x2(ctx, v200, v201);
                                let v212 = constructor_output_vreg(ctx, v211);
                                let v213 = Some(v212);
                                // Rule at src\isa\pulley_shared\lower.isle line 312.
                                return v213;
                            }
                            _ => {}
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v130 = C::fits_in_64(ctx, v129);
                            if let Some(v131) = v130 {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v139 = constructor_pulley_xadd32(ctx, v137, v138);
                                let v140 = constructor_output_xreg(ctx, v139);
                                let v141 = Some(v140);
                                // Rule at src\isa\pulley_shared\lower.isle line 254.
                                return v141;
                            }
                        }
                    }
                }
                &Opcode::Isub => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v134 = C::unpack_value_array_2(ctx, v133);
                        let v177 = constructor_u8_from_negated_iconst(ctx, v134.1);
                        if let Some(v178) = v177 {
                            let v109 = C::value_type(ctx, v108);
                            if v109 == I64 {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v290 = constructor_pulley_xadd64_u8(ctx, v137, v178);
                                let v291 = constructor_output_xreg(ctx, v290);
                                let v292 = Some(v291);
                                // Rule at src\isa\pulley_shared\lower.isle line 357.
                                return v292;
                            }
                            let v128 = C::ty_int(ctx, v109);
                            if let Some(v129) = v128 {
                                let v145 = C::fits_in_32(ctx, v129);
                                if let Some(v146) = v145 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v287 = constructor_pulley_xadd32_u8(ctx, v137, v178);
                                    let v288 = constructor_output_xreg(ctx, v287);
                                    let v289 = Some(v288);
                                    // Rule at src\isa\pulley_shared\lower.isle line 354.
                                    return v289;
                                }
                            }
                        }
                        let v169 = constructor_u32_from_negated_iconst(ctx, v134.1);
                        if let Some(v170) = v169 {
                            let v109 = C::value_type(ctx, v108);
                            if v109 == I64 {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v284 = constructor_pulley_xadd64_u32(ctx, v137, v170);
                                let v285 = constructor_output_xreg(ctx, v284);
                                let v286 = Some(v285);
                                // Rule at src\isa\pulley_shared\lower.isle line 351.
                                return v286;
                            }
                            let v128 = C::ty_int(ctx, v109);
                            if let Some(v129) = v128 {
                                let v145 = C::fits_in_32(ctx, v129);
                                if let Some(v146) = v145 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v281 = constructor_pulley_xadd32_u32(ctx, v137, v170);
                                    let v282 = constructor_output_xreg(ctx, v281);
                                    let v283 = Some(v282);
                                    // Rule at src\isa\pulley_shared\lower.isle line 348.
                                    return v283;
                                }
                            }
                        }
                        let v147 = C::def_inst(ctx, v134.1);
                        if let Some(v148) = v147 {
                            let v149 = &C::inst_data_value(ctx, v148);
                            if let &InstructionData::UnaryImm {
                                opcode: ref v150,
                                imm: v151,
                            } = v149 {
                                if let &Opcode::Iconst = v150 {
                                    let v109 = C::value_type(ctx, v108);
                                    if v109 == I64 {
                                        let v152 = C::u64_from_imm64(ctx, v151);
                                        let v158 = C::u64_from_u8(ctx, v152);
                                        if let Some(v159) = v158 {
                                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                                            let v278 = constructor_pulley_xsub64_u8(ctx, v137, v159);
                                            let v279 = constructor_output_xreg(ctx, v278);
                                            let v280 = Some(v279);
                                            // Rule at src\isa\pulley_shared\lower.isle line 343.
                                            return v280;
                                        }
                                        let v153 = C::u64_from_u32(ctx, v152);
                                        if let Some(v154) = v153 {
                                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                                            let v275 = constructor_pulley_xsub64_u32(ctx, v137, v154);
                                            let v276 = constructor_output_xreg(ctx, v275);
                                            let v277 = Some(v276);
                                            // Rule at src\isa\pulley_shared\lower.isle line 341.
                                            return v277;
                                        }
                                    }
                                    let v128 = C::ty_int(ctx, v109);
                                    if let Some(v129) = v128 {
                                        let v145 = C::fits_in_32(ctx, v129);
                                        if let Some(v146) = v145 {
                                            let v152 = C::u64_from_imm64(ctx, v151);
                                            let v158 = C::u64_from_u8(ctx, v152);
                                            if let Some(v159) = v158 {
                                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                                let v272 = constructor_pulley_xsub32_u8(ctx, v137, v159);
                                                let v273 = constructor_output_xreg(ctx, v272);
                                                let v274 = Some(v273);
                                                // Rule at src\isa\pulley_shared\lower.isle line 339.
                                                return v274;
                                            }
                                            let v153 = C::u64_from_u32(ctx, v152);
                                            if let Some(v154) = v153 {
                                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                                let v269 = constructor_pulley_xsub32_u32(ctx, v137, v154);
                                                let v270 = constructor_output_xreg(ctx, v269);
                                                let v271 = Some(v270);
                                                // Rule at src\isa\pulley_shared\lower.isle line 337.
                                                return v271;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v266 = constructor_pulley_xsub64(ctx, v137, v138);
                                let v267 = constructor_output_xreg(ctx, v266);
                                let v268 = Some(v267);
                                // Rule at src\isa\pulley_shared\lower.isle line 334.
                                return v268;
                            }
                            I128 => {
                                let v185 = C::put_in_regs(ctx, v134.0);
                                let v186 = C::put_in_regs(ctx, v134.1);
                                let v188 = C::value_regs_get(ctx, v185, 0x0_usize);
                                let v189 = C::xreg_new(ctx, v188);
                                let v191 = C::value_regs_get(ctx, v185, 0x1_usize);
                                let v192 = C::xreg_new(ctx, v191);
                                let v193 = C::value_regs_get(ctx, v186, 0x0_usize);
                                let v194 = C::xreg_new(ctx, v193);
                                let v195 = C::value_regs_get(ctx, v186, 0x1_usize);
                                let v196 = C::xreg_new(ctx, v195);
                                let v293 = constructor_pulley_xsub128(ctx, v189, v192, v194, v196);
                                let v294 = C::output(ctx, v293);
                                let v295 = Some(v294);
                                // Rule at src\isa\pulley_shared\lower.isle line 362.
                                return v295;
                            }
                            I8X16 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v296 = constructor_pulley_vsubi8x16(ctx, v200, v201);
                                let v297 = constructor_output_vreg(ctx, v296);
                                let v298 = Some(v297);
                                // Rule at src\isa\pulley_shared\lower.isle line 372.
                                return v298;
                            }
                            I16X8 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v299 = constructor_pulley_vsubi16x8(ctx, v200, v201);
                                let v300 = constructor_output_vreg(ctx, v299);
                                let v301 = Some(v300);
                                // Rule at src\isa\pulley_shared\lower.isle line 373.
                                return v301;
                            }
                            I32X4 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v302 = constructor_pulley_vsubi32x4(ctx, v200, v201);
                                let v303 = constructor_output_vreg(ctx, v302);
                                let v304 = Some(v303);
                                // Rule at src\isa\pulley_shared\lower.isle line 374.
                                return v304;
                            }
                            I64X2 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v305 = constructor_pulley_vsubi64x2(ctx, v200, v201);
                                let v306 = constructor_output_vreg(ctx, v305);
                                let v307 = Some(v306);
                                // Rule at src\isa\pulley_shared\lower.isle line 375.
                                return v307;
                            }
                            _ => {}
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v263 = constructor_pulley_xsub32(ctx, v137, v138);
                                let v264 = constructor_output_xreg(ctx, v263);
                                let v265 = Some(v264);
                                // Rule at src\isa\pulley_shared\lower.isle line 333.
                                return v265;
                            }
                        }
                    }
                }
                &Opcode::Imul => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v326 = C::i64_from_iconst(ctx, v134.1);
                                if let Some(v327) = v326 {
                                    let v336 = C::i64_from_i8(ctx, v327);
                                    if let Some(v337) = v336 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v341 = constructor_pulley_xmul64_s8(ctx, v137, v337);
                                        let v342 = constructor_output_xreg(ctx, v341);
                                        let v343 = Some(v342);
                                        // Rule at src\isa\pulley_shared\lower.isle line 395.
                                        return v343;
                                    }
                                }
                            }
                            I128 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v147 = C::def_inst(ctx, v134.1);
                                if let Some(v148) = v147 {
                                    let v149 = &C::inst_data_value(ctx, v148);
                                    if let &InstructionData::Unary {
                                        opcode: ref v346,
                                        arg: v347,
                                    } = v149 {
                                        match v346 {
                                            &Opcode::Uextend => {
                                                let v226 = C::def_inst(ctx, v134.0);
                                                if let Some(v227) = v226 {
                                                    let v228 = &C::inst_data_value(ctx, v227);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v344,
                                                        arg: v345,
                                                    } = v228 {
                                                        if let &Opcode::Uextend = v344 {
                                                            let v348 = constructor_zext64(ctx, v345);
                                                            let v349 = constructor_zext64(ctx, v347);
                                                            let v350 = constructor_pulley_xwidemul64_u(ctx, v348, v349);
                                                            let v351 = C::output(ctx, v350);
                                                            let v352 = Some(v351);
                                                            // Rule at src\isa\pulley_shared\lower.isle line 399.
                                                            return v352;
                                                        }
                                                    }
                                                }
                                            }
                                            &Opcode::Sextend => {
                                                let v226 = C::def_inst(ctx, v134.0);
                                                if let Some(v227) = v226 {
                                                    let v228 = &C::inst_data_value(ctx, v227);
                                                    if let &InstructionData::Unary {
                                                        opcode: ref v344,
                                                        arg: v345,
                                                    } = v228 {
                                                        if let &Opcode::Sextend = v344 {
                                                            let v353 = constructor_sext64(ctx, v345);
                                                            let v354 = constructor_sext64(ctx, v347);
                                                            let v355 = constructor_pulley_xwidemul64_s(ctx, v353, v354);
                                                            let v356 = C::output(ctx, v355);
                                                            let v357 = Some(v356);
                                                            // Rule at src\isa\pulley_shared\lower.isle line 401.
                                                            return v357;
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                        let v134 = C::unpack_value_array_2(ctx, v133);
                        let v326 = C::i64_from_iconst(ctx, v134.1);
                        if let Some(v327) = v326 {
                            let v128 = C::ty_int(ctx, v109);
                            if let Some(v129) = v128 {
                                let v145 = C::fits_in_32(ctx, v129);
                                if let Some(v146) = v145 {
                                    let v336 = C::i64_from_i8(ctx, v327);
                                    if let Some(v337) = v336 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v338 = constructor_pulley_xmul32_s8(ctx, v137, v337);
                                        let v339 = constructor_output_xreg(ctx, v338);
                                        let v340 = Some(v339);
                                        // Rule at src\isa\pulley_shared\lower.isle line 393.
                                        return v340;
                                    }
                                }
                            }
                            let v328 = C::i64_from_i32(ctx, v327);
                            if let Some(v329) = v328 {
                                if v109 == I64 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v333 = constructor_pulley_xmul64_s32(ctx, v137, v329);
                                    let v334 = constructor_output_xreg(ctx, v333);
                                    let v335 = Some(v334);
                                    // Rule at src\isa\pulley_shared\lower.isle line 391.
                                    return v335;
                                }
                                if let Some(v129) = v128 {
                                    let v145 = C::fits_in_32(ctx, v129);
                                    if let Some(v146) = v145 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v330 = constructor_pulley_xmul32_s32(ctx, v137, v329);
                                        let v331 = constructor_output_xreg(ctx, v330);
                                        let v332 = Some(v331);
                                        // Rule at src\isa\pulley_shared\lower.isle line 389.
                                        return v332;
                                    }
                                }
                            }
                        }
                        match v109 {
                            I8 => {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v320 = constructor_pulley_xmul32(ctx, v137, v138);
                                let v321 = constructor_output_xreg(ctx, v320);
                                let v322 = Some(v321);
                                // Rule at src\isa\pulley_shared\lower.isle line 384.
                                return v322;
                            }
                            I16 => {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v320 = constructor_pulley_xmul32(ctx, v137, v138);
                                let v321 = constructor_output_xreg(ctx, v320);
                                let v322 = Some(v321);
                                // Rule at src\isa\pulley_shared\lower.isle line 385.
                                return v322;
                            }
                            I32 => {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v320 = constructor_pulley_xmul32(ctx, v137, v138);
                                let v321 = constructor_output_xreg(ctx, v320);
                                let v322 = Some(v321);
                                // Rule at src\isa\pulley_shared\lower.isle line 386.
                                return v322;
                            }
                            I64 => {
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v323 = constructor_pulley_xmul64(ctx, v137, v138);
                                let v324 = constructor_output_xreg(ctx, v323);
                                let v325 = Some(v324);
                                // Rule at src\isa\pulley_shared\lower.isle line 387.
                                return v325;
                            }
                            I128 => {
                                let v185 = C::put_in_regs(ctx, v134.0);
                                let v358 = C::value_regs_get(ctx, v185, 0x0_usize);
                                let v359 = C::xreg_new(ctx, v358);
                                let v360 = C::value_regs_get(ctx, v185, 0x1_usize);
                                let v361 = C::xreg_new(ctx, v360);
                                let v362 = C::put_in_regs(ctx, v134.1);
                                let v363 = C::value_regs_get(ctx, v362, 0x0_usize);
                                let v364 = C::xreg_new(ctx, v363);
                                let v365 = C::value_regs_get(ctx, v362, 0x1_usize);
                                let v366 = C::xreg_new(ctx, v365);
                                let v367 = constructor_pulley_xwidemul64_u(ctx, v359, v364);
                                let v368 = C::value_regs_get(ctx, v367, 0x0_usize);
                                let v369 = C::xreg_new(ctx, v368);
                                let v370 = C::value_regs_get(ctx, v367, 0x1_usize);
                                let v371 = C::xreg_new(ctx, v370);
                                let v372 = constructor_pulley_xmul64(ctx, v359, v366);
                                let v373 = constructor_pulley_xmul64(ctx, v361, v364);
                                let v374 = constructor_pulley_xadd64(ctx, v371, v372);
                                let v375 = constructor_pulley_xadd64(ctx, v374, v373);
                                let v376 = C::xreg_to_reg(ctx, v369);
                                let v377 = C::xreg_to_reg(ctx, v375);
                                let v378 = C::value_regs(ctx, v376, v377);
                                let v379 = C::output(ctx, v378);
                                let v380 = Some(v379);
                                // Rule at src\isa\pulley_shared\lower.isle line 405.
                                return v380;
                            }
                            I8X16 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v381 = constructor_pulley_vmuli8x16(ctx, v200, v201);
                                let v382 = constructor_output_vreg(ctx, v381);
                                let v383 = Some(v382);
                                // Rule at src\isa\pulley_shared\lower.isle line 430.
                                return v383;
                            }
                            I16X8 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v384 = constructor_pulley_vmuli16x8(ctx, v200, v201);
                                let v385 = constructor_output_vreg(ctx, v384);
                                let v386 = Some(v385);
                                // Rule at src\isa\pulley_shared\lower.isle line 431.
                                return v386;
                            }
                            I32X4 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v387 = constructor_pulley_vmuli32x4(ctx, v200, v201);
                                let v388 = constructor_output_vreg(ctx, v387);
                                let v389 = Some(v388);
                                // Rule at src\isa\pulley_shared\lower.isle line 432.
                                return v389;
                            }
                            I64X2 => {
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v390 = constructor_pulley_vmuli64x2(ctx, v200, v201);
                                let v391 = constructor_output_vreg(ctx, v390);
                                let v392 = Some(v391);
                                // Rule at src\isa\pulley_shared\lower.isle line 433.
                                return v392;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Umulhi => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8 => {
                                let v394 = C::u64_try_into_u8(ctx, 0x8_u64);
                                if let Some(v395) = v394 {
                                    let v396 = C::u6_from_u8(ctx, v395);
                                    if let Some(v397) = v396 {
                                        let v134 = C::unpack_value_array_2(ctx, v133);
                                        let v398 = constructor_zext32(ctx, v134.0);
                                        let v399 = constructor_zext32(ctx, v134.1);
                                        let v400 = constructor_pulley_xmul32(ctx, v398, v399);
                                        let v401 = constructor_pulley_xshr32_u_u6(ctx, v400, v397);
                                        let v402 = constructor_output_xreg(ctx, v401);
                                        let v403 = Some(v402);
                                        // Rule at src\isa\pulley_shared\lower.isle line 437.
                                        return v403;
                                    }
                                }
                            }
                            I16 => {
                                let v405 = C::u64_try_into_u8(ctx, 0x10_u64);
                                if let Some(v406) = v405 {
                                    let v407 = C::u6_from_u8(ctx, v406);
                                    if let Some(v408) = v407 {
                                        let v134 = C::unpack_value_array_2(ctx, v133);
                                        let v398 = constructor_zext32(ctx, v134.0);
                                        let v399 = constructor_zext32(ctx, v134.1);
                                        let v400 = constructor_pulley_xmul32(ctx, v398, v399);
                                        let v409 = constructor_pulley_xshr32_u_u6(ctx, v400, v408);
                                        let v410 = constructor_output_xreg(ctx, v409);
                                        let v411 = Some(v410);
                                        // Rule at src\isa\pulley_shared\lower.isle line 441.
                                        return v411;
                                    }
                                }
                            }
                            I32 => {
                                let v413 = C::u64_try_into_u8(ctx, 0x20_u64);
                                if let Some(v414) = v413 {
                                    let v415 = C::u6_from_u8(ctx, v414);
                                    if let Some(v416) = v415 {
                                        let v134 = C::unpack_value_array_2(ctx, v133);
                                        let v417 = constructor_zext64(ctx, v134.0);
                                        let v418 = constructor_zext64(ctx, v134.1);
                                        let v419 = constructor_pulley_xmul64(ctx, v417, v418);
                                        let v420 = constructor_pulley_xshr64_u_u6(ctx, v419, v416);
                                        let v421 = constructor_output_xreg(ctx, v420);
                                        let v422 = Some(v421);
                                        // Rule at src\isa\pulley_shared\lower.isle line 445.
                                        return v422;
                                    }
                                }
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v423 = constructor_pulley_xmulhi64_u(ctx, v137, v138);
                                let v424 = constructor_output_xreg(ctx, v423);
                                let v425 = Some(v424);
                                // Rule at src\isa\pulley_shared\lower.isle line 449.
                                return v425;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Smulhi => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8 => {
                                let v394 = C::u64_try_into_u8(ctx, 0x8_u64);
                                if let Some(v395) = v394 {
                                    let v396 = C::u6_from_u8(ctx, v395);
                                    if let Some(v397) = v396 {
                                        let v134 = C::unpack_value_array_2(ctx, v133);
                                        let v426 = constructor_sext32(ctx, v134.0);
                                        let v427 = constructor_sext32(ctx, v134.1);
                                        let v428 = constructor_pulley_xmul32(ctx, v426, v427);
                                        let v429 = constructor_pulley_xshr32_s_u6(ctx, v428, v397);
                                        let v430 = constructor_output_xreg(ctx, v429);
                                        let v431 = Some(v430);
                                        // Rule at src\isa\pulley_shared\lower.isle line 454.
                                        return v431;
                                    }
                                }
                            }
                            I16 => {
                                let v405 = C::u64_try_into_u8(ctx, 0x10_u64);
                                if let Some(v406) = v405 {
                                    let v407 = C::u6_from_u8(ctx, v406);
                                    if let Some(v408) = v407 {
                                        let v134 = C::unpack_value_array_2(ctx, v133);
                                        let v426 = constructor_sext32(ctx, v134.0);
                                        let v427 = constructor_sext32(ctx, v134.1);
                                        let v428 = constructor_pulley_xmul32(ctx, v426, v427);
                                        let v432 = constructor_pulley_xshr32_s_u6(ctx, v428, v408);
                                        let v433 = constructor_output_xreg(ctx, v432);
                                        let v434 = Some(v433);
                                        // Rule at src\isa\pulley_shared\lower.isle line 458.
                                        return v434;
                                    }
                                }
                            }
                            I32 => {
                                let v413 = C::u64_try_into_u8(ctx, 0x20_u64);
                                if let Some(v414) = v413 {
                                    let v415 = C::u6_from_u8(ctx, v414);
                                    if let Some(v416) = v415 {
                                        let v134 = C::unpack_value_array_2(ctx, v133);
                                        let v435 = constructor_sext64(ctx, v134.0);
                                        let v436 = constructor_sext64(ctx, v134.1);
                                        let v437 = constructor_pulley_xmul64(ctx, v435, v436);
                                        let v438 = constructor_pulley_xshr64_s_u6(ctx, v437, v416);
                                        let v439 = constructor_output_xreg(ctx, v438);
                                        let v440 = Some(v439);
                                        // Rule at src\isa\pulley_shared\lower.isle line 462.
                                        return v440;
                                    }
                                }
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v441 = constructor_pulley_xmulhi64_s(ctx, v137, v138);
                                let v442 = constructor_output_xreg(ctx, v441);
                                let v443 = Some(v442);
                                // Rule at src\isa\pulley_shared\lower.isle line 466.
                                return v443;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::SqmulRoundSat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I16X8 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v444 = constructor_pulley_vqmulrsi16x8(ctx, v200, v201);
                            let v445 = constructor_output_vreg(ctx, v444);
                            let v446 = Some(v445);
                            // Rule at src\isa\pulley_shared\lower.isle line 471.
                            return v446;
                        }
                    }
                }
                &Opcode::Udiv => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v464 = constructor_pulley_xdiv64_u(ctx, v137, v138);
                            let v465 = constructor_output_xreg(ctx, v464);
                            let v466 = Some(v465);
                            // Rule at src\isa\pulley_shared\lower.isle line 489.
                            return v466;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v398 = constructor_zext32(ctx, v134.0);
                                let v399 = constructor_zext32(ctx, v134.1);
                                let v461 = constructor_pulley_xdiv32_u(ctx, v398, v399);
                                let v462 = constructor_output_xreg(ctx, v461);
                                let v463 = Some(v462);
                                // Rule at src\isa\pulley_shared\lower.isle line 487.
                                return v463;
                            }
                        }
                    }
                }
                &Opcode::Sdiv => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v452 = constructor_pulley_xdiv64_s(ctx, v137, v138);
                            let v453 = constructor_output_xreg(ctx, v452);
                            let v454 = Some(v453);
                            // Rule at src\isa\pulley_shared\lower.isle line 477.
                            return v454;
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v426 = constructor_sext32(ctx, v134.0);
                            let v427 = constructor_sext32(ctx, v134.1);
                            let v449 = constructor_pulley_xdiv32_s(ctx, v426, v427);
                            let v450 = constructor_output_xreg(ctx, v449);
                            let v451 = Some(v450);
                            // Rule at src\isa\pulley_shared\lower.isle line 475.
                            return v451;
                        }
                    }
                }
                &Opcode::Urem => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v470 = constructor_pulley_xrem64_u(ctx, v137, v138);
                            let v471 = constructor_output_xreg(ctx, v470);
                            let v472 = Some(v471);
                            // Rule at src\isa\pulley_shared\lower.isle line 495.
                            return v472;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v398 = constructor_zext32(ctx, v134.0);
                                let v399 = constructor_zext32(ctx, v134.1);
                                let v467 = constructor_pulley_xrem32_u(ctx, v398, v399);
                                let v468 = constructor_output_xreg(ctx, v467);
                                let v469 = Some(v468);
                                // Rule at src\isa\pulley_shared\lower.isle line 493.
                                return v469;
                            }
                        }
                    }
                }
                &Opcode::Srem => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v458 = constructor_pulley_xrem64_s(ctx, v137, v138);
                            let v459 = constructor_output_xreg(ctx, v458);
                            let v460 = Some(v459);
                            // Rule at src\isa\pulley_shared\lower.isle line 483.
                            return v460;
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v426 = constructor_sext32(ctx, v134.0);
                            let v427 = constructor_sext32(ctx, v134.1);
                            let v455 = constructor_pulley_xrem32_s(ctx, v426, v427);
                            let v456 = constructor_output_xreg(ctx, v455);
                            let v457 = Some(v456);
                            // Rule at src\isa\pulley_shared\lower.isle line 481.
                            return v457;
                        }
                    }
                }
                &Opcode::UaddOverflow => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v139 = constructor_pulley_xadd32(ctx, v137, v138);
                                let v1036 = constructor_put_in_xreg(ctx, v134.0);
                                let v1037 = constructor_pulley_xult32(ctx, v139, v1036);
                                let v1038 = C::xreg_to_reg(ctx, v139);
                                let v1039 = C::value_reg(ctx, v1038);
                                let v1040 = C::xreg_to_reg(ctx, v1037);
                                let v1041 = C::value_reg(ctx, v1040);
                                let v1042 = C::output_pair(ctx, v1039, v1041);
                                let v1043 = Some(v1042);
                                // Rule at src\isa\pulley_shared\lower.isle line 1356.
                                return v1043;
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v142 = constructor_pulley_xadd64(ctx, v137, v138);
                                let v1036 = constructor_put_in_xreg(ctx, v134.0);
                                let v1044 = constructor_pulley_xult64(ctx, v142, v1036);
                                let v1045 = C::xreg_to_reg(ctx, v142);
                                let v1046 = C::value_reg(ctx, v1045);
                                let v1047 = C::xreg_to_reg(ctx, v1044);
                                let v1048 = C::value_reg(ctx, v1047);
                                let v1049 = C::output_pair(ctx, v1046, v1048);
                                let v1050 = Some(v1049);
                                // Rule at src\isa\pulley_shared\lower.isle line 1361.
                                return v1050;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Band => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v134 = C::unpack_value_array_2(ctx, v133);
                        let v326 = C::i64_from_iconst(ctx, v134.1);
                        if let Some(v327) = v326 {
                            let v336 = C::i64_from_i8(ctx, v327);
                            if let Some(v337) = v336 {
                                let v109 = C::value_type(ctx, v108);
                                if v109 == I64 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v590 = constructor_pulley_xband64_s8(ctx, v137, v337);
                                    let v591 = constructor_output_xreg(ctx, v590);
                                    let v592 = Some(v591);
                                    // Rule at src\isa\pulley_shared\lower.isle line 610.
                                    return v592;
                                }
                                let v128 = C::ty_int(ctx, v109);
                                if let Some(v129) = v128 {
                                    let v145 = C::fits_in_32(ctx, v129);
                                    if let Some(v146) = v145 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v587 = constructor_pulley_xband32_s8(ctx, v137, v337);
                                        let v588 = constructor_output_xreg(ctx, v587);
                                        let v589 = Some(v588);
                                        // Rule at src\isa\pulley_shared\lower.isle line 608.
                                        return v589;
                                    }
                                }
                            }
                            let v328 = C::i64_from_i32(ctx, v327);
                            if let Some(v329) = v328 {
                                let v109 = C::value_type(ctx, v108);
                                if v109 == I64 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v584 = constructor_pulley_xband64_s32(ctx, v137, v329);
                                    let v585 = constructor_output_xreg(ctx, v584);
                                    let v586 = Some(v585);
                                    // Rule at src\isa\pulley_shared\lower.isle line 606.
                                    return v586;
                                }
                                let v128 = C::ty_int(ctx, v109);
                                if let Some(v129) = v128 {
                                    let v145 = C::fits_in_32(ctx, v129);
                                    if let Some(v146) = v145 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v581 = constructor_pulley_xband32_s32(ctx, v137, v329);
                                        let v582 = constructor_output_xreg(ctx, v581);
                                        let v583 = Some(v582);
                                        // Rule at src\isa\pulley_shared\lower.isle line 604.
                                        return v583;
                                    }
                                }
                            }
                        }
                        let v109 = C::value_type(ctx, v108);
                        let v593 = C::ty_vec128(ctx, v109);
                        if let Some(v594) = v593 {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v595 = constructor_pulley_vband128(ctx, v200, v201);
                            let v596 = constructor_output_vreg(ctx, v595);
                            let v597 = Some(v596);
                            // Rule at src\isa\pulley_shared\lower.isle line 613.
                            return v597;
                        }
                        if v109 == I64 {
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v578 = constructor_pulley_xband64(ctx, v137, v138);
                            let v579 = constructor_output_xreg(ctx, v578);
                            let v580 = Some(v579);
                            // Rule at src\isa\pulley_shared\lower.isle line 602.
                            return v580;
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v575 = constructor_pulley_xband32(ctx, v137, v138);
                            let v576 = constructor_output_xreg(ctx, v575);
                            let v577 = Some(v576);
                            // Rule at src\isa\pulley_shared\lower.isle line 601.
                            return v577;
                        }
                    }
                }
                &Opcode::Bor => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v134 = C::unpack_value_array_2(ctx, v133);
                        let v326 = C::i64_from_iconst(ctx, v134.1);
                        if let Some(v327) = v326 {
                            let v336 = C::i64_from_i8(ctx, v327);
                            if let Some(v337) = v336 {
                                let v109 = C::value_type(ctx, v108);
                                if v109 == I64 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v613 = constructor_pulley_xbor64_s8(ctx, v137, v337);
                                    let v614 = constructor_output_xreg(ctx, v613);
                                    let v615 = Some(v614);
                                    // Rule at src\isa\pulley_shared\lower.isle line 627.
                                    return v615;
                                }
                                let v128 = C::ty_int(ctx, v109);
                                if let Some(v129) = v128 {
                                    let v145 = C::fits_in_32(ctx, v129);
                                    if let Some(v146) = v145 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v610 = constructor_pulley_xbor32_s8(ctx, v137, v337);
                                        let v611 = constructor_output_xreg(ctx, v610);
                                        let v612 = Some(v611);
                                        // Rule at src\isa\pulley_shared\lower.isle line 625.
                                        return v612;
                                    }
                                }
                            }
                            let v328 = C::i64_from_i32(ctx, v327);
                            if let Some(v329) = v328 {
                                let v109 = C::value_type(ctx, v108);
                                if v109 == I64 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v607 = constructor_pulley_xbor64_s32(ctx, v137, v329);
                                    let v608 = constructor_output_xreg(ctx, v607);
                                    let v609 = Some(v608);
                                    // Rule at src\isa\pulley_shared\lower.isle line 623.
                                    return v609;
                                }
                                let v128 = C::ty_int(ctx, v109);
                                if let Some(v129) = v128 {
                                    let v145 = C::fits_in_32(ctx, v129);
                                    if let Some(v146) = v145 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v604 = constructor_pulley_xbor32_s32(ctx, v137, v329);
                                        let v605 = constructor_output_xreg(ctx, v604);
                                        let v606 = Some(v605);
                                        // Rule at src\isa\pulley_shared\lower.isle line 621.
                                        return v606;
                                    }
                                }
                            }
                        }
                        let v109 = C::value_type(ctx, v108);
                        let v593 = C::ty_vec128(ctx, v109);
                        if let Some(v594) = v593 {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v616 = constructor_pulley_vbor128(ctx, v200, v201);
                            let v617 = constructor_output_vreg(ctx, v616);
                            let v618 = Some(v617);
                            // Rule at src\isa\pulley_shared\lower.isle line 630.
                            return v618;
                        }
                        if v109 == I64 {
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v601 = constructor_pulley_xbor64(ctx, v137, v138);
                            let v602 = constructor_output_xreg(ctx, v601);
                            let v603 = Some(v602);
                            // Rule at src\isa\pulley_shared\lower.isle line 619.
                            return v603;
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v598 = constructor_pulley_xbor32(ctx, v137, v138);
                            let v599 = constructor_output_xreg(ctx, v598);
                            let v600 = Some(v599);
                            // Rule at src\isa\pulley_shared\lower.isle line 618.
                            return v600;
                        }
                    }
                }
                &Opcode::Bxor => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v134 = C::unpack_value_array_2(ctx, v133);
                        let v326 = C::i64_from_iconst(ctx, v134.1);
                        if let Some(v327) = v326 {
                            let v336 = C::i64_from_i8(ctx, v327);
                            if let Some(v337) = v336 {
                                let v109 = C::value_type(ctx, v108);
                                if v109 == I64 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v634 = constructor_pulley_xbxor64_s8(ctx, v137, v337);
                                    let v635 = constructor_output_xreg(ctx, v634);
                                    let v636 = Some(v635);
                                    // Rule at src\isa\pulley_shared\lower.isle line 644.
                                    return v636;
                                }
                                let v128 = C::ty_int(ctx, v109);
                                if let Some(v129) = v128 {
                                    let v145 = C::fits_in_32(ctx, v129);
                                    if let Some(v146) = v145 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v631 = constructor_pulley_xbxor32_s8(ctx, v137, v337);
                                        let v632 = constructor_output_xreg(ctx, v631);
                                        let v633 = Some(v632);
                                        // Rule at src\isa\pulley_shared\lower.isle line 642.
                                        return v633;
                                    }
                                }
                            }
                            let v328 = C::i64_from_i32(ctx, v327);
                            if let Some(v329) = v328 {
                                let v109 = C::value_type(ctx, v108);
                                if v109 == I64 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v628 = constructor_pulley_xbxor64_s32(ctx, v137, v329);
                                    let v629 = constructor_output_xreg(ctx, v628);
                                    let v630 = Some(v629);
                                    // Rule at src\isa\pulley_shared\lower.isle line 640.
                                    return v630;
                                }
                                let v128 = C::ty_int(ctx, v109);
                                if let Some(v129) = v128 {
                                    let v145 = C::fits_in_32(ctx, v129);
                                    if let Some(v146) = v145 {
                                        let v137 = constructor_put_in_xreg(ctx, v134.0);
                                        let v625 = constructor_pulley_xbxor32_s32(ctx, v137, v329);
                                        let v626 = constructor_output_xreg(ctx, v625);
                                        let v627 = Some(v626);
                                        // Rule at src\isa\pulley_shared\lower.isle line 638.
                                        return v627;
                                    }
                                }
                            }
                        }
                        let v109 = C::value_type(ctx, v108);
                        let v593 = C::ty_vec128(ctx, v109);
                        if let Some(v594) = v593 {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v637 = constructor_pulley_vbxor128(ctx, v200, v201);
                            let v638 = constructor_output_vreg(ctx, v637);
                            let v639 = Some(v638);
                            // Rule at src\isa\pulley_shared\lower.isle line 647.
                            return v639;
                        }
                        if v109 == I64 {
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v622 = constructor_pulley_xbxor64(ctx, v137, v138);
                            let v623 = constructor_output_xreg(ctx, v622);
                            let v624 = Some(v623);
                            // Rule at src\isa\pulley_shared\lower.isle line 636.
                            return v624;
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v137 = constructor_put_in_xreg(ctx, v134.0);
                            let v138 = constructor_put_in_xreg(ctx, v134.1);
                            let v619 = constructor_pulley_xbxor32(ctx, v137, v138);
                            let v620 = constructor_output_xreg(ctx, v619);
                            let v621 = Some(v620);
                            // Rule at src\isa\pulley_shared\lower.isle line 635.
                            return v621;
                        }
                    }
                }
                &Opcode::Rotl => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v779 = constructor_pulley_xrotl32(ctx, v137, v138);
                                let v780 = constructor_output_xreg(ctx, v779);
                                let v781 = Some(v780);
                                // Rule at src\isa\pulley_shared\lower.isle line 737.
                                return v781;
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v782 = constructor_pulley_xrotl64(ctx, v137, v138);
                                let v783 = constructor_output_xreg(ctx, v782);
                                let v784 = Some(v783);
                                // Rule at src\isa\pulley_shared\lower.isle line 738.
                                return v784;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Rotr => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v785 = constructor_pulley_xrotr32(ctx, v137, v138);
                                let v786 = constructor_output_xreg(ctx, v785);
                                let v787 = Some(v786);
                                // Rule at src\isa\pulley_shared\lower.isle line 742.
                                return v787;
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v788 = constructor_pulley_xrotr64(ctx, v137, v138);
                                let v789 = constructor_output_xreg(ctx, v788);
                                let v790 = Some(v789);
                                // Rule at src\isa\pulley_shared\lower.isle line 743.
                                return v790;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ishl => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v480 = constructor_pulley_xband32_s8(ctx, v138, 7_i8);
                                let v481 = constructor_pulley_xshl32(ctx, v137, v480);
                                let v482 = constructor_output_xreg(ctx, v481);
                                let v483 = Some(v482);
                                // Rule at src\isa\pulley_shared\lower.isle line 504.
                                return v483;
                            }
                            I16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v485 = constructor_pulley_xband32_s8(ctx, v138, 15_i8);
                                let v486 = constructor_pulley_xshl32(ctx, v137, v485);
                                let v487 = constructor_output_xreg(ctx, v486);
                                let v488 = Some(v487);
                                // Rule at src\isa\pulley_shared\lower.isle line 507.
                                return v488;
                            }
                            I32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v495 = constructor_u6_shift_from_iconst(ctx, v134.1);
                                if let Some(v496) = v495 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v497 = constructor_pulley_xshl32_u6(ctx, v137, v496);
                                    let v498 = constructor_output_xreg(ctx, v497);
                                    let v499 = Some(v498);
                                    // Rule at src\isa\pulley_shared\lower.isle line 517.
                                    return v499;
                                }
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v489 = constructor_pulley_xshl32(ctx, v137, v138);
                                let v490 = constructor_output_xreg(ctx, v489);
                                let v491 = Some(v490);
                                // Rule at src\isa\pulley_shared\lower.isle line 510.
                                return v491;
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v495 = constructor_u6_shift_from_iconst(ctx, v134.1);
                                if let Some(v496) = v495 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v500 = constructor_pulley_xshl64_u6(ctx, v137, v496);
                                    let v501 = constructor_output_xreg(ctx, v500);
                                    let v502 = Some(v501);
                                    // Rule at src\isa\pulley_shared\lower.isle line 520.
                                    return v502;
                                }
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v492 = constructor_pulley_xshl64(ctx, v137, v138);
                                let v493 = constructor_output_xreg(ctx, v492);
                                let v494 = Some(v493);
                                // Rule at src\isa\pulley_shared\lower.isle line 513.
                                return v494;
                            }
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v503 = constructor_pulley_vshli8x16(ctx, v200, v138);
                                let v504 = constructor_output_vreg(ctx, v503);
                                let v505 = Some(v504);
                                // Rule at src\isa\pulley_shared\lower.isle line 526.
                                return v505;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v506 = constructor_pulley_vshli16x8(ctx, v200, v138);
                                let v507 = constructor_output_vreg(ctx, v506);
                                let v508 = Some(v507);
                                // Rule at src\isa\pulley_shared\lower.isle line 527.
                                return v508;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v509 = constructor_pulley_vshli32x4(ctx, v200, v138);
                                let v510 = constructor_output_vreg(ctx, v509);
                                let v511 = Some(v510);
                                // Rule at src\isa\pulley_shared\lower.isle line 528.
                                return v511;
                            }
                            I64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v512 = constructor_pulley_vshli64x2(ctx, v200, v138);
                                let v513 = constructor_output_vreg(ctx, v512);
                                let v514 = Some(v513);
                                // Rule at src\isa\pulley_shared\lower.isle line 529.
                                return v514;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ushr => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v398 = constructor_zext32(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v480 = constructor_pulley_xband32_s8(ctx, v138, 7_i8);
                                let v515 = constructor_pulley_xshr32_u(ctx, v398, v480);
                                let v516 = constructor_output_xreg(ctx, v515);
                                let v517 = Some(v516);
                                // Rule at src\isa\pulley_shared\lower.isle line 543.
                                return v517;
                            }
                            I16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v398 = constructor_zext32(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v485 = constructor_pulley_xband32_s8(ctx, v138, 15_i8);
                                let v518 = constructor_pulley_xshr32_u(ctx, v398, v485);
                                let v519 = constructor_output_xreg(ctx, v518);
                                let v520 = Some(v519);
                                // Rule at src\isa\pulley_shared\lower.isle line 546.
                                return v520;
                            }
                            I32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v495 = constructor_u6_shift_from_iconst(ctx, v134.1);
                                if let Some(v496) = v495 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v527 = constructor_pulley_xshr32_u_u6(ctx, v137, v496);
                                    let v528 = constructor_output_xreg(ctx, v527);
                                    let v529 = Some(v528);
                                    // Rule at src\isa\pulley_shared\lower.isle line 556.
                                    return v529;
                                }
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v521 = constructor_pulley_xshr32_u(ctx, v137, v138);
                                let v522 = constructor_output_xreg(ctx, v521);
                                let v523 = Some(v522);
                                // Rule at src\isa\pulley_shared\lower.isle line 549.
                                return v523;
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v495 = constructor_u6_shift_from_iconst(ctx, v134.1);
                                if let Some(v496) = v495 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v530 = constructor_pulley_xshr64_u_u6(ctx, v137, v496);
                                    let v531 = constructor_output_xreg(ctx, v530);
                                    let v532 = Some(v531);
                                    // Rule at src\isa\pulley_shared\lower.isle line 559.
                                    return v532;
                                }
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v524 = constructor_pulley_xshr64_u(ctx, v137, v138);
                                let v525 = constructor_output_xreg(ctx, v524);
                                let v526 = Some(v525);
                                // Rule at src\isa\pulley_shared\lower.isle line 552.
                                return v526;
                            }
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v533 = constructor_pulley_vshri8x16_u(ctx, v200, v138);
                                let v534 = constructor_output_vreg(ctx, v533);
                                let v535 = Some(v534);
                                // Rule at src\isa\pulley_shared\lower.isle line 565.
                                return v535;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v536 = constructor_pulley_vshri16x8_u(ctx, v200, v138);
                                let v537 = constructor_output_vreg(ctx, v536);
                                let v538 = Some(v537);
                                // Rule at src\isa\pulley_shared\lower.isle line 566.
                                return v538;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v539 = constructor_pulley_vshri32x4_u(ctx, v200, v138);
                                let v540 = constructor_output_vreg(ctx, v539);
                                let v541 = Some(v540);
                                // Rule at src\isa\pulley_shared\lower.isle line 567.
                                return v541;
                            }
                            I64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v542 = constructor_pulley_vshri64x2_u(ctx, v200, v138);
                                let v543 = constructor_output_vreg(ctx, v542);
                                let v544 = Some(v543);
                                // Rule at src\isa\pulley_shared\lower.isle line 568.
                                return v544;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Sshr => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v426 = constructor_sext32(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v480 = constructor_pulley_xband32_s8(ctx, v138, 7_i8);
                                let v545 = constructor_pulley_xshr32_u(ctx, v426, v480);
                                let v546 = constructor_output_xreg(ctx, v545);
                                let v547 = Some(v546);
                                // Rule at src\isa\pulley_shared\lower.isle line 572.
                                return v547;
                            }
                            I16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v426 = constructor_sext32(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v485 = constructor_pulley_xband32_s8(ctx, v138, 15_i8);
                                let v548 = constructor_pulley_xshr32_u(ctx, v426, v485);
                                let v549 = constructor_output_xreg(ctx, v548);
                                let v550 = Some(v549);
                                // Rule at src\isa\pulley_shared\lower.isle line 575.
                                return v550;
                            }
                            I32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v495 = constructor_u6_shift_from_iconst(ctx, v134.1);
                                if let Some(v496) = v495 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v557 = constructor_pulley_xshr32_s_u6(ctx, v137, v496);
                                    let v558 = constructor_output_xreg(ctx, v557);
                                    let v559 = Some(v558);
                                    // Rule at src\isa\pulley_shared\lower.isle line 585.
                                    return v559;
                                }
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v551 = constructor_pulley_xshr32_s(ctx, v137, v138);
                                let v552 = constructor_output_xreg(ctx, v551);
                                let v553 = Some(v552);
                                // Rule at src\isa\pulley_shared\lower.isle line 578.
                                return v553;
                            }
                            I64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v495 = constructor_u6_shift_from_iconst(ctx, v134.1);
                                if let Some(v496) = v495 {
                                    let v137 = constructor_put_in_xreg(ctx, v134.0);
                                    let v560 = constructor_pulley_xshr64_s_u6(ctx, v137, v496);
                                    let v561 = constructor_output_xreg(ctx, v560);
                                    let v562 = Some(v561);
                                    // Rule at src\isa\pulley_shared\lower.isle line 588.
                                    return v562;
                                }
                                let v137 = constructor_put_in_xreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v554 = constructor_pulley_xshr64_s(ctx, v137, v138);
                                let v555 = constructor_output_xreg(ctx, v554);
                                let v556 = Some(v555);
                                // Rule at src\isa\pulley_shared\lower.isle line 581.
                                return v556;
                            }
                            I8X16 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v563 = constructor_pulley_vshri8x16_s(ctx, v200, v138);
                                let v564 = constructor_output_vreg(ctx, v563);
                                let v565 = Some(v564);
                                // Rule at src\isa\pulley_shared\lower.isle line 594.
                                return v565;
                            }
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v566 = constructor_pulley_vshri16x8_s(ctx, v200, v138);
                                let v567 = constructor_output_vreg(ctx, v566);
                                let v568 = Some(v567);
                                // Rule at src\isa\pulley_shared\lower.isle line 595.
                                return v568;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v569 = constructor_pulley_vshri32x4_s(ctx, v200, v138);
                                let v570 = constructor_output_vreg(ctx, v569);
                                let v571 = Some(v570);
                                // Rule at src\isa\pulley_shared\lower.isle line 596.
                                return v571;
                            }
                            I64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v138 = constructor_put_in_xreg(ctx, v134.1);
                                let v572 = constructor_pulley_vshri64x2_s(ctx, v200, v138);
                                let v573 = constructor_output_vreg(ctx, v572);
                                let v574 = Some(v573);
                                // Rule at src\isa\pulley_shared\lower.isle line 597.
                                return v574;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fadd => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1207 = constructor_pulley_fadd32(ctx, v1199, v1200);
                                let v1208 = constructor_output_freg(ctx, v1207);
                                let v1209 = Some(v1208);
                                // Rule at src\isa\pulley_shared\lower.isle line 1567.
                                return v1209;
                            }
                            F64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1210 = constructor_pulley_fadd64(ctx, v1199, v1200);
                                let v1211 = constructor_output_freg(ctx, v1210);
                                let v1212 = Some(v1211);
                                // Rule at src\isa\pulley_shared\lower.isle line 1568.
                                return v1212;
                            }
                            F32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1213 = constructor_pulley_vaddf32x4(ctx, v200, v201);
                                let v1214 = constructor_output_vreg(ctx, v1213);
                                let v1215 = Some(v1214);
                                // Rule at src\isa\pulley_shared\lower.isle line 1569.
                                return v1215;
                            }
                            F64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1216 = constructor_pulley_vaddf64x2(ctx, v200, v201);
                                let v1217 = constructor_output_vreg(ctx, v1216);
                                let v1218 = Some(v1217);
                                // Rule at src\isa\pulley_shared\lower.isle line 1570.
                                return v1218;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fsub => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1219 = constructor_pulley_fsub32(ctx, v1199, v1200);
                                let v1220 = constructor_output_freg(ctx, v1219);
                                let v1221 = Some(v1220);
                                // Rule at src\isa\pulley_shared\lower.isle line 1574.
                                return v1221;
                            }
                            F64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1222 = constructor_pulley_fsub64(ctx, v1199, v1200);
                                let v1223 = constructor_output_freg(ctx, v1222);
                                let v1224 = Some(v1223);
                                // Rule at src\isa\pulley_shared\lower.isle line 1575.
                                return v1224;
                            }
                            F32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1225 = constructor_pulley_vsubf32x4(ctx, v200, v201);
                                let v1226 = constructor_output_vreg(ctx, v1225);
                                let v1227 = Some(v1226);
                                // Rule at src\isa\pulley_shared\lower.isle line 1576.
                                return v1227;
                            }
                            F64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1228 = constructor_pulley_vsubf64x2(ctx, v200, v201);
                                let v1229 = constructor_output_vreg(ctx, v1228);
                                let v1230 = Some(v1229);
                                // Rule at src\isa\pulley_shared\lower.isle line 1577.
                                return v1230;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fmul => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1231 = constructor_pulley_fmul32(ctx, v1199, v1200);
                                let v1232 = constructor_output_freg(ctx, v1231);
                                let v1233 = Some(v1232);
                                // Rule at src\isa\pulley_shared\lower.isle line 1581.
                                return v1233;
                            }
                            F64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1234 = constructor_pulley_fmul64(ctx, v1199, v1200);
                                let v1235 = constructor_output_freg(ctx, v1234);
                                let v1236 = Some(v1235);
                                // Rule at src\isa\pulley_shared\lower.isle line 1582.
                                return v1236;
                            }
                            F32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1237 = constructor_pulley_vmulf32x4(ctx, v200, v201);
                                let v1238 = constructor_output_vreg(ctx, v1237);
                                let v1239 = Some(v1238);
                                // Rule at src\isa\pulley_shared\lower.isle line 1583.
                                return v1239;
                            }
                            F64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1240 = constructor_pulley_vmulf64x2(ctx, v200, v201);
                                let v1241 = constructor_output_vreg(ctx, v1240);
                                let v1242 = Some(v1241);
                                // Rule at src\isa\pulley_shared\lower.isle line 1584.
                                return v1242;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fdiv => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1243 = constructor_pulley_fdiv32(ctx, v1199, v1200);
                                let v1244 = constructor_output_freg(ctx, v1243);
                                let v1245 = Some(v1244);
                                // Rule at src\isa\pulley_shared\lower.isle line 1588.
                                return v1245;
                            }
                            F64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1246 = constructor_pulley_fdiv64(ctx, v1199, v1200);
                                let v1247 = constructor_output_freg(ctx, v1246);
                                let v1248 = Some(v1247);
                                // Rule at src\isa\pulley_shared\lower.isle line 1589.
                                return v1248;
                            }
                            F32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1249 = constructor_pulley_vdivf32x4(ctx, v200, v201);
                                let v1250 = constructor_output_vreg(ctx, v1249);
                                let v1251 = Some(v1250);
                                // Rule at src\isa\pulley_shared\lower.isle line 1590.
                                return v1251;
                            }
                            F64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1252 = constructor_pulley_vdivf64x2(ctx, v200, v201);
                                let v1253 = constructor_output_vreg(ctx, v1252);
                                let v1254 = Some(v1253);
                                // Rule at src\isa\pulley_shared\lower.isle line 1591.
                                return v1254;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fcopysign => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1201 = constructor_pulley_fcopysign32(ctx, v1199, v1200);
                                let v1202 = constructor_output_freg(ctx, v1201);
                                let v1203 = Some(v1202);
                                // Rule at src\isa\pulley_shared\lower.isle line 1559.
                                return v1203;
                            }
                            F64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1204 = constructor_pulley_fcopysign64(ctx, v1199, v1200);
                                let v1205 = constructor_output_freg(ctx, v1204);
                                let v1206 = Some(v1205);
                                // Rule at src\isa\pulley_shared\lower.isle line 1562.
                                return v1206;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fmin => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1267 = constructor_pulley_fminimum32(ctx, v1199, v1200);
                                let v1268 = constructor_output_freg(ctx, v1267);
                                let v1269 = Some(v1268);
                                // Rule at src\isa\pulley_shared\lower.isle line 1602.
                                return v1269;
                            }
                            F64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1270 = constructor_pulley_fminimum64(ctx, v1199, v1200);
                                let v1271 = constructor_output_freg(ctx, v1270);
                                let v1272 = Some(v1271);
                                // Rule at src\isa\pulley_shared\lower.isle line 1603.
                                return v1272;
                            }
                            F32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1273 = constructor_pulley_vminimumf32x4(ctx, v200, v201);
                                let v1274 = constructor_output_vreg(ctx, v1273);
                                let v1275 = Some(v1274);
                                // Rule at src\isa\pulley_shared\lower.isle line 1604.
                                return v1275;
                            }
                            F64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1276 = constructor_pulley_vminimumf64x2(ctx, v200, v201);
                                let v1277 = constructor_output_vreg(ctx, v1276);
                                let v1278 = Some(v1277);
                                // Rule at src\isa\pulley_shared\lower.isle line 1605.
                                return v1278;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fmax => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1255 = constructor_pulley_fmaximum32(ctx, v1199, v1200);
                                let v1256 = constructor_output_freg(ctx, v1255);
                                let v1257 = Some(v1256);
                                // Rule at src\isa\pulley_shared\lower.isle line 1595.
                                return v1257;
                            }
                            F64 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v1199 = constructor_put_in_freg(ctx, v134.0);
                                let v1200 = constructor_put_in_freg(ctx, v134.1);
                                let v1258 = constructor_pulley_fmaximum64(ctx, v1199, v1200);
                                let v1259 = constructor_output_freg(ctx, v1258);
                                let v1260 = Some(v1259);
                                // Rule at src\isa\pulley_shared\lower.isle line 1596.
                                return v1260;
                            }
                            F32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1261 = constructor_pulley_vmaximumf32x4(ctx, v200, v201);
                                let v1262 = constructor_output_vreg(ctx, v1261);
                                let v1263 = Some(v1262);
                                // Rule at src\isa\pulley_shared\lower.isle line 1597.
                                return v1263;
                            }
                            F64X2 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v1264 = constructor_pulley_vmaximumf64x2(ctx, v200, v201);
                                let v1265 = constructor_output_vreg(ctx, v1264);
                                let v1266 = Some(v1265);
                                // Rule at src\isa\pulley_shared\lower.isle line 1598.
                                return v1266;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Snarrow => {
                    let v134 = C::unpack_value_array_2(ctx, v133);
                    let v1505 = C::value_type(ctx, v134.0);
                    match v1505 {
                        I16X8 => {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v1506 = constructor_pulley_vnarrow16x8_s(ctx, v200, v201);
                            let v1507 = constructor_output_vreg(ctx, v1506);
                            let v1508 = Some(v1507);
                            // Rule at src\isa\pulley_shared\lower.isle line 1761.
                            return v1508;
                        }
                        I32X4 => {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v1509 = constructor_pulley_vnarrow32x4_s(ctx, v200, v201);
                            let v1510 = constructor_output_vreg(ctx, v1509);
                            let v1511 = Some(v1510);
                            // Rule at src\isa\pulley_shared\lower.isle line 1762.
                            return v1511;
                        }
                        I64X2 => {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v1512 = constructor_pulley_vnarrow64x2_s(ctx, v200, v201);
                            let v1513 = constructor_output_vreg(ctx, v1512);
                            let v1514 = Some(v1513);
                            // Rule at src\isa\pulley_shared\lower.isle line 1763.
                            return v1514;
                        }
                        _ => {}
                    }
                }
                &Opcode::Unarrow => {
                    let v134 = C::unpack_value_array_2(ctx, v133);
                    let v1505 = C::value_type(ctx, v134.0);
                    match v1505 {
                        I16X8 => {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v1515 = constructor_pulley_vnarrow16x8_u(ctx, v200, v201);
                            let v1516 = constructor_output_vreg(ctx, v1515);
                            let v1517 = Some(v1516);
                            // Rule at src\isa\pulley_shared\lower.isle line 1767.
                            return v1517;
                        }
                        I32X4 => {
                            let v200 = constructor_put_in_vreg(ctx, v134.0);
                            let v201 = constructor_put_in_vreg(ctx, v134.1);
                            let v1518 = constructor_pulley_vnarrow32x4_u(ctx, v200, v201);
                            let v1519 = constructor_output_vreg(ctx, v1518);
                            let v1520 = Some(v1519);
                            // Rule at src\isa\pulley_shared\lower.isle line 1768.
                            return v1520;
                        }
                        _ => {}
                    }
                }
                &Opcode::Uunarrow => {
                    let v134 = C::unpack_value_array_2(ctx, v133);
                    let v1505 = C::value_type(ctx, v134.0);
                    if v1505 == I64X2 {
                        let v200 = constructor_put_in_vreg(ctx, v134.0);
                        let v201 = constructor_put_in_vreg(ctx, v134.1);
                        let v1521 = constructor_pulley_vunarrow64x2_u(ctx, v200, v201);
                        let v1522 = constructor_output_vreg(ctx, v1521);
                        let v1523 = Some(v1522);
                        // Rule at src\isa\pulley_shared\lower.isle line 1772.
                        return v1523;
                    }
                }
                &Opcode::IaddPairwise => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I16X8 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v257 = constructor_pulley_vaddpairwisei16x8_s(ctx, v200, v201);
                                let v258 = constructor_output_vreg(ctx, v257);
                                let v259 = Some(v258);
                                // Rule at src\isa\pulley_shared\lower.isle line 328.
                                return v259;
                            }
                            I32X4 => {
                                let v134 = C::unpack_value_array_2(ctx, v133);
                                let v200 = constructor_put_in_vreg(ctx, v134.0);
                                let v201 = constructor_put_in_vreg(ctx, v134.1);
                                let v260 = constructor_pulley_vaddpairwisei32x4_s(ctx, v200, v201);
                                let v261 = constructor_output_vreg(ctx, v260);
                                let v262 = Some(v261);
                                // Rule at src\isa\pulley_shared\lower.isle line 329.
                                return v262;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Iconcat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I128 {
                            let v134 = C::unpack_value_array_2(ctx, v133);
                            let v1005 = C::put_in_reg(ctx, v134.0);
                            let v1006 = C::put_in_reg(ctx, v134.1);
                            let v1007 = C::value_regs(ctx, v1005, v1006);
                            let v1008 = C::output(ctx, v1007);
                            let v1009 = Some(v1008);
                            // Rule at src\isa\pulley_shared\lower.isle line 1336.
                            return v1009;
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::BinaryImm8 {
            opcode: ref v1530,
            arg: v1531,
            imm: v1532,
        } => {
            if let &Opcode::Extractlane = v1530 {
                let v1533 = C::value_type(ctx, v1531);
                match v1533 {
                    I8X16 => {
                        let v1535 = constructor_put_in_vreg(ctx, v1531);
                        let v1534 = C::u8_from_uimm8(ctx, v1532);
                        let v1536 = constructor_pulley_xextractv8x16(ctx, v1535, v1534);
                        let v1537 = constructor_output_xreg(ctx, v1536);
                        let v1538 = Some(v1537);
                        // Rule at src\isa\pulley_shared\lower.isle line 1784.
                        return v1538;
                    }
                    I16X8 => {
                        let v1535 = constructor_put_in_vreg(ctx, v1531);
                        let v1534 = C::u8_from_uimm8(ctx, v1532);
                        let v1539 = constructor_pulley_xextractv16x8(ctx, v1535, v1534);
                        let v1540 = constructor_output_xreg(ctx, v1539);
                        let v1541 = Some(v1540);
                        // Rule at src\isa\pulley_shared\lower.isle line 1786.
                        return v1541;
                    }
                    I32X4 => {
                        let v1535 = constructor_put_in_vreg(ctx, v1531);
                        let v1534 = C::u8_from_uimm8(ctx, v1532);
                        let v1542 = constructor_pulley_xextractv32x4(ctx, v1535, v1534);
                        let v1543 = constructor_output_xreg(ctx, v1542);
                        let v1544 = Some(v1543);
                        // Rule at src\isa\pulley_shared\lower.isle line 1788.
                        return v1544;
                    }
                    I64X2 => {
                        let v1535 = constructor_put_in_vreg(ctx, v1531);
                        let v1534 = C::u8_from_uimm8(ctx, v1532);
                        let v1545 = constructor_pulley_xextractv64x2(ctx, v1535, v1534);
                        let v1546 = constructor_output_xreg(ctx, v1545);
                        let v1547 = Some(v1546);
                        // Rule at src\isa\pulley_shared\lower.isle line 1790.
                        return v1547;
                    }
                    F32X4 => {
                        let v1535 = constructor_put_in_vreg(ctx, v1531);
                        let v1534 = C::u8_from_uimm8(ctx, v1532);
                        let v1548 = constructor_pulley_fextractv32x4(ctx, v1535, v1534);
                        let v1549 = constructor_output_freg(ctx, v1548);
                        let v1550 = Some(v1549);
                        // Rule at src\isa\pulley_shared\lower.isle line 1792.
                        return v1550;
                    }
                    F64X2 => {
                        let v1535 = constructor_put_in_vreg(ctx, v1531);
                        let v1534 = C::u8_from_uimm8(ctx, v1532);
                        let v1551 = constructor_pulley_fextractv64x2(ctx, v1535, v1534);
                        let v1552 = constructor_output_freg(ctx, v1551);
                        let v1553 = Some(v1552);
                        // Rule at src\isa\pulley_shared\lower.isle line 1794.
                        return v1553;
                    }
                    _ => {}
                }
            }
        }
        &InstructionData::Call {
            opcode: ref v34,
            args: v35,
            func_ref: v36,
        } => {
            match v34 {
                &Opcode::Call => {
                    let v38 = C::func_ref_data(ctx, v36);
                    if let &RelocDistance::Near = &v38.2 {
                        let v42 = &C::gen_call_output(ctx, v38.0);
                        let v43 = C::abi_sig(ctx, v38.0);
                        let v37 = C::value_list_slice(ctx, v35);
                        let v44 = &C::put_in_regs_vec(ctx, v37);
                        let v45 = C::gen_call_args(ctx, v43, v44);
                        let v46 = C::gen_call_rets(ctx, v43, v42);
                        let v47 = C::try_call_none(ctx);
                        let v48 = C::gen_call_info(ctx, v43, v38.1, v45, v46, v47);
                        let v49 = &constructor_call_impl(ctx, v48);
                        let v50 = constructor_emit_side_effect(ctx, v49);
                        let v51 = C::output_vec(ctx, v42);
                        let v52 = Some(v51);
                        // Rule at src\isa\pulley_shared\lower.isle line 143.
                        return v52;
                    }
                    let v42 = &C::gen_call_output(ctx, v38.0);
                    let v43 = C::abi_sig(ctx, v38.0);
                    let v37 = C::value_list_slice(ctx, v35);
                    let v44 = &C::put_in_regs_vec(ctx, v37);
                    let v45 = C::gen_call_args(ctx, v43, v44);
                    let v46 = C::gen_call_rets(ctx, v43, v42);
                    let v47 = C::try_call_none(ctx);
                    let v53 = C::gen_call_host_info(ctx, v43, v38.1, v45, v46, v47);
                    let v54 = &constructor_indirect_call_host_impl(ctx, v53);
                    let v55 = constructor_emit_side_effect(ctx, v54);
                    let v51 = C::output_vec(ctx, v42);
                    let v52 = Some(v51);
                    // Rule at src\isa\pulley_shared\lower.isle line 153.
                    return v52;
                }
                &Opcode::ReturnCall => {
                    let v38 = C::func_ref_data(ctx, v36);
                    if let &RelocDistance::Near = &v38.2 {
                        let v76 = C::abi_sig(ctx, v38.0);
                        let v37 = C::value_list_slice(ctx, v35);
                        let v77 = &C::put_in_regs_vec(ctx, v37);
                        let v86 = C::gen_return_call_args(ctx, v76, v77);
                        let v87 = C::gen_return_call_info(ctx, v76, v38.1, v86);
                        let v88 = &constructor_return_call_impl(ctx, v87);
                        let v89 = constructor_side_effect(ctx, v88);
                        let v90 = Some(v89);
                        // Rule at src\isa\pulley_shared\lower.isle line 218.
                        return v90;
                    }
                    let v76 = C::abi_sig(ctx, v38.0);
                    let v37 = C::value_list_slice(ctx, v35);
                    let v77 = &C::put_in_regs_vec(ctx, v37);
                    let v86 = C::gen_return_call_args(ctx, v76, v77);
                    let v91 = C::box_external_name(ctx, v38.1);
                    let v93 = constructor_load_ext_name(ctx, v91, 0_i64, &v38.2);
                    let v94 = C::xreg_to_reg(ctx, v93);
                    let v95 = C::gen_return_call_ind_info(ctx, v76, v94, v86);
                    let v96 = &constructor_return_indirect_call_impl(ctx, v95);
                    let v97 = constructor_side_effect(ctx, v96);
                    let v98 = Some(v97);
                    // Rule at src\isa\pulley_shared\lower.isle line 225.
                    return v98;
                }
                &Opcode::PatchableCall => {
                    let v38 = C::func_ref_data(ctx, v36);
                    if let &RelocDistance::Near = &v38.2 {
                        let v76 = C::abi_sig(ctx, v38.0);
                        let v37 = C::value_list_slice(ctx, v35);
                        let v77 = &C::put_in_regs_vec(ctx, v37);
                        let v78 = C::gen_call_args(ctx, v76, v77);
                        let v79 = C::gen_patchable_call_rets(ctx);
                        let v80 = C::try_call_none(ctx);
                        let v81 = C::gen_call_info(ctx, v76, v38.1, v78, v79, v80);
                        let v82 = &constructor_patchable_call_impl(ctx, v81);
                        let v83 = constructor_emit_side_effect(ctx, v82);
                        let v84 = C::output_none(ctx);
                        let v85 = Some(v84);
                        // Rule at src\isa\pulley_shared\lower.isle line 176.
                        return v85;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::CallIndirect {
            opcode: ref v56,
            args: v57,
            sig_ref: v58,
        } => {
            match v56 {
                &Opcode::CallIndirect => {
                    let v59 = C::value_list_slice(ctx, v57);
                    let v60 = C::value_slice_unwrap(ctx, v59);
                    if let Some(v61) = v60 {
                        let v64 = &C::gen_call_output(ctx, v58);
                        let v65 = C::abi_sig(ctx, v58);
                        let v66 = C::put_in_reg(ctx, v61.0);
                        let v67 = &C::put_in_regs_vec(ctx, v61.1);
                        let v68 = C::gen_call_args(ctx, v65, v67);
                        let v69 = C::gen_call_rets(ctx, v65, v64);
                        let v70 = C::try_call_none(ctx);
                        let v71 = C::gen_call_ind_info(ctx, v65, v66, v68, v69, v70);
                        let v72 = &constructor_indirect_call_impl(ctx, v71);
                        let v73 = constructor_emit_side_effect(ctx, v72);
                        let v74 = C::output_vec(ctx, v64);
                        let v75 = Some(v74);
                        // Rule at src\isa\pulley_shared\lower.isle line 163.
                        return v75;
                    }
                }
                &Opcode::ReturnCallIndirect => {
                    let v59 = C::value_list_slice(ctx, v57);
                    let v60 = C::value_slice_unwrap(ctx, v59);
                    if let Some(v61) = v60 {
                        let v99 = C::abi_sig(ctx, v58);
                        let v100 = C::put_in_reg(ctx, v61.0);
                        let v101 = &C::put_in_regs_vec(ctx, v61.1);
                        let v102 = C::gen_return_call_args(ctx, v99, v101);
                        let v103 = C::gen_return_call_ind_info(ctx, v99, v100, v102);
                        let v104 = &constructor_return_indirect_call_impl(ctx, v103);
                        let v105 = constructor_side_effect(ctx, v104);
                        let v106 = Some(v105);
                        // Rule at src\isa\pulley_shared\lower.isle line 233.
                        return v106;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::CondTrap {
            opcode: ref v7,
            arg: v8,
            code: ref v9,
        } => {
            match v7 {
                &Opcode::Trapz => {
                    let v10 = &constructor_lower_cond(ctx, v8);
                    let v11 = &C::cond_invert(ctx, v10);
                    let v12 = &constructor_pulley_trap_if(ctx, v11, v9);
                    let v13 = constructor_side_effect(ctx, v12);
                    let v14 = Some(v13);
                    // Rule at src\isa\pulley_shared\lower.isle line 115.
                    return v14;
                }
                &Opcode::Trapnz => {
                    let v10 = &constructor_lower_cond(ctx, v8);
                    let v15 = &constructor_pulley_trap_if(ctx, v10, v9);
                    let v16 = constructor_side_effect(ctx, v15);
                    let v17 = Some(v16);
                    // Rule at src\isa\pulley_shared\lower.isle line 118.
                    return v17;
                }
                _ => {}
            }
        }
        &InstructionData::ExceptionHandlerAddress {
            opcode: ref v1649,
            block: ref v1650,
            imm: v1651,
        } => {
            if let &Opcode::GetExceptionHandlerAddress = v1649 {
                let v1652 = C::u64_from_imm64(ctx, v1651);
                let v1653 = C::block_exn_successor_label(ctx, v1650, v1652);
                let v1654 = constructor_pulley_label_address(ctx, v1653);
                let v1655 = constructor_output_reg(ctx, v1654);
                let v1656 = Some(v1655);
                // Rule at src\isa\pulley_shared\lower.isle line 1858.
                return v1656;
            }
        }
        &InstructionData::FloatCompare {
            opcode: ref v809,
            args: ref v810,
            cond: ref v811,
        } => {
            if let &Opcode::Fcmp = v809 {
                let v812 = C::unpack_value_array_2(ctx, v810);
                let v815 = C::value_type(ctx, v812.1);
                let v821 = C::ty_vec128(ctx, v815);
                if let Some(v822) = v821 {
                    let v823 = constructor_lower_vfcmp(ctx, v822, v811, v812.0, v812.1);
                    let v824 = constructor_output_vreg(ctx, v823);
                    let v825 = Some(v824);
                    // Rule at src\isa\pulley_shared\lower.isle line 900.
                    return v825;
                }
                let v816 = C::ty_scalar_float(ctx, v815);
                if let Some(v817) = v816 {
                    let v818 = constructor_lower_fcmp(ctx, v817, v811, v812.0, v812.1);
                    let v819 = constructor_output_xreg(ctx, v818);
                    let v820 = Some(v819);
                    // Rule at src\isa\pulley_shared\lower.isle line 897.
                    return v820;
                }
            }
        }
        &InstructionData::FuncAddr {
            opcode: ref v1639,
            func_ref: v1640,
        } => {
            if let &Opcode::FuncAddr = v1639 {
                let v1641 = C::func_ref_data(ctx, v1640);
                let v1645 = C::box_external_name(ctx, v1641.1);
                let v1646 = constructor_load_ext_name(ctx, v1645, 0_i64, &v1641.2);
                let v1647 = constructor_output_xreg(ctx, v1646);
                let v1648 = Some(v1647);
                // Rule at src\isa\pulley_shared\lower.isle line 1852.
                return v1648;
            }
        }
        &InstructionData::IntAddTrap {
            opcode: ref v1022,
            args: ref v1023,
            code: ref v1024,
        } => {
            if let &Opcode::UaddOverflowTrap = v1022 {
                let v107 = C::first_result(ctx, arg0);
                if let Some(v108) = v107 {
                    let v109 = C::value_type(ctx, v108);
                    match v109 {
                        I32 => {
                            let v1025 = C::unpack_value_array_2(ctx, v1023);
                            let v1028 = constructor_put_in_xreg(ctx, v1025.0);
                            let v1029 = constructor_put_in_xreg(ctx, v1025.1);
                            let v1030 = constructor_pulley_xadd32_uoverflow_trap(ctx, v1028, v1029, v1024);
                            let v1031 = constructor_output_xreg(ctx, v1030);
                            let v1032 = Some(v1031);
                            // Rule at src\isa\pulley_shared\lower.isle line 1348.
                            return v1032;
                        }
                        I64 => {
                            let v1025 = C::unpack_value_array_2(ctx, v1023);
                            let v1028 = constructor_put_in_xreg(ctx, v1025.0);
                            let v1029 = constructor_put_in_xreg(ctx, v1025.1);
                            let v1033 = constructor_pulley_xadd64_uoverflow_trap(ctx, v1028, v1029, v1024);
                            let v1034 = constructor_output_xreg(ctx, v1033);
                            let v1035 = Some(v1034);
                            // Rule at src\isa\pulley_shared\lower.isle line 1351.
                            return v1035;
                        }
                        _ => {}
                    }
                }
            }
        }
        &InstructionData::IntCompare {
            opcode: ref v791,
            args: ref v792,
            cond: ref v793,
        } => {
            if let &Opcode::Icmp = v791 {
                let v794 = C::unpack_value_array_2(ctx, v792);
                let v803 = C::value_type(ctx, v794.0);
                let v804 = C::ty_vec128(ctx, v803);
                if let Some(v805) = v804 {
                    let v806 = constructor_lower_vcmp(ctx, v805, v793, v794.0, v794.1);
                    let v807 = constructor_output_vreg(ctx, v806);
                    let v808 = Some(v807);
                    // Rule at src\isa\pulley_shared\lower.isle line 856.
                    return v808;
                }
                let v797 = C::value_type(ctx, v794.1);
                let v798 = C::ty_int(ctx, v797);
                if let Some(v799) = v798 {
                    let v800 = constructor_lower_icmp(ctx, v799, v793, v794.0, v794.1);
                    let v801 = constructor_output_xreg(ctx, v800);
                    let v802 = Some(v801);
                    // Rule at src\isa\pulley_shared\lower.isle line 747.
                    return v802;
                }
            }
        }
        &InstructionData::Load {
            opcode: ref v826,
            arg: v827,
            flags: v828,
            offset: v829,
        } => {
            match v826 {
                &Opcode::Load => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I128 {
                            let v839 = C::offset32_to_i32(ctx, v829);
                            let v841 = C::i32_checked_add(ctx, v839, 8_i32);
                            if let Some(v842) = v841 {
                                let v843 = &constructor_amode(ctx, v827, v829);
                                let v845 = constructor_pulley_xload(ctx, v843, I64, v828);
                                let v846 = C::i32_to_offset32(ctx, v842);
                                let v847 = &constructor_amode(ctx, v827, v846);
                                let v848 = constructor_pulley_xload(ctx, v847, I64, v828);
                                let v849 = C::xreg_to_reg(ctx, v845);
                                let v850 = C::xreg_to_reg(ctx, v848);
                                let v851 = C::value_regs(ctx, v849, v850);
                                let v852 = C::output(ctx, v851);
                                let v853 = Some(v852);
                                // Rule at src\isa\pulley_shared\lower.isle line 968.
                                return v853;
                            }
                        }
                        let v593 = C::ty_vec128(ctx, v109);
                        if let Some(v594) = v593 {
                            let v895 = constructor_gen_vload(ctx, v827, v829, v828, v594, &VExtKind::None);
                            let v896 = constructor_output_vreg(ctx, v895);
                            let v897 = Some(v896);
                            // Rule at src\isa\pulley_shared\lower.isle line 1010.
                            return v897;
                        }
                        let v834 = C::ty_scalar_float(ctx, v109);
                        if let Some(v835) = v834 {
                            let v836 = constructor_gen_fload(ctx, v827, v829, v828, v835);
                            let v837 = constructor_output_freg(ctx, v836);
                            let v838 = Some(v837);
                            // Rule at src\isa\pulley_shared\lower.isle line 965.
                            return v838;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v130 = C::fits_in_64(ctx, v129);
                            if let Some(v131) = v130 {
                                let v831 = constructor_gen_xload(ctx, v827, v829, v828, v131, &ExtKind::None);
                                let v832 = constructor_output_xreg(ctx, v831);
                                let v833 = Some(v832);
                                // Rule at src\isa\pulley_shared\lower.isle line 962.
                                return v833;
                            }
                        }
                    }
                }
                &Opcode::Uload8 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v868 = constructor_gen_xload(ctx, v827, v829, v828, I8, &ExtKind::Zero64);
                            let v869 = constructor_output_xreg(ctx, v868);
                            let v870 = Some(v869);
                            // Rule at src\isa\pulley_shared\lower.isle line 983.
                            return v870;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v856 = constructor_gen_xload(ctx, v827, v829, v828, I8, &ExtKind::Zero32);
                                let v857 = constructor_output_xreg(ctx, v856);
                                let v858 = Some(v857);
                                // Rule at src\isa\pulley_shared\lower.isle line 974.
                                return v858;
                            }
                        }
                    }
                }
                &Opcode::Sload8 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v885 = constructor_gen_xload(ctx, v827, v829, v828, I8, &ExtKind::Sign64);
                            let v886 = constructor_output_xreg(ctx, v885);
                            let v887 = Some(v886);
                            // Rule at src\isa\pulley_shared\lower.isle line 1001.
                            return v887;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v878 = constructor_gen_xload(ctx, v827, v829, v828, I8, &ExtKind::Sign32);
                                let v879 = constructor_output_xreg(ctx, v878);
                                let v880 = Some(v879);
                                // Rule at src\isa\pulley_shared\lower.isle line 992.
                                return v880;
                            }
                        }
                    }
                }
                &Opcode::Uload16 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v871 = constructor_gen_xload(ctx, v827, v829, v828, I16, &ExtKind::Zero64);
                            let v872 = constructor_output_xreg(ctx, v871);
                            let v873 = Some(v872);
                            // Rule at src\isa\pulley_shared\lower.isle line 986.
                            return v873;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v860 = constructor_gen_xload(ctx, v827, v829, v828, I16, &ExtKind::Zero32);
                                let v861 = constructor_output_xreg(ctx, v860);
                                let v862 = Some(v861);
                                // Rule at src\isa\pulley_shared\lower.isle line 977.
                                return v862;
                            }
                        }
                    }
                }
                &Opcode::Sload16 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v888 = constructor_gen_xload(ctx, v827, v829, v828, I16, &ExtKind::Sign64);
                            let v889 = constructor_output_xreg(ctx, v888);
                            let v890 = Some(v889);
                            // Rule at src\isa\pulley_shared\lower.isle line 1004.
                            return v890;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v881 = constructor_gen_xload(ctx, v827, v829, v828, I16, &ExtKind::Sign32);
                                let v882 = constructor_output_xreg(ctx, v881);
                                let v883 = Some(v882);
                                // Rule at src\isa\pulley_shared\lower.isle line 995.
                                return v883;
                            }
                        }
                    }
                }
                &Opcode::Uload32 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v874 = constructor_gen_xload(ctx, v827, v829, v828, I32, &ExtKind::Zero64);
                            let v875 = constructor_output_xreg(ctx, v874);
                            let v876 = Some(v875);
                            // Rule at src\isa\pulley_shared\lower.isle line 989.
                            return v876;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v864 = constructor_gen_xload(ctx, v827, v829, v828, I32, &ExtKind::None);
                                let v865 = constructor_output_xreg(ctx, v864);
                                let v866 = Some(v865);
                                // Rule at src\isa\pulley_shared\lower.isle line 980.
                                return v866;
                            }
                        }
                    }
                }
                &Opcode::Sload32 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v891 = constructor_gen_xload(ctx, v827, v829, v828, I32, &ExtKind::Sign64);
                            let v892 = constructor_output_xreg(ctx, v891);
                            let v893 = Some(v892);
                            // Rule at src\isa\pulley_shared\lower.isle line 1007.
                            return v893;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v864 = constructor_gen_xload(ctx, v827, v829, v828, I32, &ExtKind::None);
                                let v865 = constructor_output_xreg(ctx, v864);
                                let v866 = Some(v865);
                                // Rule at src\isa\pulley_shared\lower.isle line 998.
                                return v866;
                            }
                        }
                    }
                }
                &Opcode::Uload8x8 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v903 = constructor_gen_vload(ctx, v827, v829, v828, v109, &VExtKind::U8x8);
                        let v904 = constructor_output_vreg(ctx, v903);
                        let v905 = Some(v904);
                        // Rule at src\isa\pulley_shared\lower.isle line 1016.
                        return v905;
                    }
                }
                &Opcode::Sload8x8 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v899 = constructor_gen_vload(ctx, v827, v829, v828, v109, &VExtKind::S8x8);
                        let v900 = constructor_output_vreg(ctx, v899);
                        let v901 = Some(v900);
                        // Rule at src\isa\pulley_shared\lower.isle line 1013.
                        return v901;
                    }
                }
                &Opcode::Uload16x4 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v911 = constructor_gen_vload(ctx, v827, v829, v828, v109, &VExtKind::U16x4);
                        let v912 = constructor_output_vreg(ctx, v911);
                        let v913 = Some(v912);
                        // Rule at src\isa\pulley_shared\lower.isle line 1022.
                        return v913;
                    }
                }
                &Opcode::Sload16x4 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v907 = constructor_gen_vload(ctx, v827, v829, v828, v109, &VExtKind::S16x4);
                        let v908 = constructor_output_vreg(ctx, v907);
                        let v909 = Some(v908);
                        // Rule at src\isa\pulley_shared\lower.isle line 1019.
                        return v909;
                    }
                }
                &Opcode::Uload32x2 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v919 = constructor_gen_vload(ctx, v827, v829, v828, v109, &VExtKind::U32x2);
                        let v920 = constructor_output_vreg(ctx, v919);
                        let v921 = Some(v920);
                        // Rule at src\isa\pulley_shared\lower.isle line 1028.
                        return v921;
                    }
                }
                &Opcode::Sload32x2 => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v915 = constructor_gen_vload(ctx, v827, v829, v828, v109, &VExtKind::S32x2);
                        let v916 = constructor_output_vreg(ctx, v915);
                        let v917 = Some(v916);
                        // Rule at src\isa\pulley_shared\lower.isle line 1025.
                        return v917;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::LoadNoOffset {
            opcode: ref v1074,
            arg: v1075,
            flags: v1076,
        } => {
            if let &Opcode::Bitcast = v1074 {
                let v107 = C::first_result(ctx, arg0);
                if let Some(v108) = v107 {
                    let v109 = C::value_type(ctx, v108);
                    let v1077 = C::value_type(ctx, v1075);
                    if v109 == v1077 {
                        let v1094 = constructor_output_value(ctx, v1075);
                        let v1095 = Some(v1094);
                        // Rule at src\isa\pulley_shared\lower.isle line 1443.
                        return v1095;
                    }
                    let v593 = C::ty_vec128(ctx, v109);
                    if let Some(v594) = v593 {
                        let v1092 = C::ty_vec128(ctx, v1077);
                        if let Some(v1093) = v1092 {
                            let v1094 = constructor_output_value(ctx, v1075);
                            let v1095 = Some(v1094);
                            // Rule at src\isa\pulley_shared\lower.isle line 1440.
                            return v1095;
                        }
                    }
                    match v109 {
                        I32 => {
                            if v1077 == F32 {
                                let v1085 = constructor_put_in_freg(ctx, v1075);
                                let v1086 = constructor_pulley_bitcast_int_from_float_32(ctx, v1085);
                                let v1087 = constructor_output_xreg(ctx, v1086);
                                let v1088 = Some(v1087);
                                // Rule at src\isa\pulley_shared\lower.isle line 1434.
                                return v1088;
                            }
                        }
                        I64 => {
                            if v1077 == F64 {
                                let v1085 = constructor_put_in_freg(ctx, v1075);
                                let v1089 = constructor_pulley_bitcast_int_from_float_64(ctx, v1085);
                                let v1090 = constructor_output_xreg(ctx, v1089);
                                let v1091 = Some(v1090);
                                // Rule at src\isa\pulley_shared\lower.isle line 1437.
                                return v1091;
                            }
                        }
                        F32 => {
                            if v1077 == I32 {
                                let v1078 = constructor_put_in_xreg(ctx, v1075);
                                let v1079 = constructor_pulley_bitcast_float_from_int_32(ctx, v1078);
                                let v1080 = constructor_output_freg(ctx, v1079);
                                let v1081 = Some(v1080);
                                // Rule at src\isa\pulley_shared\lower.isle line 1428.
                                return v1081;
                            }
                        }
                        F64 => {
                            if v1077 == I64 {
                                let v1078 = constructor_put_in_xreg(ctx, v1075);
                                let v1082 = constructor_pulley_bitcast_float_from_int_64(ctx, v1078);
                                let v1083 = constructor_output_freg(ctx, v1082);
                                let v1084 = Some(v1083);
                                // Rule at src\isa\pulley_shared\lower.isle line 1431.
                                return v1084;
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
        &InstructionData::MultiAry {
            opcode: ref v29,
            args: v30,
        } => {
            if let &Opcode::Return = v29 {
                let v31 = C::value_list_slice(ctx, v30);
                let v32 = constructor_lower_return(ctx, v31);
                let v33 = Some(v32);
                // Rule at src\isa\pulley_shared\lower.isle line 137.
                return v33;
            }
        }
        &InstructionData::NullAry {
            opcode: ref v18,
        } => {
            match v18 {
                &Opcode::GetFramePointer => {
                    let v23 = constructor_pulley_xmov_fp(ctx);
                    let v24 = constructor_output_xreg(ctx, v23);
                    let v25 = Some(v24);
                    // Rule at src\isa\pulley_shared\lower.isle line 128.
                    return v25;
                }
                &Opcode::GetStackPointer => {
                    let v19 = C::sp_reg(ctx);
                    let v20 = constructor_pulley_get_special(ctx, v19);
                    let v21 = constructor_output_xreg(ctx, v20);
                    let v22 = Some(v21);
                    // Rule at src\isa\pulley_shared\lower.isle line 123.
                    return v22;
                }
                &Opcode::GetReturnAddress => {
                    let v26 = constructor_pulley_xmov_lr(ctx);
                    let v27 = constructor_output_xreg(ctx, v26);
                    let v28 = Some(v27);
                    // Rule at src\isa\pulley_shared\lower.isle line 132.
                    return v28;
                }
                &Opcode::SequencePoint => {
                    let v1657 = &constructor_pulley_sequence_point(ctx);
                    let v1658 = constructor_side_effect(ctx, v1657);
                    let v1659 = Some(v1658);
                    // Rule at src\isa\pulley_shared\lower.isle line 1864.
                    return v1659;
                }
                _ => {}
            }
        }
        &InstructionData::Shuffle {
            opcode: ref v1606,
            args: ref v1607,
            imm: v1608,
        } => {
            if let &Opcode::Shuffle = v1606 {
                let v107 = C::first_result(ctx, arg0);
                if let Some(v108) = v107 {
                    let v109 = C::value_type(ctx, v108);
                    if v109 == I8X16 {
                        let v1612 = C::u128_from_immediate(ctx, v1608);
                        if let Some(v1613) = v1612 {
                            let v1609 = C::unpack_value_array_2(ctx, v1607);
                            let v1614 = constructor_put_in_vreg(ctx, v1609.0);
                            let v1615 = constructor_put_in_vreg(ctx, v1609.1);
                            let v1616 = constructor_pulley_vshuffle(ctx, v1614, v1615, v1613);
                            let v1617 = constructor_output_vreg(ctx, v1616);
                            let v1618 = Some(v1617);
                            // Rule at src\isa\pulley_shared\lower.isle line 1833.
                            return v1618;
                        }
                    }
                }
            }
        }
        &InstructionData::StackLoad {
            opcode: ref v968,
            stack_slot: v969,
            offset: v970,
        } => {
            if let &Opcode::StackAddr = v968 {
                let v971 = constructor_lower_stack_addr(ctx, v969, v970);
                let v972 = constructor_output_xreg(ctx, v971);
                let v973 = Some(v972);
                // Rule at src\isa\pulley_shared\lower.isle line 1295.
                return v973;
            }
        }
        &InstructionData::Store {
            opcode: ref v922,
            args: ref v923,
            flags: v924,
            offset: v925,
        } => {
            match v922 {
                &Opcode::Store => {
                    let v926 = C::unpack_value_array_2(ctx, v923);
                    let v929 = C::value_type(ctx, v926.0);
                    if v929 == I128 {
                        let v956 = C::put_in_regs(ctx, v926.0);
                        let v957 = C::value_regs_get(ctx, v956, 0x0_usize);
                        let v958 = C::xreg_new(ctx, v957);
                        let v959 = C::value_regs_get(ctx, v956, 0x1_usize);
                        let v960 = C::xreg_new(ctx, v959);
                        let v961 = constructor_put_in_xreg(ctx, v926.1);
                        let v964 = Amode::RegOffset {
                            base: v961,
                            offset: 0_i32,
                        };
                        let v962 = Amode::RegOffset {
                            base: v961,
                            offset: 8_i32,
                        };
                        let v965 = &constructor_emit_store_i128(ctx, v924, v958, v960, &v964, &v962);
                        let v966 = constructor_side_effect(ctx, v965);
                        let v967 = Some(v966);
                        // Rule at src\isa\pulley_shared\lower.isle line 1228.
                        return v967;
                    }
                    let v951 = C::ty_vec128(ctx, v929);
                    if let Some(v952) = v951 {
                        let v953 = &constructor_gen_store(ctx, v926.0, v926.1, v925, v924, v952);
                        let v954 = constructor_side_effect(ctx, v953);
                        let v955 = Some(v954);
                        // Rule at src\isa\pulley_shared\lower.isle line 1223.
                        return v955;
                    }
                    let v937 = C::ty_scalar_float(ctx, v929);
                    if let Some(v938) = v937 {
                        let v939 = &constructor_gen_store(ctx, v926.0, v926.1, v925, v924, v938);
                        let v940 = constructor_side_effect(ctx, v939);
                        let v941 = Some(v940);
                        // Rule at src\isa\pulley_shared\lower.isle line 1211.
                        return v941;
                    }
                    let v930 = C::ty_int(ctx, v929);
                    if let Some(v931) = v930 {
                        let v932 = C::fits_in_64(ctx, v931);
                        if let Some(v933) = v932 {
                            let v934 = &constructor_gen_store(ctx, v926.0, v926.1, v925, v924, v933);
                            let v935 = constructor_side_effect(ctx, v934);
                            let v936 = Some(v935);
                            // Rule at src\isa\pulley_shared\lower.isle line 1208.
                            return v936;
                        }
                    }
                }
                &Opcode::Istore8 => {
                    let v926 = C::unpack_value_array_2(ctx, v923);
                    let v942 = &constructor_gen_store(ctx, v926.0, v926.1, v925, v924, I8);
                    let v943 = constructor_side_effect(ctx, v942);
                    let v944 = Some(v943);
                    // Rule at src\isa\pulley_shared\lower.isle line 1214.
                    return v944;
                }
                &Opcode::Istore16 => {
                    let v926 = C::unpack_value_array_2(ctx, v923);
                    let v945 = &constructor_gen_store(ctx, v926.0, v926.1, v925, v924, I16);
                    let v946 = constructor_side_effect(ctx, v945);
                    let v947 = Some(v946);
                    // Rule at src\isa\pulley_shared\lower.isle line 1217.
                    return v947;
                }
                &Opcode::Istore32 => {
                    let v926 = C::unpack_value_array_2(ctx, v923);
                    let v948 = &constructor_gen_store(ctx, v926.0, v926.1, v925, v924, I32);
                    let v949 = constructor_side_effect(ctx, v948);
                    let v950 = Some(v949);
                    // Rule at src\isa\pulley_shared\lower.isle line 1220.
                    return v950;
                }
                _ => {}
            }
        }
        &InstructionData::Ternary {
            opcode: ref v653,
            args: ref v654,
        } => {
            match v653 {
                &Opcode::Select => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v593 = C::ty_vec128(ctx, v109);
                        if let Some(v594) = v593 {
                            let v655 = C::unpack_value_array_3(ctx, v654);
                            let v1051 = &constructor_lower_cond(ctx, v655.0);
                            let v1052 = constructor_emit_cond(ctx, v1051);
                            let v1069 = constructor_put_in_vreg(ctx, v655.1);
                            let v1070 = constructor_put_in_vreg(ctx, v655.2);
                            let v1071 = constructor_pulley_vselect(ctx, v1052, v1069, v1070);
                            let v1072 = constructor_output_vreg(ctx, v1071);
                            let v1073 = Some(v1072);
                            // Rule at src\isa\pulley_shared\lower.isle line 1380.
                            return v1073;
                        }
                        match v109 {
                            I64 => {
                                let v655 = C::unpack_value_array_3(ctx, v654);
                                let v1051 = &constructor_lower_cond(ctx, v655.0);
                                let v1052 = constructor_emit_cond(ctx, v1051);
                                let v1053 = constructor_put_in_xreg(ctx, v655.1);
                                let v1054 = constructor_put_in_xreg(ctx, v655.2);
                                let v1058 = constructor_pulley_xselect64(ctx, v1052, v1053, v1054);
                                let v1059 = constructor_output_xreg(ctx, v1058);
                                let v1060 = Some(v1059);
                                // Rule at src\isa\pulley_shared\lower.isle line 1371.
                                return v1060;
                            }
                            F32 => {
                                let v655 = C::unpack_value_array_3(ctx, v654);
                                let v1051 = &constructor_lower_cond(ctx, v655.0);
                                let v1052 = constructor_emit_cond(ctx, v1051);
                                let v1061 = constructor_put_in_freg(ctx, v655.1);
                                let v1062 = constructor_put_in_freg(ctx, v655.2);
                                let v1063 = constructor_pulley_fselect32(ctx, v1052, v1061, v1062);
                                let v1064 = constructor_output_freg(ctx, v1063);
                                let v1065 = Some(v1064);
                                // Rule at src\isa\pulley_shared\lower.isle line 1374.
                                return v1065;
                            }
                            F64 => {
                                let v655 = C::unpack_value_array_3(ctx, v654);
                                let v1051 = &constructor_lower_cond(ctx, v655.0);
                                let v1052 = constructor_emit_cond(ctx, v1051);
                                let v1061 = constructor_put_in_freg(ctx, v655.1);
                                let v1062 = constructor_put_in_freg(ctx, v655.2);
                                let v1066 = constructor_pulley_fselect64(ctx, v1052, v1061, v1062);
                                let v1067 = constructor_output_freg(ctx, v1066);
                                let v1068 = Some(v1067);
                                // Rule at src\isa\pulley_shared\lower.isle line 1377.
                                return v1068;
                            }
                            _ => {}
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v655 = C::unpack_value_array_3(ctx, v654);
                                let v1051 = &constructor_lower_cond(ctx, v655.0);
                                let v1052 = constructor_emit_cond(ctx, v1051);
                                let v1053 = constructor_put_in_xreg(ctx, v655.1);
                                let v1054 = constructor_put_in_xreg(ctx, v655.2);
                                let v1055 = constructor_pulley_xselect32(ctx, v1052, v1053, v1054);
                                let v1056 = constructor_output_xreg(ctx, v1055);
                                let v1057 = Some(v1056);
                                // Rule at src\isa\pulley_shared\lower.isle line 1368.
                                return v1057;
                            }
                        }
                    }
                }
                &Opcode::Bitselect => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v593 = C::ty_vec128(ctx, v109);
                        if let Some(v594) = v593 {
                            let v655 = C::unpack_value_array_3(ctx, v654);
                            let v659 = constructor_put_in_vreg(ctx, v655.0);
                            let v660 = constructor_put_in_vreg(ctx, v655.1);
                            let v661 = constructor_put_in_vreg(ctx, v655.2);
                            let v662 = constructor_pulley_vbitselect128(ctx, v659, v660, v661);
                            let v663 = constructor_output_vreg(ctx, v662);
                            let v664 = Some(v663);
                            // Rule at src\isa\pulley_shared\lower.isle line 663.
                            return v664;
                        }
                    }
                }
                &Opcode::Fma => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32X4 => {
                                let v655 = C::unpack_value_array_3(ctx, v654);
                                let v659 = constructor_put_in_vreg(ctx, v655.0);
                                let v660 = constructor_put_in_vreg(ctx, v655.1);
                                let v661 = constructor_put_in_vreg(ctx, v655.2);
                                let v1622 = constructor_pulley_vfma32x4(ctx, v659, v660, v661);
                                let v1623 = constructor_output_vreg(ctx, v1622);
                                let v1624 = Some(v1623);
                                // Rule at src\isa\pulley_shared\lower.isle line 1842.
                                return v1624;
                            }
                            F64X2 => {
                                let v655 = C::unpack_value_array_3(ctx, v654);
                                let v659 = constructor_put_in_vreg(ctx, v655.0);
                                let v660 = constructor_put_in_vreg(ctx, v655.1);
                                let v661 = constructor_put_in_vreg(ctx, v655.2);
                                let v1625 = constructor_pulley_vfma64x2(ctx, v659, v660, v661);
                                let v1626 = constructor_output_vreg(ctx, v1625);
                                let v1627 = Some(v1626);
                                // Rule at src\isa\pulley_shared\lower.isle line 1843.
                                return v1627;
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            }
        }
        &InstructionData::TernaryImm8 {
            opcode: ref v1554,
            args: ref v1555,
            imm: v1556,
        } => {
            if let &Opcode::Insertlane = v1554 {
                let v1557 = C::unpack_value_array_2(ctx, v1555);
                let v1560 = C::value_type(ctx, v1557.0);
                match v1560 {
                    I8X16 => {
                        let v1562 = constructor_put_in_vreg(ctx, v1557.0);
                        let v1563 = constructor_put_in_xreg(ctx, v1557.1);
                        let v1561 = C::u8_from_uimm8(ctx, v1556);
                        let v1564 = constructor_pulley_vinsertx8(ctx, v1562, v1563, v1561);
                        let v1565 = constructor_output_vreg(ctx, v1564);
                        let v1566 = Some(v1565);
                        // Rule at src\isa\pulley_shared\lower.isle line 1799.
                        return v1566;
                    }
                    I16X8 => {
                        let v1562 = constructor_put_in_vreg(ctx, v1557.0);
                        let v1563 = constructor_put_in_xreg(ctx, v1557.1);
                        let v1561 = C::u8_from_uimm8(ctx, v1556);
                        let v1567 = constructor_pulley_vinsertx16(ctx, v1562, v1563, v1561);
                        let v1568 = constructor_output_vreg(ctx, v1567);
                        let v1569 = Some(v1568);
                        // Rule at src\isa\pulley_shared\lower.isle line 1801.
                        return v1569;
                    }
                    I32X4 => {
                        let v1562 = constructor_put_in_vreg(ctx, v1557.0);
                        let v1563 = constructor_put_in_xreg(ctx, v1557.1);
                        let v1561 = C::u8_from_uimm8(ctx, v1556);
                        let v1570 = constructor_pulley_vinsertx32(ctx, v1562, v1563, v1561);
                        let v1571 = constructor_output_vreg(ctx, v1570);
                        let v1572 = Some(v1571);
                        // Rule at src\isa\pulley_shared\lower.isle line 1803.
                        return v1572;
                    }
                    I64X2 => {
                        let v1562 = constructor_put_in_vreg(ctx, v1557.0);
                        let v1563 = constructor_put_in_xreg(ctx, v1557.1);
                        let v1561 = C::u8_from_uimm8(ctx, v1556);
                        let v1573 = constructor_pulley_vinsertx64(ctx, v1562, v1563, v1561);
                        let v1574 = constructor_output_vreg(ctx, v1573);
                        let v1575 = Some(v1574);
                        // Rule at src\isa\pulley_shared\lower.isle line 1805.
                        return v1575;
                    }
                    F32X4 => {
                        let v1562 = constructor_put_in_vreg(ctx, v1557.0);
                        let v1576 = constructor_put_in_freg(ctx, v1557.1);
                        let v1561 = C::u8_from_uimm8(ctx, v1556);
                        let v1577 = constructor_pulley_vinsertf32(ctx, v1562, v1576, v1561);
                        let v1578 = constructor_output_vreg(ctx, v1577);
                        let v1579 = Some(v1578);
                        // Rule at src\isa\pulley_shared\lower.isle line 1807.
                        return v1579;
                    }
                    F64X2 => {
                        let v1562 = constructor_put_in_vreg(ctx, v1557.0);
                        let v1576 = constructor_put_in_freg(ctx, v1557.1);
                        let v1561 = C::u8_from_uimm8(ctx, v1556);
                        let v1580 = constructor_pulley_vinsertf64(ctx, v1562, v1576, v1561);
                        let v1581 = constructor_output_vreg(ctx, v1580);
                        let v1582 = Some(v1581);
                        // Rule at src\isa\pulley_shared\lower.isle line 1809.
                        return v1582;
                    }
                    _ => {}
                }
            }
        }
        &InstructionData::Trap {
            opcode: ref v2,
            code: ref v3,
        } => {
            if let &Opcode::Trap = v2 {
                let v4 = &constructor_pulley_trap(ctx, v3);
                let v5 = constructor_side_effect(ctx, v4);
                let v6 = Some(v5);
                // Rule at src\isa\pulley_shared\lower.isle line 110.
                return v6;
            }
        }
        &InstructionData::Unary {
            opcode: ref v640,
            arg: v641,
        } => {
            match v640 {
                &Opcode::Splat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8X16 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1415 = constructor_pulley_vsplatx8(ctx, v642);
                                let v1416 = constructor_output_vreg(ctx, v1415);
                                let v1417 = Some(v1416);
                                // Rule at src\isa\pulley_shared\lower.isle line 1699.
                                return v1417;
                            }
                            I16X8 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1418 = constructor_pulley_vsplatx16(ctx, v642);
                                let v1419 = constructor_output_vreg(ctx, v1418);
                                let v1420 = Some(v1419);
                                // Rule at src\isa\pulley_shared\lower.isle line 1700.
                                return v1420;
                            }
                            I32X4 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1421 = constructor_pulley_vsplatx32(ctx, v642);
                                let v1422 = constructor_output_vreg(ctx, v1421);
                                let v1423 = Some(v1422);
                                // Rule at src\isa\pulley_shared\lower.isle line 1701.
                                return v1423;
                            }
                            I64X2 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1424 = constructor_pulley_vsplatx64(ctx, v642);
                                let v1425 = constructor_output_vreg(ctx, v1424);
                                let v1426 = Some(v1425);
                                // Rule at src\isa\pulley_shared\lower.isle line 1702.
                                return v1426;
                            }
                            F32X4 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1427 = constructor_pulley_vsplatf32(ctx, v1096);
                                let v1428 = constructor_output_vreg(ctx, v1427);
                                let v1429 = Some(v1428);
                                // Rule at src\isa\pulley_shared\lower.isle line 1703.
                                return v1429;
                            }
                            F64X2 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1430 = constructor_pulley_vsplatf64(ctx, v1096);
                                let v1431 = constructor_output_vreg(ctx, v1430);
                                let v1432 = Some(v1431);
                                // Rule at src\isa\pulley_shared\lower.isle line 1704.
                                return v1432;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::VanyTrue => {
                    let v725 = C::value_type(ctx, v641);
                    match v725 {
                        I8X16 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1457 = constructor_pulley_vanytrue8x16(ctx, v649);
                            let v1458 = constructor_output_xreg(ctx, v1457);
                            let v1459 = Some(v1458);
                            // Rule at src\isa\pulley_shared\lower.isle line 1728.
                            return v1459;
                        }
                        I16X8 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1460 = constructor_pulley_vanytrue16x8(ctx, v649);
                            let v1461 = constructor_output_xreg(ctx, v1460);
                            let v1462 = Some(v1461);
                            // Rule at src\isa\pulley_shared\lower.isle line 1729.
                            return v1462;
                        }
                        I32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1463 = constructor_pulley_vanytrue32x4(ctx, v649);
                            let v1464 = constructor_output_xreg(ctx, v1463);
                            let v1465 = Some(v1464);
                            // Rule at src\isa\pulley_shared\lower.isle line 1730.
                            return v1465;
                        }
                        I64X2 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1466 = constructor_pulley_vanytrue64x2(ctx, v649);
                            let v1467 = constructor_output_xreg(ctx, v1466);
                            let v1468 = Some(v1467);
                            // Rule at src\isa\pulley_shared\lower.isle line 1731.
                            return v1468;
                        }
                        F32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1463 = constructor_pulley_vanytrue32x4(ctx, v649);
                            let v1464 = constructor_output_xreg(ctx, v1463);
                            let v1465 = Some(v1464);
                            // Rule at src\isa\pulley_shared\lower.isle line 1732.
                            return v1465;
                        }
                        F64X2 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1466 = constructor_pulley_vanytrue64x2(ctx, v649);
                            let v1467 = constructor_output_xreg(ctx, v1466);
                            let v1468 = Some(v1467);
                            // Rule at src\isa\pulley_shared\lower.isle line 1733.
                            return v1468;
                        }
                        _ => {}
                    }
                }
                &Opcode::VallTrue => {
                    let v725 = C::value_type(ctx, v641);
                    match v725 {
                        I8X16 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1445 = constructor_pulley_valltrue8x16(ctx, v649);
                            let v1446 = constructor_output_xreg(ctx, v1445);
                            let v1447 = Some(v1446);
                            // Rule at src\isa\pulley_shared\lower.isle line 1719.
                            return v1447;
                        }
                        I16X8 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1448 = constructor_pulley_valltrue16x8(ctx, v649);
                            let v1449 = constructor_output_xreg(ctx, v1448);
                            let v1450 = Some(v1449);
                            // Rule at src\isa\pulley_shared\lower.isle line 1720.
                            return v1450;
                        }
                        I32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1451 = constructor_pulley_valltrue32x4(ctx, v649);
                            let v1452 = constructor_output_xreg(ctx, v1451);
                            let v1453 = Some(v1452);
                            // Rule at src\isa\pulley_shared\lower.isle line 1721.
                            return v1453;
                        }
                        I64X2 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1454 = constructor_pulley_valltrue64x2(ctx, v649);
                            let v1455 = constructor_output_xreg(ctx, v1454);
                            let v1456 = Some(v1455);
                            // Rule at src\isa\pulley_shared\lower.isle line 1722.
                            return v1456;
                        }
                        F32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1451 = constructor_pulley_valltrue32x4(ctx, v649);
                            let v1452 = constructor_output_xreg(ctx, v1451);
                            let v1453 = Some(v1452);
                            // Rule at src\isa\pulley_shared\lower.isle line 1723.
                            return v1453;
                        }
                        F64X2 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1454 = constructor_pulley_valltrue64x2(ctx, v649);
                            let v1455 = constructor_output_xreg(ctx, v1454);
                            let v1456 = Some(v1455);
                            // Rule at src\isa\pulley_shared\lower.isle line 1724.
                            return v1456;
                        }
                        _ => {}
                    }
                }
                &Opcode::VhighBits => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v725 = C::value_type(ctx, v641);
                            match v725 {
                                I8X16 => {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1433 = constructor_pulley_vbitmask8x16(ctx, v649);
                                    let v1434 = constructor_output_xreg(ctx, v1433);
                                    let v1435 = Some(v1434);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1708.
                                    return v1435;
                                }
                                I16X8 => {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1436 = constructor_pulley_vbitmask16x8(ctx, v649);
                                    let v1437 = constructor_output_xreg(ctx, v1436);
                                    let v1438 = Some(v1437);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1710.
                                    return v1438;
                                }
                                I32X4 => {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1439 = constructor_pulley_vbitmask32x4(ctx, v649);
                                    let v1440 = constructor_output_xreg(ctx, v1439);
                                    let v1441 = Some(v1440);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1712.
                                    return v1441;
                                }
                                I64X2 => {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1442 = constructor_pulley_vbitmask64x2(ctx, v649);
                                    let v1443 = constructor_output_xreg(ctx, v1442);
                                    let v1444 = Some(v1443);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1714.
                                    return v1444;
                                }
                                _ => {}
                            }
                        }
                    }
                }
                &Opcode::Ineg => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1354 = constructor_pulley_xneg64(ctx, v642);
                                let v1355 = constructor_output_xreg(ctx, v1354);
                                let v1356 = Some(v1355);
                                // Rule at src\isa\pulley_shared\lower.isle line 1660.
                                return v1356;
                            }
                            I8X16 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1357 = constructor_pulley_vneg8x16(ctx, v649);
                                let v1358 = constructor_output_vreg(ctx, v1357);
                                let v1359 = Some(v1358);
                                // Rule at src\isa\pulley_shared\lower.isle line 1664.
                                return v1359;
                            }
                            I16X8 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1360 = constructor_pulley_vneg16x8(ctx, v649);
                                let v1361 = constructor_output_vreg(ctx, v1360);
                                let v1362 = Some(v1361);
                                // Rule at src\isa\pulley_shared\lower.isle line 1665.
                                return v1362;
                            }
                            I32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1363 = constructor_pulley_vneg32x4(ctx, v649);
                                let v1364 = constructor_output_vreg(ctx, v1363);
                                let v1365 = Some(v1364);
                                // Rule at src\isa\pulley_shared\lower.isle line 1666.
                                return v1365;
                            }
                            I64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1366 = constructor_pulley_vneg64x2(ctx, v649);
                                let v1367 = constructor_output_vreg(ctx, v1366);
                                let v1368 = Some(v1367);
                                // Rule at src\isa\pulley_shared\lower.isle line 1667.
                                return v1368;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v984 = constructor_sext32(ctx, v641);
                            let v1351 = constructor_pulley_xneg32(ctx, v984);
                            let v1352 = constructor_output_xreg(ctx, v1351);
                            let v1353 = Some(v1352);
                            // Rule at src\isa\pulley_shared\lower.isle line 1659.
                            return v1353;
                        }
                    }
                }
                &Opcode::Iabs => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1400 = constructor_pulley_xabs64(ctx, v642);
                                let v1401 = constructor_output_xreg(ctx, v1400);
                                let v1402 = Some(v1401);
                                // Rule at src\isa\pulley_shared\lower.isle line 1691.
                                return v1402;
                            }
                            I8X16 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1403 = constructor_pulley_vabs8x16(ctx, v649);
                                let v1404 = constructor_output_vreg(ctx, v1403);
                                let v1405 = Some(v1404);
                                // Rule at src\isa\pulley_shared\lower.isle line 1692.
                                return v1405;
                            }
                            I16X8 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1406 = constructor_pulley_vabs16x8(ctx, v649);
                                let v1407 = constructor_output_vreg(ctx, v1406);
                                let v1408 = Some(v1407);
                                // Rule at src\isa\pulley_shared\lower.isle line 1693.
                                return v1408;
                            }
                            I32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1409 = constructor_pulley_vabs32x4(ctx, v649);
                                let v1410 = constructor_output_vreg(ctx, v1409);
                                let v1411 = Some(v1410);
                                // Rule at src\isa\pulley_shared\lower.isle line 1694.
                                return v1411;
                            }
                            I64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1412 = constructor_pulley_vabs64x2(ctx, v649);
                                let v1413 = constructor_output_vreg(ctx, v1412);
                                let v1414 = Some(v1413);
                                // Rule at src\isa\pulley_shared\lower.isle line 1695.
                                return v1414;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v984 = constructor_sext32(ctx, v641);
                            let v1397 = constructor_pulley_xabs32(ctx, v984);
                            let v1398 = constructor_output_xreg(ctx, v1397);
                            let v1399 = Some(v1398);
                            // Rule at src\isa\pulley_shared\lower.isle line 1690.
                            return v1399;
                        }
                    }
                }
                &Opcode::Bnot => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v593 = C::ty_vec128(ctx, v109);
                        if let Some(v594) = v593 {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v650 = constructor_pulley_vbnot128(ctx, v649);
                            let v651 = constructor_output_vreg(ctx, v650);
                            let v652 = Some(v651);
                            // Rule at src\isa\pulley_shared\lower.isle line 658.
                            return v652;
                        }
                        if v109 == I64 {
                            let v642 = constructor_put_in_xreg(ctx, v641);
                            let v646 = constructor_pulley_xbnot64(ctx, v642);
                            let v647 = constructor_output_xreg(ctx, v646);
                            let v648 = Some(v647);
                            // Rule at src\isa\pulley_shared\lower.isle line 655.
                            return v648;
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v642 = constructor_put_in_xreg(ctx, v641);
                            let v643 = constructor_pulley_xbnot32(ctx, v642);
                            let v644 = constructor_output_xreg(ctx, v643);
                            let v645 = Some(v644);
                            // Rule at src\isa\pulley_shared\lower.isle line 652.
                            return v645;
                        }
                    }
                }
                &Opcode::Clz => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8 => {
                                let v728 = constructor_zext32(ctx, v641);
                                let v755 = constructor_pulley_xclz32(ctx, v728);
                                let v757 = constructor_pulley_xsub32_u8(ctx, v755, 0x18_u8);
                                let v758 = constructor_output_xreg(ctx, v757);
                                let v759 = Some(v758);
                                // Rule at src\isa\pulley_shared\lower.isle line 722.
                                return v759;
                            }
                            I16 => {
                                let v728 = constructor_zext32(ctx, v641);
                                let v755 = constructor_pulley_xclz32(ctx, v728);
                                let v761 = constructor_pulley_xsub32_u8(ctx, v755, 0x10_u8);
                                let v762 = constructor_output_xreg(ctx, v761);
                                let v763 = Some(v762);
                                // Rule at src\isa\pulley_shared\lower.isle line 724.
                                return v763;
                            }
                            I32 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v764 = constructor_pulley_xclz32(ctx, v642);
                                let v765 = constructor_output_xreg(ctx, v764);
                                let v766 = Some(v765);
                                // Rule at src\isa\pulley_shared\lower.isle line 726.
                                return v766;
                            }
                            I64 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v767 = constructor_pulley_xclz64(ctx, v642);
                                let v768 = constructor_output_xreg(ctx, v767);
                                let v769 = Some(v768);
                                // Rule at src\isa\pulley_shared\lower.isle line 727.
                                return v769;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ctz => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I8 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v740 = constructor_pulley_xbor32_s32(ctx, v642, 256_i32);
                                let v741 = constructor_pulley_xctz32(ctx, v740);
                                let v742 = constructor_output_xreg(ctx, v741);
                                let v743 = Some(v742);
                                // Rule at src\isa\pulley_shared\lower.isle line 713.
                                return v743;
                            }
                            I16 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v745 = constructor_pulley_xbor32_s32(ctx, v642, 65536_i32);
                                let v746 = constructor_pulley_xctz32(ctx, v745);
                                let v747 = constructor_output_xreg(ctx, v746);
                                let v748 = Some(v747);
                                // Rule at src\isa\pulley_shared\lower.isle line 715.
                                return v748;
                            }
                            I32 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v749 = constructor_pulley_xctz32(ctx, v642);
                                let v750 = constructor_output_xreg(ctx, v749);
                                let v751 = Some(v750);
                                // Rule at src\isa\pulley_shared\lower.isle line 717.
                                return v751;
                            }
                            I64 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v752 = constructor_pulley_xctz64(ctx, v642);
                                let v753 = constructor_output_xreg(ctx, v752);
                                let v754 = Some(v753);
                                // Rule at src\isa\pulley_shared\lower.isle line 718.
                                return v754;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Bswap => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I16 => {
                                let v405 = C::u64_try_into_u8(ctx, 0x10_u64);
                                if let Some(v406) = v405 {
                                    let v407 = C::u6_from_u8(ctx, v406);
                                    if let Some(v408) = v407 {
                                        let v642 = constructor_put_in_xreg(ctx, v641);
                                        let v1388 = constructor_pulley_bswap32(ctx, v642);
                                        let v1389 = constructor_pulley_xshr32_u_u6(ctx, v1388, v408);
                                        let v1390 = constructor_output_xreg(ctx, v1389);
                                        let v1391 = Some(v1390);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1682.
                                        return v1391;
                                    }
                                }
                            }
                            I32 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1388 = constructor_pulley_bswap32(ctx, v642);
                                let v1392 = constructor_output_xreg(ctx, v1388);
                                let v1393 = Some(v1392);
                                // Rule at src\isa\pulley_shared\lower.isle line 1685.
                                return v1393;
                            }
                            I64 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v1394 = constructor_pulley_bswap64(ctx, v642);
                                let v1395 = constructor_output_xreg(ctx, v1394);
                                let v1396 = Some(v1395);
                                // Rule at src\isa\pulley_shared\lower.isle line 1686.
                                return v1396;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Popcnt => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v642 = constructor_put_in_xreg(ctx, v641);
                                let v773 = constructor_pulley_xpopcnt64(ctx, v642);
                                let v774 = constructor_output_xreg(ctx, v773);
                                let v775 = Some(v774);
                                // Rule at src\isa\pulley_shared\lower.isle line 732.
                                return v775;
                            }
                            I8X16 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v776 = constructor_pulley_vpopcnt8x16(ctx, v649);
                                let v777 = constructor_output_vreg(ctx, v776);
                                let v778 = Some(v777);
                                // Rule at src\isa\pulley_shared\lower.isle line 733.
                                return v778;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v728 = constructor_zext32(ctx, v641);
                            let v770 = constructor_pulley_xpopcnt32(ctx, v728);
                            let v771 = constructor_output_xreg(ctx, v770);
                            let v772 = Some(v771);
                            // Rule at src\isa\pulley_shared\lower.isle line 731.
                            return v772;
                        }
                    }
                }
                &Opcode::Sqrt => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1327 = constructor_pulley_fsqrt32(ctx, v1096);
                                let v1328 = constructor_output_freg(ctx, v1327);
                                let v1329 = Some(v1328);
                                // Rule at src\isa\pulley_shared\lower.isle line 1643.
                                return v1329;
                            }
                            F64 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1330 = constructor_pulley_fsqrt64(ctx, v1096);
                                let v1331 = constructor_output_freg(ctx, v1330);
                                let v1332 = Some(v1331);
                                // Rule at src\isa\pulley_shared\lower.isle line 1644.
                                return v1332;
                            }
                            F32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1333 = constructor_pulley_vsqrt32x4(ctx, v649);
                                let v1334 = constructor_output_vreg(ctx, v1333);
                                let v1335 = Some(v1334);
                                // Rule at src\isa\pulley_shared\lower.isle line 1645.
                                return v1335;
                            }
                            F64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1336 = constructor_pulley_vsqrt64x2(ctx, v649);
                                let v1337 = constructor_output_vreg(ctx, v1336);
                                let v1338 = Some(v1337);
                                // Rule at src\isa\pulley_shared\lower.isle line 1647.
                                return v1338;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fneg => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1339 = constructor_pulley_fneg32(ctx, v1096);
                                let v1340 = constructor_output_freg(ctx, v1339);
                                let v1341 = Some(v1340);
                                // Rule at src\isa\pulley_shared\lower.isle line 1652.
                                return v1341;
                            }
                            F64 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1342 = constructor_pulley_fneg64(ctx, v1096);
                                let v1343 = constructor_output_freg(ctx, v1342);
                                let v1344 = Some(v1343);
                                // Rule at src\isa\pulley_shared\lower.isle line 1653.
                                return v1344;
                            }
                            F32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1345 = constructor_pulley_vnegf32x4(ctx, v649);
                                let v1346 = constructor_output_vreg(ctx, v1345);
                                let v1347 = Some(v1346);
                                // Rule at src\isa\pulley_shared\lower.isle line 1654.
                                return v1347;
                            }
                            F64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1348 = constructor_pulley_vnegf64x2(ctx, v649);
                                let v1349 = constructor_output_vreg(ctx, v1348);
                                let v1350 = Some(v1349);
                                // Rule at src\isa\pulley_shared\lower.isle line 1655.
                                return v1350;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Fabs => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1369 = constructor_pulley_fabs32(ctx, v1096);
                                let v1370 = constructor_output_freg(ctx, v1369);
                                let v1371 = Some(v1370);
                                // Rule at src\isa\pulley_shared\lower.isle line 1671.
                                return v1371;
                            }
                            F64 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1372 = constructor_pulley_fabs64(ctx, v1096);
                                let v1373 = constructor_output_freg(ctx, v1372);
                                let v1374 = Some(v1373);
                                // Rule at src\isa\pulley_shared\lower.isle line 1672.
                                return v1374;
                            }
                            F32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1375 = constructor_pulley_vabsf32x4(ctx, v649);
                                let v1376 = constructor_output_vreg(ctx, v1375);
                                let v1377 = Some(v1376);
                                // Rule at src\isa\pulley_shared\lower.isle line 1673.
                                return v1377;
                            }
                            F64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1378 = constructor_pulley_vabsf64x2(ctx, v649);
                                let v1379 = constructor_output_vreg(ctx, v1378);
                                let v1380 = Some(v1379);
                                // Rule at src\isa\pulley_shared\lower.isle line 1674.
                                return v1380;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Ceil => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1303 = constructor_pulley_fceil32(ctx, v1096);
                                let v1304 = constructor_output_freg(ctx, v1303);
                                let v1305 = Some(v1304);
                                // Rule at src\isa\pulley_shared\lower.isle line 1625.
                                return v1305;
                            }
                            F64 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1306 = constructor_pulley_fceil64(ctx, v1096);
                                let v1307 = constructor_output_freg(ctx, v1306);
                                let v1308 = Some(v1307);
                                // Rule at src\isa\pulley_shared\lower.isle line 1626.
                                return v1308;
                            }
                            F32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1312 = constructor_pulley_vceil32x4(ctx, v649);
                                let v1313 = constructor_output_vreg(ctx, v1312);
                                let v1314 = Some(v1313);
                                // Rule at src\isa\pulley_shared\lower.isle line 1629.
                                return v1314;
                            }
                            F64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1309 = constructor_pulley_vceil64x2(ctx, v649);
                                let v1310 = constructor_output_vreg(ctx, v1309);
                                let v1311 = Some(v1310);
                                // Rule at src\isa\pulley_shared\lower.isle line 1627.
                                return v1311;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Floor => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1291 = constructor_pulley_ffloor32(ctx, v1096);
                                let v1292 = constructor_output_freg(ctx, v1291);
                                let v1293 = Some(v1292);
                                // Rule at src\isa\pulley_shared\lower.isle line 1616.
                                return v1293;
                            }
                            F64 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1294 = constructor_pulley_ffloor64(ctx, v1096);
                                let v1295 = constructor_output_freg(ctx, v1294);
                                let v1296 = Some(v1295);
                                // Rule at src\isa\pulley_shared\lower.isle line 1617.
                                return v1296;
                            }
                            F32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1297 = constructor_pulley_vfloor32x4(ctx, v649);
                                let v1298 = constructor_output_vreg(ctx, v1297);
                                let v1299 = Some(v1298);
                                // Rule at src\isa\pulley_shared\lower.isle line 1618.
                                return v1299;
                            }
                            F64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1300 = constructor_pulley_vfloor64x2(ctx, v649);
                                let v1301 = constructor_output_vreg(ctx, v1300);
                                let v1302 = Some(v1301);
                                // Rule at src\isa\pulley_shared\lower.isle line 1620.
                                return v1302;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Trunc => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1279 = constructor_pulley_ftrunc32(ctx, v1096);
                                let v1280 = constructor_output_freg(ctx, v1279);
                                let v1281 = Some(v1280);
                                // Rule at src\isa\pulley_shared\lower.isle line 1609.
                                return v1281;
                            }
                            F64 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1282 = constructor_pulley_ftrunc64(ctx, v1096);
                                let v1283 = constructor_output_freg(ctx, v1282);
                                let v1284 = Some(v1283);
                                // Rule at src\isa\pulley_shared\lower.isle line 1610.
                                return v1284;
                            }
                            F32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1285 = constructor_pulley_vtrunc32x4(ctx, v649);
                                let v1286 = constructor_output_vreg(ctx, v1285);
                                let v1287 = Some(v1286);
                                // Rule at src\isa\pulley_shared\lower.isle line 1611.
                                return v1287;
                            }
                            F64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1288 = constructor_pulley_vtrunc64x2(ctx, v649);
                                let v1289 = constructor_output_vreg(ctx, v1288);
                                let v1290 = Some(v1289);
                                // Rule at src\isa\pulley_shared\lower.isle line 1612.
                                return v1290;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Nearest => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1315 = constructor_pulley_fnearest32(ctx, v1096);
                                let v1316 = constructor_output_freg(ctx, v1315);
                                let v1317 = Some(v1316);
                                // Rule at src\isa\pulley_shared\lower.isle line 1634.
                                return v1317;
                            }
                            F64 => {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1318 = constructor_pulley_fnearest64(ctx, v1096);
                                let v1319 = constructor_output_freg(ctx, v1318);
                                let v1320 = Some(v1319);
                                // Rule at src\isa\pulley_shared\lower.isle line 1635.
                                return v1320;
                            }
                            F32X4 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1321 = constructor_pulley_vnearest32x4(ctx, v649);
                                let v1322 = constructor_output_vreg(ctx, v1321);
                                let v1323 = Some(v1322);
                                // Rule at src\isa\pulley_shared\lower.isle line 1636.
                                return v1323;
                            }
                            F64X2 => {
                                let v649 = constructor_put_in_vreg(ctx, v641);
                                let v1324 = constructor_pulley_vnearest64x2(ctx, v649);
                                let v1325 = constructor_output_vreg(ctx, v1324);
                                let v1326 = Some(v1325);
                                // Rule at src\isa\pulley_shared\lower.isle line 1638.
                                return v1326;
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::ScalarToVector => {
                    let v725 = C::value_type(ctx, v641);
                    match v725 {
                        I8 => {
                            let v1584 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1585 = constructor_put_in_xreg(ctx, v641);
                            let v1587 = constructor_pulley_vinsertx8(ctx, v1584, v1585, 0x0_u8);
                            let v1588 = constructor_output_vreg(ctx, v1587);
                            let v1589 = Some(v1588);
                            // Rule at src\isa\pulley_shared\lower.isle line 1818.
                            return v1589;
                        }
                        I16 => {
                            let v1584 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1585 = constructor_put_in_xreg(ctx, v641);
                            let v1590 = constructor_pulley_vinsertx16(ctx, v1584, v1585, 0x0_u8);
                            let v1591 = constructor_output_vreg(ctx, v1590);
                            let v1592 = Some(v1591);
                            // Rule at src\isa\pulley_shared\lower.isle line 1820.
                            return v1592;
                        }
                        I32 => {
                            let v1584 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1585 = constructor_put_in_xreg(ctx, v641);
                            let v1593 = constructor_pulley_vinsertx32(ctx, v1584, v1585, 0x0_u8);
                            let v1594 = constructor_output_vreg(ctx, v1593);
                            let v1595 = Some(v1594);
                            // Rule at src\isa\pulley_shared\lower.isle line 1822.
                            return v1595;
                        }
                        I64 => {
                            let v1584 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1585 = constructor_put_in_xreg(ctx, v641);
                            let v1596 = constructor_pulley_vinsertx64(ctx, v1584, v1585, 0x0_u8);
                            let v1597 = constructor_output_vreg(ctx, v1596);
                            let v1598 = Some(v1597);
                            // Rule at src\isa\pulley_shared\lower.isle line 1824.
                            return v1598;
                        }
                        F32 => {
                            let v1584 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1599 = constructor_put_in_freg(ctx, v641);
                            let v1600 = constructor_pulley_vinsertf32(ctx, v1584, v1599, 0x0_u8);
                            let v1601 = constructor_output_vreg(ctx, v1600);
                            let v1602 = Some(v1601);
                            // Rule at src\isa\pulley_shared\lower.isle line 1826.
                            return v1602;
                        }
                        F64 => {
                            let v1584 = constructor_pulley_vconst128(ctx, 0x0_u128);
                            let v1599 = constructor_put_in_freg(ctx, v641);
                            let v1603 = constructor_pulley_vinsertf64(ctx, v1584, v1599, 0x0_u8);
                            let v1604 = constructor_output_vreg(ctx, v1603);
                            let v1605 = Some(v1604);
                            // Rule at src\isa\pulley_shared\lower.isle line 1828.
                            return v1605;
                        }
                        _ => {}
                    }
                }
                &Opcode::Bmask => {
                    let v725 = C::value_type(ctx, v641);
                    if v725 == I64 {
                        let v642 = constructor_put_in_xreg(ctx, v641);
                        let v736 = constructor_pulley_xbmask64(ctx, v642);
                        let v737 = constructor_output_xreg(ctx, v736);
                        let v738 = Some(v737);
                        // Rule at src\isa\pulley_shared\lower.isle line 708.
                        return v738;
                    }
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == I64 {
                            let v732 = constructor_zext64(ctx, v641);
                            let v733 = constructor_pulley_xbmask64(ctx, v732);
                            let v734 = constructor_output_xreg(ctx, v733);
                            let v735 = Some(v734);
                            // Rule at src\isa\pulley_shared\lower.isle line 706.
                            return v735;
                        }
                        let v128 = C::ty_int(ctx, v109);
                        if let Some(v129) = v128 {
                            let v145 = C::fits_in_32(ctx, v129);
                            if let Some(v146) = v145 {
                                let v726 = C::fits_in_32(ctx, v725);
                                if let Some(v727) = v726 {
                                    let v728 = constructor_zext32(ctx, v641);
                                    let v729 = constructor_pulley_xbmask32(ctx, v728);
                                    let v730 = constructor_output_xreg(ctx, v729);
                                    let v731 = Some(v730);
                                    // Rule at src\isa\pulley_shared\lower.isle line 704.
                                    return v731;
                                }
                            }
                        }
                    }
                }
                &Opcode::Ireduce => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        let v1001 = C::fits_in_64(ctx, v109);
                        if let Some(v1002) = v1001 {
                            let v1003 = constructor_output_value(ctx, v641);
                            let v1004 = Some(v1003);
                            // Rule at src\isa\pulley_shared\lower.isle line 1331.
                            return v1004;
                        }
                    }
                }
                &Opcode::SwidenLow => {
                    let v725 = C::value_type(ctx, v641);
                    match v725 {
                        I8X16 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1469 = constructor_pulley_vwidenlow8x16_s(ctx, v649);
                            let v1470 = constructor_output_vreg(ctx, v1469);
                            let v1471 = Some(v1470);
                            // Rule at src\isa\pulley_shared\lower.isle line 1737.
                            return v1471;
                        }
                        I16X8 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1472 = constructor_pulley_vwidenlow16x8_s(ctx, v649);
                            let v1473 = constructor_output_vreg(ctx, v1472);
                            let v1474 = Some(v1473);
                            // Rule at src\isa\pulley_shared\lower.isle line 1738.
                            return v1474;
                        }
                        I32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1475 = constructor_pulley_vwidenlow32x4_s(ctx, v649);
                            let v1476 = constructor_output_vreg(ctx, v1475);
                            let v1477 = Some(v1476);
                            // Rule at src\isa\pulley_shared\lower.isle line 1739.
                            return v1477;
                        }
                        _ => {}
                    }
                }
                &Opcode::SwidenHigh => {
                    let v725 = C::value_type(ctx, v641);
                    match v725 {
                        I8X16 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1478 = constructor_pulley_vwidenhigh8x16_s(ctx, v649);
                            let v1479 = constructor_output_vreg(ctx, v1478);
                            let v1480 = Some(v1479);
                            // Rule at src\isa\pulley_shared\lower.isle line 1743.
                            return v1480;
                        }
                        I16X8 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1481 = constructor_pulley_vwidenhigh16x8_s(ctx, v649);
                            let v1482 = constructor_output_vreg(ctx, v1481);
                            let v1483 = Some(v1482);
                            // Rule at src\isa\pulley_shared\lower.isle line 1744.
                            return v1483;
                        }
                        I32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1484 = constructor_pulley_vwidenhigh32x4_s(ctx, v649);
                            let v1485 = constructor_output_vreg(ctx, v1484);
                            let v1486 = Some(v1485);
                            // Rule at src\isa\pulley_shared\lower.isle line 1745.
                            return v1486;
                        }
                        _ => {}
                    }
                }
                &Opcode::UwidenLow => {
                    let v725 = C::value_type(ctx, v641);
                    match v725 {
                        I8X16 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1487 = constructor_pulley_vwidenlow8x16_u(ctx, v649);
                            let v1488 = constructor_output_vreg(ctx, v1487);
                            let v1489 = Some(v1488);
                            // Rule at src\isa\pulley_shared\lower.isle line 1749.
                            return v1489;
                        }
                        I16X8 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1490 = constructor_pulley_vwidenlow16x8_u(ctx, v649);
                            let v1491 = constructor_output_vreg(ctx, v1490);
                            let v1492 = Some(v1491);
                            // Rule at src\isa\pulley_shared\lower.isle line 1750.
                            return v1492;
                        }
                        I32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1493 = constructor_pulley_vwidenlow32x4_u(ctx, v649);
                            let v1494 = constructor_output_vreg(ctx, v1493);
                            let v1495 = Some(v1494);
                            // Rule at src\isa\pulley_shared\lower.isle line 1751.
                            return v1495;
                        }
                        _ => {}
                    }
                }
                &Opcode::UwidenHigh => {
                    let v725 = C::value_type(ctx, v641);
                    match v725 {
                        I8X16 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1496 = constructor_pulley_vwidenhigh8x16_u(ctx, v649);
                            let v1497 = constructor_output_vreg(ctx, v1496);
                            let v1498 = Some(v1497);
                            // Rule at src\isa\pulley_shared\lower.isle line 1755.
                            return v1498;
                        }
                        I16X8 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1499 = constructor_pulley_vwidenhigh16x8_u(ctx, v649);
                            let v1500 = constructor_output_vreg(ctx, v1499);
                            let v1501 = Some(v1500);
                            // Rule at src\isa\pulley_shared\lower.isle line 1756.
                            return v1501;
                        }
                        I32X4 => {
                            let v649 = constructor_put_in_vreg(ctx, v641);
                            let v1502 = constructor_pulley_vwidenhigh32x4_u(ctx, v649);
                            let v1503 = constructor_output_vreg(ctx, v1502);
                            let v1504 = Some(v1503);
                            // Rule at src\isa\pulley_shared\lower.isle line 1757.
                            return v1504;
                        }
                        _ => {}
                    }
                }
                &Opcode::Uextend => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v732 = constructor_zext64(ctx, v641);
                                let v976 = constructor_output_xreg(ctx, v732);
                                let v977 = Some(v976);
                                // Rule at src\isa\pulley_shared\lower.isle line 1309.
                                return v977;
                            }
                            I128 => {
                                let v732 = constructor_zext64(ctx, v641);
                                let v979 = constructor_pulley_xzero(ctx);
                                let v978 = C::xreg_to_reg(ctx, v732);
                                let v980 = C::xreg_to_reg(ctx, v979);
                                let v981 = C::value_regs(ctx, v978, v980);
                                let v982 = C::output(ctx, v981);
                                let v983 = Some(v982);
                                // Rule at src\isa\pulley_shared\lower.isle line 1312.
                                return v983;
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v728 = constructor_zext32(ctx, v641);
                            let v974 = constructor_output_xreg(ctx, v728);
                            let v975 = Some(v974);
                            // Rule at src\isa\pulley_shared\lower.isle line 1306.
                            return v975;
                        }
                    }
                }
                &Opcode::Sextend => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I64 => {
                                let v987 = constructor_sext64(ctx, v641);
                                let v988 = constructor_output_xreg(ctx, v987);
                                let v989 = Some(v988);
                                // Rule at src\isa\pulley_shared\lower.isle line 1320.
                                return v989;
                            }
                            I128 => {
                                let v991 = C::u64_try_into_u8(ctx, 0x3f_u64);
                                if let Some(v992) = v991 {
                                    let v993 = C::u6_from_u8(ctx, v992);
                                    if let Some(v994) = v993 {
                                        let v987 = constructor_sext64(ctx, v641);
                                        let v995 = constructor_pulley_xshr64_s_u6(ctx, v987, v994);
                                        let v996 = C::xreg_to_reg(ctx, v987);
                                        let v997 = C::xreg_to_reg(ctx, v995);
                                        let v998 = C::value_regs(ctx, v996, v997);
                                        let v999 = C::output(ctx, v998);
                                        let v1000 = Some(v999);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1323.
                                        return v1000;
                                    }
                                }
                            }
                            _ => {}
                        }
                        let v447 = C::fits_in_32(ctx, v109);
                        if let Some(v448) = v447 {
                            let v984 = constructor_sext32(ctx, v641);
                            let v985 = constructor_output_xreg(ctx, v984);
                            let v986 = Some(v985);
                            // Rule at src\isa\pulley_shared\lower.isle line 1317.
                            return v986;
                        }
                    }
                }
                &Opcode::Fpromote => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == F64 {
                            let v725 = C::value_type(ctx, v641);
                            if v725 == F32 {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1196 = constructor_pulley_f64_from_f32(ctx, v1096);
                                let v1197 = constructor_output_freg(ctx, v1196);
                                let v1198 = Some(v1197);
                                // Rule at src\isa\pulley_shared\lower.isle line 1554.
                                return v1198;
                            }
                        }
                    }
                }
                &Opcode::Fdemote => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        if v109 == F32 {
                            let v725 = C::value_type(ctx, v641);
                            if v725 == F64 {
                                let v1096 = constructor_put_in_freg(ctx, v641);
                                let v1193 = constructor_pulley_f32_from_f64(ctx, v1096);
                                let v1194 = constructor_output_freg(ctx, v1193);
                                let v1195 = Some(v1194);
                                // Rule at src\isa\pulley_shared\lower.isle line 1549.
                                return v1195;
                            }
                        }
                    }
                }
                &Opcode::Fvdemote => {
                    let v725 = C::value_type(ctx, v641);
                    if v725 == F64X2 {
                        let v649 = constructor_put_in_vreg(ctx, v641);
                        let v1527 = constructor_pulley_vfdemote(ctx, v649);
                        let v1528 = constructor_output_vreg(ctx, v1527);
                        let v1529 = Some(v1528);
                        // Rule at src\isa\pulley_shared\lower.isle line 1780.
                        return v1529;
                    }
                }
                &Opcode::FvpromoteLow => {
                    let v725 = C::value_type(ctx, v641);
                    if v725 == F32X4 {
                        let v649 = constructor_put_in_vreg(ctx, v641);
                        let v1524 = constructor_pulley_vfpromotelow(ctx, v649);
                        let v1525 = constructor_output_vreg(ctx, v1524);
                        let v1526 = Some(v1525);
                        // Rule at src\isa\pulley_shared\lower.isle line 1776.
                        return v1526;
                    }
                }
                &Opcode::FcvtToUint => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1097 = constructor_pulley_x32_from_f32_u(ctx, v1096);
                                        let v1098 = constructor_output_xreg(ctx, v1097);
                                        let v1099 = Some(v1098);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1447.
                                        return v1099;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1100 = constructor_pulley_x32_from_f64_u(ctx, v1096);
                                        let v1101 = constructor_output_xreg(ctx, v1100);
                                        let v1102 = Some(v1101);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1450.
                                        return v1102;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1103 = constructor_pulley_x64_from_f32_u(ctx, v1096);
                                        let v1104 = constructor_output_xreg(ctx, v1103);
                                        let v1105 = Some(v1104);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1453.
                                        return v1105;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1106 = constructor_pulley_x64_from_f64_u(ctx, v1096);
                                        let v1107 = constructor_output_xreg(ctx, v1106);
                                        let v1108 = Some(v1107);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1456.
                                        return v1108;
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtToSint => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1109 = constructor_pulley_x32_from_f32_s(ctx, v1096);
                                        let v1110 = constructor_output_xreg(ctx, v1109);
                                        let v1111 = Some(v1110);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1459.
                                        return v1111;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1112 = constructor_pulley_x32_from_f64_s(ctx, v1096);
                                        let v1113 = constructor_output_xreg(ctx, v1112);
                                        let v1114 = Some(v1113);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1462.
                                        return v1114;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1115 = constructor_pulley_x64_from_f32_s(ctx, v1096);
                                        let v1116 = constructor_output_xreg(ctx, v1115);
                                        let v1117 = Some(v1116);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1465.
                                        return v1117;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1118 = constructor_pulley_x64_from_f64_s(ctx, v1096);
                                        let v1119 = constructor_output_xreg(ctx, v1118);
                                        let v1120 = Some(v1119);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1468.
                                        return v1120;
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtToUintSat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1157 = constructor_pulley_x32_from_f32_u_sat(ctx, v1096);
                                        let v1158 = constructor_output_xreg(ctx, v1157);
                                        let v1159 = Some(v1158);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1511.
                                        return v1159;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1160 = constructor_pulley_x32_from_f64_u_sat(ctx, v1096);
                                        let v1161 = constructor_output_xreg(ctx, v1160);
                                        let v1162 = Some(v1161);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1514.
                                        return v1162;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1163 = constructor_pulley_x64_from_f32_u_sat(ctx, v1096);
                                        let v1164 = constructor_output_xreg(ctx, v1163);
                                        let v1165 = Some(v1164);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1517.
                                        return v1165;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1166 = constructor_pulley_x64_from_f64_u_sat(ctx, v1096);
                                        let v1167 = constructor_output_xreg(ctx, v1166);
                                        let v1168 = Some(v1167);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1520.
                                        return v1168;
                                    }
                                    _ => {}
                                }
                            }
                            I32X4 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == F32X4 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1184 = constructor_pulley_vi32x4_from_f32x4_u(ctx, v649);
                                    let v1185 = constructor_output_vreg(ctx, v1184);
                                    let v1186 = Some(v1185);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1538.
                                    return v1186;
                                }
                            }
                            I64X2 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == F64X2 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1190 = constructor_pulley_vi64x2_from_f64x2_u(ctx, v649);
                                    let v1191 = constructor_output_vreg(ctx, v1190);
                                    let v1192 = Some(v1191);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1544.
                                    return v1192;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtToSintSat => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            I32 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1169 = constructor_pulley_x32_from_f32_s_sat(ctx, v1096);
                                        let v1170 = constructor_output_xreg(ctx, v1169);
                                        let v1171 = Some(v1170);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1523.
                                        return v1171;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1172 = constructor_pulley_x32_from_f64_s_sat(ctx, v1096);
                                        let v1173 = constructor_output_xreg(ctx, v1172);
                                        let v1174 = Some(v1173);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1526.
                                        return v1174;
                                    }
                                    _ => {}
                                }
                            }
                            I64 => {
                                let v725 = C::value_type(ctx, v641);
                                match v725 {
                                    F32 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1175 = constructor_pulley_x64_from_f32_s_sat(ctx, v1096);
                                        let v1176 = constructor_output_xreg(ctx, v1175);
                                        let v1177 = Some(v1176);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1529.
                                        return v1177;
                                    }
                                    F64 => {
                                        let v1096 = constructor_put_in_freg(ctx, v641);
                                        let v1178 = constructor_pulley_x64_from_f64_s_sat(ctx, v1096);
                                        let v1179 = constructor_output_xreg(ctx, v1178);
                                        let v1180 = Some(v1179);
                                        // Rule at src\isa\pulley_shared\lower.isle line 1532.
                                        return v1180;
                                    }
                                    _ => {}
                                }
                            }
                            I32X4 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == F32X4 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1181 = constructor_pulley_vi32x4_from_f32x4_s(ctx, v649);
                                    let v1182 = constructor_output_vreg(ctx, v1181);
                                    let v1183 = Some(v1182);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1535.
                                    return v1183;
                                }
                            }
                            I64X2 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == F64X2 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1187 = constructor_pulley_vi64x2_from_f64x2_s(ctx, v649);
                                    let v1188 = constructor_output_vreg(ctx, v1187);
                                    let v1189 = Some(v1188);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1541.
                                    return v1189;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtFromUint => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I64 {
                                    let v642 = constructor_put_in_xreg(ctx, v641);
                                    let v1124 = constructor_pulley_f32_from_x64_u(ctx, v642);
                                    let v1125 = constructor_output_freg(ctx, v1124);
                                    let v1126 = Some(v1125);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1476.
                                    return v1126;
                                }
                                let v726 = C::fits_in_32(ctx, v725);
                                if let Some(v727) = v726 {
                                    let v728 = constructor_zext32(ctx, v641);
                                    let v1121 = constructor_pulley_f32_from_x32_u(ctx, v728);
                                    let v1122 = constructor_output_freg(ctx, v1121);
                                    let v1123 = Some(v1122);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1473.
                                    return v1123;
                                }
                            }
                            F64 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I64 {
                                    let v642 = constructor_put_in_xreg(ctx, v641);
                                    let v1130 = constructor_pulley_f64_from_x64_u(ctx, v642);
                                    let v1131 = constructor_output_freg(ctx, v1130);
                                    let v1132 = Some(v1131);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1482.
                                    return v1132;
                                }
                                let v726 = C::fits_in_32(ctx, v725);
                                if let Some(v727) = v726 {
                                    let v728 = constructor_zext32(ctx, v641);
                                    let v1127 = constructor_pulley_f64_from_x32_u(ctx, v728);
                                    let v1128 = constructor_output_freg(ctx, v1127);
                                    let v1129 = Some(v1128);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1479.
                                    return v1129;
                                }
                            }
                            F32X4 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I32X4 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1148 = constructor_pulley_vf32x4_from_i32x4_u(ctx, v649);
                                    let v1149 = constructor_output_vreg(ctx, v1148);
                                    let v1150 = Some(v1149);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1500.
                                    return v1150;
                                }
                            }
                            F64X2 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I64X2 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1154 = constructor_pulley_vf64x2_from_i64x2_u(ctx, v649);
                                    let v1155 = constructor_output_vreg(ctx, v1154);
                                    let v1156 = Some(v1155);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1506.
                                    return v1156;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::FcvtFromSint => {
                    let v107 = C::first_result(ctx, arg0);
                    if let Some(v108) = v107 {
                        let v109 = C::value_type(ctx, v108);
                        match v109 {
                            F32 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I64 {
                                    let v642 = constructor_put_in_xreg(ctx, v641);
                                    let v1136 = constructor_pulley_f32_from_x64_s(ctx, v642);
                                    let v1137 = constructor_output_freg(ctx, v1136);
                                    let v1138 = Some(v1137);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1488.
                                    return v1138;
                                }
                                let v726 = C::fits_in_32(ctx, v725);
                                if let Some(v727) = v726 {
                                    let v984 = constructor_sext32(ctx, v641);
                                    let v1133 = constructor_pulley_f32_from_x32_s(ctx, v984);
                                    let v1134 = constructor_output_freg(ctx, v1133);
                                    let v1135 = Some(v1134);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1485.
                                    return v1135;
                                }
                            }
                            F64 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I64 {
                                    let v642 = constructor_put_in_xreg(ctx, v641);
                                    let v1142 = constructor_pulley_f64_from_x64_s(ctx, v642);
                                    let v1143 = constructor_output_freg(ctx, v1142);
                                    let v1144 = Some(v1143);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1494.
                                    return v1144;
                                }
                                let v726 = C::fits_in_32(ctx, v725);
                                if let Some(v727) = v726 {
                                    let v984 = constructor_sext32(ctx, v641);
                                    let v1139 = constructor_pulley_f64_from_x32_s(ctx, v984);
                                    let v1140 = constructor_output_freg(ctx, v1139);
                                    let v1141 = Some(v1140);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1491.
                                    return v1141;
                                }
                            }
                            F32X4 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I32X4 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1145 = constructor_pulley_vf32x4_from_i32x4_s(ctx, v649);
                                    let v1146 = constructor_output_vreg(ctx, v1145);
                                    let v1147 = Some(v1146);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1497.
                                    return v1147;
                                }
                            }
                            F64X2 => {
                                let v725 = C::value_type(ctx, v641);
                                if v725 == I64X2 {
                                    let v649 = constructor_put_in_vreg(ctx, v641);
                                    let v1151 = constructor_pulley_vf64x2_from_i64x2_s(ctx, v649);
                                    let v1152 = constructor_output_vreg(ctx, v1151);
                                    let v1153 = Some(v1152);
                                    // Rule at src\isa\pulley_shared\lower.isle line 1503.
                                    return v1153;
                                }
                            }
                            _ => {}
                        }
                    }
                }
                &Opcode::Isplit => {
                    let v725 = C::value_type(ctx, v641);
                    if v725 == I128 {
                        let v1010 = C::put_in_regs(ctx, v641);
                        let v1011 = C::value_regs_get(ctx, v1010, 0x0_usize);
                        let v1012 = C::xreg_new(ctx, v1011);
                        let v1013 = C::put_in_regs(ctx, v641);
                        let v1014 = C::value_regs_get(ctx, v1013, 0x1_usize);
                        let v1015 = C::xreg_new(ctx, v1014);
                        let v1016 = C::xreg_to_reg(ctx, v1012);
                        let v1017 = C::value_reg(ctx, v1016);
                        let v1018 = C::xreg_to_reg(ctx, v1015);
                        let v1019 = C::value_reg(ctx, v1018);
                        let v1020 = C::output_pair(ctx, v1017, v1019);
                        let v1021 = Some(v1020);
                        // Rule at src\isa\pulley_shared\lower.isle line 1341.
                        return v1021;
                    }
                }
                _ => {}
            }
        }
        &InstructionData::UnaryConst {
            opcode: ref v1381,
            constant_handle: v1382,
        } => {
            if let &Opcode::Vconst = v1381 {
                let v107 = C::first_result(ctx, arg0);
                if let Some(v108) = v107 {
                    let v109 = C::value_type(ctx, v108);
                    let v593 = C::ty_vec128(ctx, v109);
                    if let Some(v594) = v593 {
                        let v1383 = C::u128_from_constant(ctx, v1382);
                        if let Some(v1384) = v1383 {
                            let v1385 = constructor_pulley_vconst128(ctx, v1384);
                            let v1386 = constructor_output_vreg(ctx, v1385);
                            let v1387 = Some(v1386);
                            // Rule at src\isa\pulley_shared\lower.isle line 1678.
                            return v1387;
                        }
                    }
                }
            }
        }
        &InstructionData::UnaryGlobalValue {
            opcode: ref v1628,
            global_value: v1629,
        } => {
            if let &Opcode::SymbolValue = v1628 {
                let v1630 = C::symbol_value_data(ctx, v1629);
                if let Some(v1631) = v1630 {
                    let v1635 = C::box_external_name(ctx, v1631.0);
                    let v1636 = constructor_load_ext_name(ctx, v1635, v1631.2, &v1631.1);
                    let v1637 = constructor_output_xreg(ctx, v1636);
                    let v1638 = Some(v1637);
                    // Rule at src\isa\pulley_shared\lower.isle line 1847.
                    return v1638;
                }
            }
        }
        &InstructionData::UnaryIeee32 {
            opcode: ref v116,
            imm: v117,
        } => {
            if let &Opcode::F32const = v116 {
                let v118 = C::u32_from_ieee32(ctx, v117);
                let v119 = constructor_pulley_fconst32(ctx, v118);
                let v120 = constructor_output_freg(ctx, v119);
                let v121 = Some(v120);
                // Rule at src\isa\pulley_shared\lower.isle line 246.
                return v121;
            }
        }
        &InstructionData::UnaryIeee64 {
            opcode: ref v122,
            imm: v123,
        } => {
            if let &Opcode::F64const = v122 {
                let v124 = C::u64_from_ieee64(ctx, v123);
                let v125 = constructor_pulley_fconst64(ctx, v124);
                let v126 = constructor_output_freg(ctx, v125);
                let v127 = Some(v126);
                // Rule at src\isa\pulley_shared\lower.isle line 250.
                return v127;
            }
        }
        &InstructionData::UnaryImm {
            opcode: ref v110,
            imm: v111,
        } => {
            if let &Opcode::Iconst = v110 {
                let v107 = C::first_result(ctx, arg0);
                if let Some(v108) = v107 {
                    let v109 = C::value_type(ctx, v108);
                    let v112 = C::i64_sextend_imm64(ctx, v109, v111);
                    let v113 = constructor_imm(ctx, v112);
                    let v114 = constructor_output_reg(ctx, v113);
                    let v115 = Some(v114);
                    // Rule at src\isa\pulley_shared\lower.isle line 242.
                    return v115;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term lower_cond.
pub fn constructor_lower_cond<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Cond {
    let v9 = C::def_inst(ctx, arg0);
    if let Some(v10) = v9 {
        let v11 = &C::inst_data_value(ctx, v10);
        match v11 {
            &InstructionData::IntCompare {
                opcode: ref v15,
                args: ref v16,
                cond: ref v17,
            } => {
                if let &Opcode::Icmp = v15 {
                    let v18 = C::unpack_value_array_2(ctx, v16);
                    let v21 = C::value_type(ctx, v18.1);
                    match v21 {
                        I32 => {
                            let v22 = &constructor_lower_cond_icmp32(ctx, v17, v18.0, v18.1);
                            // Rule at src\isa\pulley_shared\lower.isle line 21.
                            return v22.clone();
                        }
                        I64 => {
                            let v23 = &constructor_lower_cond_icmp64(ctx, v17, v18.0, v18.1);
                            // Rule at src\isa\pulley_shared\lower.isle line 22.
                            return v23.clone();
                        }
                        _ => {}
                    }
                }
            }
            &InstructionData::Unary {
                opcode: ref v12,
                arg: v13,
            } => {
                if let &Opcode::Uextend = v12 {
                    let v14 = &constructor_lower_cond(ctx, v13);
                    // Rule at src\isa\pulley_shared\lower.isle line 19.
                    return v14.clone();
                }
            }
            _ => {}
        }
    }
    let v1 = C::value_type(ctx, arg0);
    if v1 == I64 {
        let v6 = constructor_put_in_xreg(ctx, arg0);
        let v8 = Cond::IfXneq64I32 {
            src1: v6,
            src2: 0_i32,
        };
        // Rule at src\isa\pulley_shared\lower.isle line 15.
        return v8;
    }
    let v2 = C::fits_in_32(ctx, v1);
    if let Some(v3) = v2 {
        let v4 = constructor_zext32(ctx, arg0);
        let v5 = Cond::If32 {
            reg: v4,
        };
        // Rule at src\isa\pulley_shared\lower.isle line 14.
        return v5;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_cond", "src\\isa\\pulley_shared\\lower.isle line 13")
}

// Generated as internal constructor for term lower_cond_icmp32.
pub fn constructor_lower_cond_icmp32<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Value,
    arg2: Value,
) -> Cond {
    match arg0 {
        &IntCC::Equal => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v21 = Cond::IfXeq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 37.
                    return v21;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v5 = Cond::IfXeq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 25.
            return v5;
        }
        &IntCC::NotEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v22 = Cond::IfXneq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 39.
                    return v22;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v6 = Cond::IfXneq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 26.
            return v6;
        }
        &IntCC::SignedGreaterThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v25 = Cond::IfXsgt32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 45.
                    return v25;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v13 = Cond::IfXslt32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 32.
            return v13;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v26 = Cond::IfXsgteq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 47.
                    return v26;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v14 = Cond::IfXslteq32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 33.
            return v14;
        }
        &IntCC::SignedLessThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v23 = Cond::IfXslt32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 41.
                    return v23;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v7 = Cond::IfXslt32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 27.
            return v7;
        }
        &IntCC::SignedLessThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v24 = Cond::IfXslteq32I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 43.
                    return v24;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v8 = Cond::IfXslteq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 28.
            return v8;
        }
        &IntCC::UnsignedGreaterThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v37 = Cond::IfXugt32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 53.
                            return v37;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v15 = Cond::IfXult32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 34.
            return v15;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v38 = Cond::IfXugteq32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 55.
                            return v38;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v16 = Cond::IfXulteq32 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 35.
            return v16;
        }
        &IntCC::UnsignedLessThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v35 = Cond::IfXult32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 49.
                            return v35;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v9 = Cond::IfXult32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 29.
            return v9;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v36 = Cond::IfXulteq32I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 51.
                            return v36;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v10 = Cond::IfXulteq32 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 30.
            return v10;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_cond_icmp32", "src\\isa\\pulley_shared\\lower.isle line 24")
}

// Generated as internal constructor for term lower_cond_icmp64.
pub fn constructor_lower_cond_icmp64<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Value,
    arg2: Value,
) -> Cond {
    match arg0 {
        &IntCC::Equal => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v21 = Cond::IfXeq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 71.
                    return v21;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v5 = Cond::IfXeq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 59.
            return v5;
        }
        &IntCC::NotEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v22 = Cond::IfXneq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 73.
                    return v22;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v6 = Cond::IfXneq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 60.
            return v6;
        }
        &IntCC::SignedGreaterThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v25 = Cond::IfXsgt64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 79.
                    return v25;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v13 = Cond::IfXslt64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 66.
            return v13;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v26 = Cond::IfXsgteq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 81.
                    return v26;
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v14 = Cond::IfXslteq64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 67.
            return v14;
        }
        &IntCC::SignedLessThan => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v23 = Cond::IfXslt64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 75.
                    return v23;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v7 = Cond::IfXslt64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 61.
            return v7;
        }
        &IntCC::SignedLessThanOrEqual => {
            let v17 = C::i64_from_iconst(ctx, arg2);
            if let Some(v18) = v17 {
                let v19 = C::i64_from_i32(ctx, v18);
                if let Some(v20) = v19 {
                    let v3 = constructor_put_in_xreg(ctx, arg1);
                    let v24 = Cond::IfXslteq64I32 {
                        src1: v3,
                        src2: v20,
                    };
                    // Rule at src\isa\pulley_shared\lower.isle line 77.
                    return v24;
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v8 = Cond::IfXslteq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 62.
            return v8;
        }
        &IntCC::UnsignedGreaterThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v37 = Cond::IfXugt64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 87.
                            return v37;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v15 = Cond::IfXult64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 68.
            return v15;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v38 = Cond::IfXugteq64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 89.
                            return v38;
                        }
                    }
                }
            }
            let v11 = constructor_put_in_xreg(ctx, arg2);
            let v12 = constructor_put_in_xreg(ctx, arg1);
            let v16 = Cond::IfXulteq64 {
                src1: v11,
                src2: v12,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 69.
            return v16;
        }
        &IntCC::UnsignedLessThan => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v35 = Cond::IfXult64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 83.
                            return v35;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v9 = Cond::IfXult64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 63.
            return v9;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v27 = C::def_inst(ctx, arg2);
            if let Some(v28) = v27 {
                let v29 = &C::inst_data_value(ctx, v28);
                if let &InstructionData::UnaryImm {
                    opcode: ref v30,
                    imm: v31,
                } = v29 {
                    if let &Opcode::Iconst = v30 {
                        let v32 = C::u64_from_imm64(ctx, v31);
                        let v33 = C::u64_from_u32(ctx, v32);
                        if let Some(v34) = v33 {
                            let v3 = constructor_put_in_xreg(ctx, arg1);
                            let v36 = Cond::IfXulteq64I32 {
                                src1: v3,
                                src2: v34,
                            };
                            // Rule at src\isa\pulley_shared\lower.isle line 85.
                            return v36;
                        }
                    }
                }
            }
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = constructor_put_in_xreg(ctx, arg2);
            let v10 = Cond::IfXulteq64 {
                src1: v3,
                src2: v4,
            };
            // Rule at src\isa\pulley_shared\lower.isle line 64.
            return v10;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_cond_icmp64", "src\\isa\\pulley_shared\\lower.isle line 58")
}

// Generated as internal constructor for term lower_branch.
pub fn constructor_lower_branch<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: &MachLabelSlice,
) -> Option<Unit> {
    let v1 = &C::inst_data_value(ctx, arg0);
    match v1 {
        &InstructionData::BranchTable {
            opcode: ref v24,
            arg: v25,
            table: v26,
        } => {
            if let &Opcode::BrTable = v24 {
                let v27 = C::jump_table_targets(ctx, arg1);
                if let Some(v28) = v27 {
                    let v31 = constructor_put_in_xreg(ctx, v25);
                    let v32 = constructor_gen_br_table(ctx, v31, v28.0, &v28.1);
                    let v33 = Some(v32);
                    // Rule at src\isa\pulley_shared\lower.isle line 105.
                    return v33;
                }
            }
        }
        &InstructionData::Brif {
            opcode: ref v10,
            arg: v11,
            blocks: ref v12,
        } => {
            if let &Opcode::Brif = v10 {
                let v16 = C::two_targets(ctx, arg1);
                if let Some(v17) = v16 {
                    let v20 = &constructor_lower_cond(ctx, v11);
                    let v21 = &constructor_pulley_br_if(ctx, v20, v17.0, v17.1);
                    let v22 = constructor_emit_side_effect(ctx, v21);
                    let v23 = Some(v22);
                    // Rule at src\isa\pulley_shared\lower.isle line 101.
                    return v23;
                }
            }
        }
        &InstructionData::Jump {
            opcode: ref v2,
            destination: v3,
        } => {
            if let &Opcode::Jump = v2 {
                let v5 = C::single_target(ctx, arg1);
                if let Some(v6) = v5 {
                    let v7 = &constructor_pulley_jump(ctx, v6);
                    let v8 = constructor_emit_side_effect(ctx, v7);
                    let v9 = Some(v8);
                    // Rule at src\isa\pulley_shared\lower.isle line 97.
                    return v9;
                }
            }
        }
        &InstructionData::TryCall {
            opcode: ref v34,
            args: v35,
            func_ref: v36,
            exception: v37,
        } => {
            if let &Opcode::TryCall = v34 {
                let v39 = C::func_ref_data(ctx, v36);
                if let &RelocDistance::Near = &v39.2 {
                    let v43 = C::abi_sig(ctx, v39.0);
                    let v44 = C::try_call_info(ctx, v37, arg1);
                    let v38 = C::value_list_slice(ctx, v35);
                    let v45 = &C::put_in_regs_vec(ctx, v38);
                    let v46 = C::gen_call_args(ctx, v43, v45);
                    let v47 = C::gen_try_call_rets(ctx, v43);
                    let v48 = C::gen_call_info(ctx, v43, v39.1, v46, v47, v44);
                    let v49 = &constructor_call_impl(ctx, v48);
                    let v50 = constructor_emit_side_effect(ctx, v49);
                    let v51 = Some(v50);
                    // Rule at src\isa\pulley_shared\lower.isle line 187.
                    return v51;
                }
                let v43 = C::abi_sig(ctx, v39.0);
                let v44 = C::try_call_info(ctx, v37, arg1);
                let v38 = C::value_list_slice(ctx, v35);
                let v45 = &C::put_in_regs_vec(ctx, v38);
                let v46 = C::gen_call_args(ctx, v43, v45);
                let v47 = C::gen_try_call_rets(ctx, v43);
                let v52 = C::gen_call_host_info(ctx, v43, v39.1, v46, v47, v44);
                let v53 = &constructor_indirect_call_host_impl(ctx, v52);
                let v54 = constructor_emit_side_effect(ctx, v53);
                let v55 = Some(v54);
                // Rule at src\isa\pulley_shared\lower.isle line 196.
                return v55;
            }
        }
        &InstructionData::TryCallIndirect {
            opcode: ref v56,
            args: v57,
            exception: v58,
        } => {
            if let &Opcode::TryCallIndirect = v56 {
                let v59 = C::value_list_slice(ctx, v57);
                let v60 = C::value_slice_unwrap(ctx, v59);
                if let Some(v61) = v60 {
                    let v64 = C::exception_sig(ctx, v58);
                    let v65 = C::abi_sig(ctx, v64);
                    let v66 = C::try_call_info(ctx, v58, arg1);
                    let v67 = C::put_in_reg(ctx, v61.0);
                    let v68 = &C::put_in_regs_vec(ctx, v61.1);
                    let v69 = C::gen_call_args(ctx, v65, v68);
                    let v70 = C::gen_try_call_rets(ctx, v65);
                    let v71 = C::gen_call_ind_info(ctx, v65, v67, v69, v70, v66);
                    let v72 = &constructor_indirect_call_impl(ctx, v71);
                    let v73 = constructor_emit_side_effect(ctx, v72);
                    let v74 = Some(v73);
                    // Rule at src\isa\pulley_shared\lower.isle line 205.
                    return v74;
                }
            }
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term u8_from_negated_iconst.
pub fn constructor_u8_from_negated_iconst<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<u8> {
    let v1 = C::i64_from_iconst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::i64_from_i32(ctx, v2);
        if let Some(v4) = v3 {
            let v5 = C::i32_into_i64(ctx, v4);
            let v6 = C::i64_checked_neg(ctx, v5);
            if let Some(v7) = v6 {
                let v8 = C::i64_try_into_u8(ctx, v7);
                if let Some(v9) = v8 {
                    let v10 = Some(v9);
                    // Rule at src\isa\pulley_shared\lower.isle line 285.
                    return v10;
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term u32_from_negated_iconst.
pub fn constructor_u32_from_negated_iconst<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<u32> {
    let v1 = C::i64_from_iconst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = C::i64_from_i32(ctx, v2);
        if let Some(v4) = v3 {
            let v5 = C::i32_into_i64(ctx, v4);
            let v6 = C::i64_checked_neg(ctx, v5);
            if let Some(v7) = v6 {
                let v8 = C::i64_try_into_u32(ctx, v7);
                if let Some(v9) = v8 {
                    let v10 = Some(v9);
                    // Rule at src\isa\pulley_shared\lower.isle line 293.
                    return v10;
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term u6_shift_from_iconst.
pub fn constructor_u6_shift_from_iconst<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> Option<U6> {
    let v1 = C::def_inst(ctx, arg0);
    if let Some(v2) = v1 {
        let v3 = &C::inst_data_value(ctx, v2);
        if let &InstructionData::UnaryImm {
            opcode: ref v4,
            imm: v5,
        } = v3 {
            if let &Opcode::Iconst = v4 {
                let v6 = C::u64_from_imm64(ctx, v5);
                let v8 = C::u64_and(ctx, v6, 0x3f_u64);
                let v9 = C::u64_try_into_u8(ctx, v8);
                if let Some(v10) = v9 {
                    let v11 = C::u6_from_u8(ctx, v10);
                    if let Some(v12) = v11 {
                        let v13 = Some(v12);
                        // Rule at src\isa\pulley_shared\lower.isle line 534.
                        return v13;
                    }
                }
            }
        }
    }
    None
}

// Generated as internal constructor for term lower_icmp.
pub fn constructor_lower_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> XReg {
    if arg0 == I128 {
        let v58 = &C::intcc_unsigned(ctx, arg1);
        if let &IntCC::UnsignedLessThan = v58 {
            let v32 = C::put_in_regs(ctx, arg2);
            let v34 = C::value_regs_get(ctx, v32, 0x0_usize);
            let v35 = C::xreg_new(ctx, v34);
            let v59 = C::put_in_regs(ctx, arg2);
            let v60 = C::value_regs_get(ctx, v59, 0x1_usize);
            let v61 = C::xreg_new(ctx, v60);
            let v62 = C::put_in_regs(ctx, arg3);
            let v63 = C::value_regs_get(ctx, v62, 0x0_usize);
            let v64 = C::xreg_new(ctx, v63);
            let v65 = C::put_in_regs(ctx, arg3);
            let v66 = C::value_regs_get(ctx, v65, 0x1_usize);
            let v67 = C::xreg_new(ctx, v66);
            let v68 = constructor_lower_icmp128_hi(ctx, arg1, v61, v67);
            let v69 = constructor_pulley_xult64(ctx, v35, v64);
            let v70 = constructor_pulley_xbxor64(ctx, v61, v67);
            let v50 = constructor_pulley_xconst8(ctx, 0_i8);
            let v71 = constructor_pulley_xeq64(ctx, v70, v50);
            let v72 = constructor_pulley_xselect32(ctx, v71, v69, v68);
            // Rule at src\isa\pulley_shared\lower.isle line 837.
            return v72;
        }
        match arg1 {
            &IntCC::SignedGreaterThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src\isa\pulley_shared\lower.isle line 826.
                return v57;
            }
            &IntCC::SignedLessThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src\isa\pulley_shared\lower.isle line 824.
                return v57;
            }
            &IntCC::UnsignedGreaterThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src\isa\pulley_shared\lower.isle line 830.
                return v57;
            }
            &IntCC::UnsignedLessThanOrEqual => {
                let v54 = &C::intcc_complement(ctx, arg1);
                let v55 = constructor_lower_icmp(ctx, I128, v54, arg2, arg3);
                let v57 = constructor_pulley_xbxor32_s8(ctx, v55, 1_i8);
                // Rule at src\isa\pulley_shared\lower.isle line 828.
                return v57;
            }
            _ => {}
        }
    }
    match arg1 {
        &IntCC::Equal => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v16 = constructor_pulley_xeq32(ctx, v14, v15);
                // Rule at src\isa\pulley_shared\lower.isle line 770.
                return v16;
            }
            match arg0 {
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v6 = constructor_pulley_xeq64(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 752.
                    return v6;
                }
                I128 => {
                    let v32 = C::put_in_regs(ctx, arg2);
                    let v34 = C::value_regs_get(ctx, v32, 0x0_usize);
                    let v35 = C::xreg_new(ctx, v34);
                    let v36 = C::put_in_regs(ctx, arg3);
                    let v37 = C::value_regs_get(ctx, v36, 0x0_usize);
                    let v38 = C::xreg_new(ctx, v37);
                    let v39 = constructor_pulley_xbxor64(ctx, v35, v38);
                    let v40 = C::put_in_regs(ctx, arg2);
                    let v42 = C::value_regs_get(ctx, v40, 0x1_usize);
                    let v43 = C::xreg_new(ctx, v42);
                    let v44 = C::put_in_regs(ctx, arg3);
                    let v45 = C::value_regs_get(ctx, v44, 0x1_usize);
                    let v46 = C::xreg_new(ctx, v45);
                    let v47 = constructor_pulley_xbxor64(ctx, v43, v46);
                    let v48 = constructor_pulley_xbor64(ctx, v39, v47);
                    let v50 = constructor_pulley_xconst8(ctx, 0_i8);
                    let v51 = constructor_pulley_xeq64(ctx, v48, v50);
                    // Rule at src\isa\pulley_shared\lower.isle line 808.
                    return v51;
                }
                _ => {}
            }
        }
        &IntCC::NotEqual => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v17 = constructor_pulley_xneq32(ctx, v14, v15);
                // Rule at src\isa\pulley_shared\lower.isle line 773.
                return v17;
            }
            match arg0 {
                I64 => {
                    let v4 = constructor_put_in_xreg(ctx, arg2);
                    let v5 = constructor_put_in_xreg(ctx, arg3);
                    let v7 = constructor_pulley_xneq64(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 755.
                    return v7;
                }
                I128 => {
                    let v32 = C::put_in_regs(ctx, arg2);
                    let v34 = C::value_regs_get(ctx, v32, 0x0_usize);
                    let v35 = C::xreg_new(ctx, v34);
                    let v36 = C::put_in_regs(ctx, arg3);
                    let v37 = C::value_regs_get(ctx, v36, 0x0_usize);
                    let v38 = C::xreg_new(ctx, v37);
                    let v39 = constructor_pulley_xbxor64(ctx, v35, v38);
                    let v40 = C::put_in_regs(ctx, arg2);
                    let v42 = C::value_regs_get(ctx, v40, 0x1_usize);
                    let v43 = C::xreg_new(ctx, v42);
                    let v44 = C::put_in_regs(ctx, arg3);
                    let v45 = C::value_regs_get(ctx, v44, 0x1_usize);
                    let v46 = C::xreg_new(ctx, v45);
                    let v47 = constructor_pulley_xbxor64(ctx, v43, v46);
                    let v48 = constructor_pulley_xbor64(ctx, v39, v47);
                    let v50 = constructor_pulley_xconst8(ctx, 0_i8);
                    let v52 = constructor_pulley_xneq64(ctx, v48, v50);
                    // Rule at src\isa\pulley_shared\lower.isle line 812.
                    return v52;
                }
                _ => {}
            }
        }
        &IntCC::SignedGreaterThan => {
            let v25 = constructor_lower_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 790.
            return v25;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v27 = constructor_lower_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 792.
            return v27;
        }
        &IntCC::SignedLessThan => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v18 = constructor_sext32(ctx, arg2);
                let v19 = constructor_sext32(ctx, arg3);
                let v20 = constructor_pulley_xslt32(ctx, v18, v19);
                // Rule at src\isa\pulley_shared\lower.isle line 776.
                return v20;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v8 = constructor_pulley_xslt64(ctx, v4, v5);
                // Rule at src\isa\pulley_shared\lower.isle line 758.
                return v8;
            }
        }
        &IntCC::SignedLessThanOrEqual => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v18 = constructor_sext32(ctx, arg2);
                let v19 = constructor_sext32(ctx, arg3);
                let v21 = constructor_pulley_xslteq32(ctx, v18, v19);
                // Rule at src\isa\pulley_shared\lower.isle line 779.
                return v21;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v9 = constructor_pulley_xslteq64(ctx, v4, v5);
                // Rule at src\isa\pulley_shared\lower.isle line 761.
                return v9;
            }
        }
        &IntCC::UnsignedGreaterThan => {
            let v29 = constructor_lower_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 794.
            return v29;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v31 = constructor_lower_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 796.
            return v31;
        }
        &IntCC::UnsignedLessThan => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v22 = constructor_pulley_xult32(ctx, v14, v15);
                // Rule at src\isa\pulley_shared\lower.isle line 782.
                return v22;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v10 = constructor_pulley_xult64(ctx, v4, v5);
                // Rule at src\isa\pulley_shared\lower.isle line 764.
                return v10;
            }
        }
        &IntCC::UnsignedLessThanOrEqual => {
            let v12 = C::fits_in_32(ctx, arg0);
            if let Some(v13) = v12 {
                let v14 = constructor_zext32(ctx, arg2);
                let v15 = constructor_zext32(ctx, arg3);
                let v23 = constructor_pulley_xulteq32(ctx, v14, v15);
                // Rule at src\isa\pulley_shared\lower.isle line 785.
                return v23;
            }
            if arg0 == I64 {
                let v4 = constructor_put_in_xreg(ctx, arg2);
                let v5 = constructor_put_in_xreg(ctx, arg3);
                let v11 = constructor_pulley_xulteq64(ctx, v4, v5);
                // Rule at src\isa\pulley_shared\lower.isle line 767.
                return v11;
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_icmp", "src\\isa\\pulley_shared\\lower.isle line 750")
}

// Generated as internal constructor for term lower_icmp128_hi.
pub fn constructor_lower_icmp128_hi<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    match arg0 {
        &IntCC::SignedLessThan => {
            let v3 = constructor_pulley_xslt64(ctx, arg1, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 851.
            return v3;
        }
        &IntCC::UnsignedLessThan => {
            let v4 = constructor_pulley_xult64(ctx, arg1, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 852.
            return v4;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_icmp128_hi", "src\\isa\\pulley_shared\\lower.isle line 850")
}

// Generated as internal constructor for term lower_vcmp.
pub fn constructor_lower_vcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> VReg {
    match arg1 {
        &IntCC::Equal => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v6 = constructor_pulley_veq8x16(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 860.
                    return v6;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v12 = constructor_pulley_veq16x8(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 866.
                    return v12;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v18 = constructor_pulley_veq32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 872.
                    return v18;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v24 = constructor_pulley_veq64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 878.
                    return v24;
                }
                _ => {}
            }
        }
        &IntCC::NotEqual => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v7 = constructor_pulley_vneq8x16(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 861.
                    return v7;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v13 = constructor_pulley_vneq16x8(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 867.
                    return v13;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v19 = constructor_pulley_vneq32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 873.
                    return v19;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v25 = constructor_pulley_vneq64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 879.
                    return v25;
                }
                _ => {}
            }
        }
        &IntCC::SignedGreaterThan => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 886.
            return v31;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 888.
            return v31;
        }
        &IntCC::SignedLessThan => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v8 = constructor_pulley_vslt8x16(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 862.
                    return v8;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v14 = constructor_pulley_vslt16x8(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 868.
                    return v14;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v20 = constructor_pulley_vslt32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 874.
                    return v20;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v26 = constructor_pulley_vslt64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 880.
                    return v26;
                }
                _ => {}
            }
        }
        &IntCC::SignedLessThanOrEqual => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v9 = constructor_pulley_vslteq8x16(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 863.
                    return v9;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v15 = constructor_pulley_vslteq16x8(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 869.
                    return v15;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v21 = constructor_pulley_vslteq32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 875.
                    return v21;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v27 = constructor_pulley_vslteq64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 881.
                    return v27;
                }
                _ => {}
            }
        }
        &IntCC::UnsignedGreaterThan => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 890.
            return v31;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            let v30 = &C::intcc_swap_args(ctx, arg1);
            let v31 = constructor_lower_vcmp(ctx, arg0, v30, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 892.
            return v31;
        }
        &IntCC::UnsignedLessThan => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v10 = constructor_pulley_vult8x16(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 864.
                    return v10;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v16 = constructor_pulley_vult16x8(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 870.
                    return v16;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v22 = constructor_pulley_vult32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 876.
                    return v22;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v28 = constructor_pulley_vult64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 882.
                    return v28;
                }
                _ => {}
            }
        }
        &IntCC::UnsignedLessThanOrEqual => {
            match arg0 {
                I8X16 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v11 = constructor_pulley_vulteq8x16(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 865.
                    return v11;
                }
                I16X8 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v17 = constructor_pulley_vulteq16x8(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 871.
                    return v17;
                }
                I32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v23 = constructor_pulley_vulteq32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 877.
                    return v23;
                }
                I64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v29 = constructor_pulley_vulteq64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 883.
                    return v29;
                }
                _ => {}
            }
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_vcmp", "src\\isa\\pulley_shared\\lower.isle line 859")
}

// Generated as internal constructor for term lower_fcmp.
pub fn constructor_lower_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> XReg {
    match arg1 {
        &FloatCC::Equal => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v6 = constructor_pulley_feq32(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 905.
                    return v6;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v7 = constructor_pulley_feq64(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 906.
                    return v7;
                }
                _ => {}
            }
        }
        &FloatCC::GreaterThan => {
            let v23 = constructor_lower_fcmp(ctx, arg0, &FloatCC::LessThan, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 924.
            return v23;
        }
        &FloatCC::GreaterThanOrEqual => {
            let v25 = constructor_lower_fcmp(ctx, arg0, &FloatCC::LessThanOrEqual, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 926.
            return v25;
        }
        &FloatCC::LessThan => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v10 = constructor_pulley_flt32(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 909.
                    return v10;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v11 = constructor_pulley_flt64(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 910.
                    return v11;
                }
                _ => {}
            }
        }
        &FloatCC::LessThanOrEqual => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v12 = constructor_pulley_flteq32(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 911.
                    return v12;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v13 = constructor_pulley_flteq64(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 912.
                    return v13;
                }
                _ => {}
            }
        }
        &FloatCC::NotEqual => {
            match arg0 {
                F32 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v8 = constructor_pulley_fneq32(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 907.
                    return v8;
                }
                F64 => {
                    let v4 = constructor_put_in_freg(ctx, arg2);
                    let v5 = constructor_put_in_freg(ctx, arg3);
                    let v9 = constructor_pulley_fneq64(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 908.
                    return v9;
                }
                _ => {}
            }
        }
        &FloatCC::Ordered => {
            let v15 = constructor_lower_fcmp(ctx, arg0, &FloatCC::Equal, arg2, arg2);
            let v16 = constructor_lower_fcmp(ctx, arg0, &FloatCC::Equal, arg3, arg3);
            let v17 = constructor_pulley_xband32(ctx, v15, v16);
            // Rule at src\isa\pulley_shared\lower.isle line 915.
            return v17;
        }
        &FloatCC::OrderedNotEqual => {
            let v19 = constructor_lower_fcmp(ctx, arg0, &FloatCC::LessThan, arg2, arg3);
            let v21 = constructor_lower_fcmp(ctx, arg0, &FloatCC::GreaterThan, arg2, arg3);
            let v22 = constructor_pulley_xbor32(ctx, v19, v21);
            // Rule at src\isa\pulley_shared\lower.isle line 919.
            return v22;
        }
        _ => {}
    }
    let v26 = C::floatcc_unordered(ctx, arg1);
    if v26 == true {
        let v27 = &C::floatcc_complement(ctx, arg1);
        let v28 = constructor_lower_fcmp(ctx, arg0, v27, arg2, arg3);
        let v30 = constructor_pulley_xbxor32_s8(ctx, v28, 1_i8);
        // Rule at src\isa\pulley_shared\lower.isle line 930.
        return v30;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_fcmp", "src\\isa\\pulley_shared\\lower.isle line 903")
}

// Generated as internal constructor for term lower_vfcmp.
pub fn constructor_lower_vfcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> VReg {
    match arg1 {
        &FloatCC::Equal => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v6 = constructor_pulley_veqf32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 936.
                    return v6;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v7 = constructor_pulley_veqf64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 937.
                    return v7;
                }
                _ => {}
            }
        }
        &FloatCC::GreaterThan => {
            let v19 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::LessThan, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 955.
            return v19;
        }
        &FloatCC::GreaterThanOrEqual => {
            let v21 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::LessThanOrEqual, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 957.
            return v21;
        }
        &FloatCC::LessThan => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v10 = constructor_pulley_vltf32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 940.
                    return v10;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v11 = constructor_pulley_vltf64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 941.
                    return v11;
                }
                _ => {}
            }
        }
        &FloatCC::LessThanOrEqual => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v12 = constructor_pulley_vlteqf32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 942.
                    return v12;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v13 = constructor_pulley_vlteqf64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 943.
                    return v13;
                }
                _ => {}
            }
        }
        &FloatCC::NotEqual => {
            match arg0 {
                F32X4 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v8 = constructor_pulley_vneqf32x4(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 938.
                    return v8;
                }
                F64X2 => {
                    let v4 = constructor_put_in_vreg(ctx, arg2);
                    let v5 = constructor_put_in_vreg(ctx, arg3);
                    let v9 = constructor_pulley_vneqf64x2(ctx, v4, v5);
                    // Rule at src\isa\pulley_shared\lower.isle line 939.
                    return v9;
                }
                _ => {}
            }
        }
        &FloatCC::Unordered => {
            let v15 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::NotEqual, arg2, arg2);
            let v16 = constructor_lower_vfcmp(ctx, arg0, &FloatCC::NotEqual, arg3, arg3);
            let v17 = constructor_pulley_vbor128(ctx, v15, v16);
            // Rule at src\isa\pulley_shared\lower.isle line 945.
            return v17;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "lower_vfcmp", "src\\isa\\pulley_shared\\lower.isle line 934")
}

// Generated as internal constructor for term gen_xload.
pub fn constructor_gen_xload<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
    arg4: &ExtKind,
) -> XReg {
    let v14 = &constructor_wasm_g32(ctx, arg0, arg1, arg2, arg3);
    if let Some(v15) = v14 {
        let v16 = constructor_gen_xload_g32(ctx, v15, arg3, arg4);
        // Rule at src\isa\pulley_shared\lower.isle line 1098.
        return v16;
    }
    let v11 = C::memflags_is_wasm(ctx, arg2);
    if v11 == true {
        let v12 = &constructor_addrz(ctx, arg0, arg1);
        let v13 = constructor_emit_addrz_xload(ctx, v12, arg3, arg4);
        // Rule at src\isa\pulley_shared\lower.isle line 1073.
        return v13;
    }
    let v5 = C::memflags_nontrapping(ctx, arg2);
    if v5 == true {
        let v6 = &C::endianness(ctx, arg2);
        match v6 {
            &Endianness::Little => {
                let v9 = &constructor_addro32(ctx, arg0, arg1);
                let v10 = constructor_emit_addro32_xload(ctx, v9, arg3, arg4);
                // Rule at src\isa\pulley_shared\lower.isle line 1048.
                return v10;
            }
            &Endianness::Big => {
                if let &ExtKind::None = arg4 {
                    let v7 = &constructor_amode(ctx, arg0, arg1);
                    let v8 = constructor_pulley_xload(ctx, v7, arg3, arg2);
                    // Rule at src\isa\pulley_shared\lower.isle line 1041.
                    return v8;
                }
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_xload", "src\\isa\\pulley_shared\\lower.isle line 1035")
}

// Generated as internal constructor for term emit_addro32_xload.
pub fn constructor_emit_addro32_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1054.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1055.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_o32(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src\isa\pulley_shared\lower.isle line 1057.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1056.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_o32(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src\isa\pulley_shared\lower.isle line 1058.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1059.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1060.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_o32(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src\isa\pulley_shared\lower.isle line 1062.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1061.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_o32(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src\isa\pulley_shared\lower.isle line 1063.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1064.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1065.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1067.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1066.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_o32(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1068.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_o32(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1069.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addro32_xload", "src\\isa\\pulley_shared\\lower.isle line 1053")
}

// Generated as internal constructor for term emit_addrz_xload.
pub fn constructor_emit_addrz_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1078.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1079.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_z(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src\isa\pulley_shared\lower.isle line 1081.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1080.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_z(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src\isa\pulley_shared\lower.isle line 1082.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1083.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1084.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_z(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src\isa\pulley_shared\lower.isle line 1086.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1085.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_z(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src\isa\pulley_shared\lower.isle line 1087.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1088.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1089.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1091.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1090.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_z(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1092.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_z(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1093.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_xload", "src\\isa\\pulley_shared\\lower.isle line 1077")
}

// Generated as internal constructor for term gen_xload_g32.
pub fn constructor_gen_xload_g32<C: Context>(
    ctx: &mut C,
    arg0: &G32,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    let v5 = &constructor_addrg32bne(ctx, arg0);
    if let Some(v6) = v5 {
        let v7 = &constructor_gen_addrg32bne(ctx, v6);
        let v8 = constructor_emit_addrg32bne_xload(ctx, v7, arg1, arg2);
        // Rule at src\isa\pulley_shared\lower.isle line 1125.
        return v8;
    }
    let v3 = &constructor_gen_addrg32(ctx, arg0);
    let v4 = constructor_emit_addrg32_xload(ctx, v3, arg1, arg2);
    // Rule at src\isa\pulley_shared\lower.isle line 1104.
    return v4;
}

// Generated as internal constructor for term emit_addrg32_xload.
pub fn constructor_emit_addrg32_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1107.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1108.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_g32(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src\isa\pulley_shared\lower.isle line 1110.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1109.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_g32(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src\isa\pulley_shared\lower.isle line 1111.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1112.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1113.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_g32(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src\isa\pulley_shared\lower.isle line 1115.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1114.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_g32(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src\isa\pulley_shared\lower.isle line 1116.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1117.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1118.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1120.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1119.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_g32(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1121.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_g32(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1122.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32_xload", "src\\isa\\pulley_shared\\lower.isle line 1106")
}

// Generated as internal constructor for term emit_addrg32bne_xload.
pub fn constructor_emit_addrg32bne_xload<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: Type,
    arg2: &ExtKind,
) -> XReg {
    match arg1 {
        I8 => {
            match arg2 {
                &ExtKind::None => {
                    let v3 = constructor_pulley_xload8_u32_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1130.
                    return v3;
                }
                &ExtKind::Sign32 => {
                    let v4 = constructor_pulley_xload8_s32_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1131.
                    return v4;
                }
                &ExtKind::Sign64 => {
                    let v4 = constructor_pulley_xload8_s32_g32bne(ctx, arg0);
                    let v5 = constructor_pulley_sext32(ctx, v4);
                    // Rule at src\isa\pulley_shared\lower.isle line 1133.
                    return v5;
                }
                &ExtKind::Zero32 => {
                    let v3 = constructor_pulley_xload8_u32_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1132.
                    return v3;
                }
                &ExtKind::Zero64 => {
                    let v3 = constructor_pulley_xload8_u32_g32bne(ctx, arg0);
                    let v6 = constructor_pulley_zext32(ctx, v3);
                    // Rule at src\isa\pulley_shared\lower.isle line 1134.
                    return v6;
                }
                _ => {}
            }
        }
        I16 => {
            match arg2 {
                &ExtKind::None => {
                    let v7 = constructor_pulley_xload16le_u32_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1135.
                    return v7;
                }
                &ExtKind::Sign32 => {
                    let v8 = constructor_pulley_xload16le_s32_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1136.
                    return v8;
                }
                &ExtKind::Sign64 => {
                    let v8 = constructor_pulley_xload16le_s32_g32bne(ctx, arg0);
                    let v9 = constructor_pulley_sext32(ctx, v8);
                    // Rule at src\isa\pulley_shared\lower.isle line 1138.
                    return v9;
                }
                &ExtKind::Zero32 => {
                    let v7 = constructor_pulley_xload16le_u32_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1137.
                    return v7;
                }
                &ExtKind::Zero64 => {
                    let v7 = constructor_pulley_xload16le_u32_g32bne(ctx, arg0);
                    let v10 = constructor_pulley_zext32(ctx, v7);
                    // Rule at src\isa\pulley_shared\lower.isle line 1139.
                    return v10;
                }
                _ => {}
            }
        }
        I32 => {
            match arg2 {
                &ExtKind::None => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1140.
                    return v11;
                }
                &ExtKind::Sign32 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1141.
                    return v11;
                }
                &ExtKind::Sign64 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    let v12 = constructor_pulley_sext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1143.
                    return v12;
                }
                &ExtKind::Zero32 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    // Rule at src\isa\pulley_shared\lower.isle line 1142.
                    return v11;
                }
                &ExtKind::Zero64 => {
                    let v11 = constructor_pulley_xload32le_g32bne(ctx, arg0);
                    let v13 = constructor_pulley_zext32(ctx, v11);
                    // Rule at src\isa\pulley_shared\lower.isle line 1144.
                    return v13;
                }
                _ => {}
            }
        }
        I64 => {
            let v14 = constructor_pulley_xload64le_g32bne(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1145.
            return v14;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32bne_xload", "src\\isa\\pulley_shared\\lower.isle line 1129")
}

// Generated as internal constructor for term gen_fload.
pub fn constructor_gen_fload<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
) -> FReg {
    let v10 = &constructor_wasm_g32(ctx, arg0, arg1, arg2, arg3);
    if let Some(v11) = v10 {
        let v12 = &constructor_gen_addrg32(ctx, v11);
        let v13 = constructor_emit_addrg32_fload(ctx, v12, arg3);
        // Rule at src\isa\pulley_shared\lower.isle line 1168.
        return v13;
    }
    let v7 = C::memflags_is_wasm(ctx, arg2);
    if v7 == true {
        let v8 = &constructor_addrz(ctx, arg0, arg1);
        let v9 = constructor_emit_addrz_fload(ctx, v8, arg3);
        // Rule at src\isa\pulley_shared\lower.isle line 1158.
        return v9;
    }
    let v4 = C::memflags_nontrapping(ctx, arg2);
    if v4 == true {
        let v5 = &constructor_amode(ctx, arg0, arg1);
        let v6 = constructor_pulley_fload(ctx, v5, arg3, arg2);
        // Rule at src\isa\pulley_shared\lower.isle line 1152.
        return v6;
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_fload", "src\\isa\\pulley_shared\\lower.isle line 1148")
}

// Generated as internal constructor for term emit_addrz_fload.
pub fn constructor_emit_addrz_fload<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Type,
) -> FReg {
    match arg1 {
        F32 => {
            let v2 = constructor_pulley_fload32le_z(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1163.
            return v2;
        }
        F64 => {
            let v3 = constructor_pulley_fload64le_z(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1164.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_fload", "src\\isa\\pulley_shared\\lower.isle line 1162")
}

// Generated as internal constructor for term emit_addrg32_fload.
pub fn constructor_emit_addrg32_fload<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: Type,
) -> FReg {
    match arg1 {
        F32 => {
            let v2 = constructor_pulley_fload32le_g32(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1173.
            return v2;
        }
        F64 => {
            let v3 = constructor_pulley_fload64le_g32(ctx, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1174.
            return v3;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32_fload", "src\\isa\\pulley_shared\\lower.isle line 1172")
}

// Generated as internal constructor for term gen_vload.
pub fn constructor_gen_vload<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: Type,
    arg4: &VExtKind,
) -> VReg {
    if let &VExtKind::None = arg4 {
        let v11 = C::ty_vec128(ctx, arg3);
        if let Some(v12) = v11 {
            let v13 = &constructor_wasm_g32(ctx, arg0, arg1, arg2, v12);
            if let Some(v14) = v13 {
                let v15 = &constructor_gen_addrg32(ctx, v14);
                let v16 = constructor_pulley_vload128le_g32(ctx, v15);
                // Rule at src\isa\pulley_shared\lower.isle line 1202.
                return v16;
            }
        }
    }
    let v8 = C::memflags_is_wasm(ctx, arg2);
    if v8 == true {
        let v9 = &constructor_addrz(ctx, arg0, arg1);
        let v10 = constructor_emit_addrz_vload(ctx, v9, arg3, arg4);
        // Rule at src\isa\pulley_shared\lower.isle line 1187.
        return v10;
    }
    if let &VExtKind::None = arg4 {
        let v5 = C::memflags_nontrapping(ctx, arg2);
        if v5 == true {
            let v6 = &constructor_amode(ctx, arg0, arg1);
            let v7 = constructor_pulley_vload(ctx, v6, arg3, arg2);
            // Rule at src\isa\pulley_shared\lower.isle line 1182.
            return v7;
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_vload", "src\\isa\\pulley_shared\\lower.isle line 1177")
}

// Generated as internal constructor for term emit_addrz_vload.
pub fn constructor_emit_addrz_vload<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Type,
    arg2: &VExtKind,
) -> VReg {
    let v2 = C::ty_vec128(ctx, arg1);
    if let Some(v3) = v2 {
        match arg2 {
            &VExtKind::None => {
                let v5 = constructor_pulley_vload128le_z(ctx, arg0);
                // Rule at src\isa\pulley_shared\lower.isle line 1192.
                return v5;
            }
            &VExtKind::S8x8 => {
                let v6 = constructor_pulley_vload8x8_s_z(ctx, arg0);
                // Rule at src\isa\pulley_shared\lower.isle line 1193.
                return v6;
            }
            &VExtKind::U8x8 => {
                let v7 = constructor_pulley_vload8x8_u_z(ctx, arg0);
                // Rule at src\isa\pulley_shared\lower.isle line 1194.
                return v7;
            }
            &VExtKind::S16x4 => {
                let v8 = constructor_pulley_vload16x4le_s_z(ctx, arg0);
                // Rule at src\isa\pulley_shared\lower.isle line 1195.
                return v8;
            }
            &VExtKind::U16x4 => {
                let v9 = constructor_pulley_vload16x4le_u_z(ctx, arg0);
                // Rule at src\isa\pulley_shared\lower.isle line 1196.
                return v9;
            }
            &VExtKind::S32x2 => {
                let v10 = constructor_pulley_vload32x2le_s_z(ctx, arg0);
                // Rule at src\isa\pulley_shared\lower.isle line 1197.
                return v10;
            }
            &VExtKind::U32x2 => {
                let v11 = constructor_pulley_vload32x2le_u_z(ctx, arg0);
                // Rule at src\isa\pulley_shared\lower.isle line 1198.
                return v11;
            }
            _ => {}
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_vload", "src\\isa\\pulley_shared\\lower.isle line 1191")
}

// Generated as internal constructor for term emit_store_i128.
pub fn constructor_emit_store_i128<C: Context>(
    ctx: &mut C,
    arg0: MemFlags,
    arg1: XReg,
    arg2: XReg,
    arg3: &Amode,
    arg4: &Amode,
) -> SideEffectNoResult {
    let v5 = &C::endianness(ctx, arg0);
    match v5 {
        &Endianness::Little => {
            let v7 = &constructor_pulley_xstore(ctx, arg3, arg1, I64, arg0);
            let v8 = constructor_side_effect(ctx, v7);
            let v9 = &constructor_pulley_xstore(ctx, arg4, arg2, I64, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1240.
            return v9.clone();
        }
        &Endianness::Big => {
            let v10 = &constructor_pulley_xstore(ctx, arg3, arg2, I64, arg0);
            let v11 = constructor_side_effect(ctx, v10);
            let v12 = &constructor_pulley_xstore(ctx, arg4, arg1, I64, arg0);
            // Rule at src\isa\pulley_shared\lower.isle line 1244.
            return v12.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_store_i128", "src\\isa\\pulley_shared\\lower.isle line 1239")
}

// Generated as internal constructor for term gen_store.
pub fn constructor_gen_store<C: Context>(
    ctx: &mut C,
    arg0: Value,
    arg1: Value,
    arg2: Offset32,
    arg3: MemFlags,
    arg4: Type,
) -> SideEffectNoResult {
    let v22 = &constructor_wasm_g32(ctx, arg1, arg2, arg3, arg4);
    if let Some(v23) = v22 {
        let v24 = &constructor_gen_addrg32(ctx, v23);
        let v25 = &constructor_emit_addrg32_store(ctx, v24, arg0, arg4);
        // Rule at src\isa\pulley_shared\lower.isle line 1280.
        return v25.clone();
    }
    let v19 = C::memflags_is_wasm(ctx, arg3);
    if v19 == true {
        let v20 = &constructor_addrz(ctx, arg1, arg2);
        let v21 = &constructor_emit_addrz_store(ctx, v20, arg0, arg4);
        // Rule at src\isa\pulley_shared\lower.isle line 1266.
        return v21.clone();
    }
    let v7 = C::memflags_nontrapping(ctx, arg3);
    if v7 == true {
        let v15 = C::ty_vec128(ctx, arg4);
        if let Some(v16) = v15 {
            let v8 = &constructor_amode(ctx, arg1, arg2);
            let v17 = constructor_put_in_vreg(ctx, arg0);
            let v18 = &constructor_pulley_vstore(ctx, v8, v17, v16, arg3);
            // Rule at src\isa\pulley_shared\lower.isle line 1261.
            return v18.clone();
        }
        let v11 = C::ty_scalar_float(ctx, arg4);
        if let Some(v12) = v11 {
            let v8 = &constructor_amode(ctx, arg1, arg2);
            let v13 = constructor_put_in_freg(ctx, arg0);
            let v14 = &constructor_pulley_fstore(ctx, v8, v13, v12, arg3);
            // Rule at src\isa\pulley_shared\lower.isle line 1258.
            return v14.clone();
        }
        let v5 = C::ty_int(ctx, arg4);
        if let Some(v6) = v5 {
            let v8 = &constructor_amode(ctx, arg1, arg2);
            let v9 = constructor_put_in_xreg(ctx, arg0);
            let v10 = &constructor_pulley_xstore(ctx, v8, v9, v6, arg3);
            // Rule at src\isa\pulley_shared\lower.isle line 1255.
            return v10.clone();
        }
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "gen_store", "src\\isa\\pulley_shared\\lower.isle line 1252")
}

// Generated as internal constructor for term emit_addrz_store.
pub fn constructor_emit_addrz_store<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: Value,
    arg2: Type,
) -> SideEffectNoResult {
    let v11 = C::ty_vec128(ctx, arg2);
    if let Some(v12) = v11 {
        let v13 = constructor_put_in_vreg(ctx, arg1);
        let v14 = &constructor_pulley_vstore128le_z(ctx, arg0, v13);
        // Rule at src\isa\pulley_shared\lower.isle line 1277.
        return v14.clone();
    }
    match arg2 {
        I8 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = &constructor_pulley_xstore8_z(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1271.
            return v4.clone();
        }
        I16 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v5 = &constructor_pulley_xstore16le_z(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1272.
            return v5.clone();
        }
        I32 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v6 = &constructor_pulley_xstore32le_z(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1273.
            return v6.clone();
        }
        I64 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v7 = &constructor_pulley_xstore64le_z(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1274.
            return v7.clone();
        }
        F32 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v9 = &constructor_pulley_fstore32le_z(ctx, arg0, v8);
            // Rule at src\isa\pulley_shared\lower.isle line 1275.
            return v9.clone();
        }
        F64 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v10 = &constructor_pulley_fstore64le_z(ctx, arg0, v8);
            // Rule at src\isa\pulley_shared\lower.isle line 1276.
            return v10.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrz_store", "src\\isa\\pulley_shared\\lower.isle line 1270")
}

// Generated as internal constructor for term emit_addrg32_store.
pub fn constructor_emit_addrg32_store<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: Value,
    arg2: Type,
) -> SideEffectNoResult {
    let v11 = C::ty_vec128(ctx, arg2);
    if let Some(v12) = v11 {
        let v13 = constructor_put_in_vreg(ctx, arg1);
        let v14 = &constructor_pulley_vstore128le_g32(ctx, arg0, v13);
        // Rule at src\isa\pulley_shared\lower.isle line 1291.
        return v14.clone();
    }
    match arg2 {
        I8 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v4 = &constructor_pulley_xstore8_g32(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1285.
            return v4.clone();
        }
        I16 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v5 = &constructor_pulley_xstore16le_g32(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1286.
            return v5.clone();
        }
        I32 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v6 = &constructor_pulley_xstore32le_g32(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1287.
            return v6.clone();
        }
        I64 => {
            let v3 = constructor_put_in_xreg(ctx, arg1);
            let v7 = &constructor_pulley_xstore64le_g32(ctx, arg0, v3);
            // Rule at src\isa\pulley_shared\lower.isle line 1288.
            return v7.clone();
        }
        F32 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v9 = &constructor_pulley_fstore32le_g32(ctx, arg0, v8);
            // Rule at src\isa\pulley_shared\lower.isle line 1289.
            return v9.clone();
        }
        F64 => {
            let v8 = constructor_put_in_freg(ctx, arg1);
            let v10 = &constructor_pulley_fstore64le_g32(ctx, arg0, v8);
            // Rule at src\isa\pulley_shared\lower.isle line 1290.
            return v10.clone();
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_addrg32_store", "src\\isa\\pulley_shared\\lower.isle line 1284")
}

// Generated as internal constructor for term lower_stack_addr.
pub fn constructor_lower_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: StackSlot,
    arg1: Offset32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = C::writable_xreg_to_writable_reg(ctx, v2);
    let v4 = &C::abi_stackslot_addr(ctx, v3, arg0, arg1);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at src\isa\pulley_shared\lower.isle line 1299.
    return v6;
}

// Generated as internal constructor for term emit_cond.
pub fn constructor_emit_cond<C: Context>(
    ctx: &mut C,
    arg0: &Cond,
) -> XReg {
    match arg0 {
        &Cond::If32 {
            reg: v1,
        } => {
            // Rule at src\isa\pulley_shared\lower.isle line 1385.
            return v1;
        }
        &Cond::IfNot32 {
            reg: v2,
        } => {
            let v4 = constructor_pulley_xconst8(ctx, 0_i8);
            let v5 = constructor_pulley_xeq32(ctx, v2, v4);
            // Rule at src\isa\pulley_shared\lower.isle line 1386.
            return v5;
        }
        &Cond::IfXeq32 {
            src1: v6,
            src2: v7,
        } => {
            let v8 = constructor_pulley_xeq32(ctx, v6, v7);
            // Rule at src\isa\pulley_shared\lower.isle line 1387.
            return v8;
        }
        &Cond::IfXneq32 {
            src1: v9,
            src2: v10,
        } => {
            let v11 = constructor_pulley_xneq32(ctx, v9, v10);
            // Rule at src\isa\pulley_shared\lower.isle line 1388.
            return v11;
        }
        &Cond::IfXslt32 {
            src1: v12,
            src2: v13,
        } => {
            let v14 = constructor_pulley_xslt32(ctx, v12, v13);
            // Rule at src\isa\pulley_shared\lower.isle line 1389.
            return v14;
        }
        &Cond::IfXslteq32 {
            src1: v15,
            src2: v16,
        } => {
            let v17 = constructor_pulley_xslteq32(ctx, v15, v16);
            // Rule at src\isa\pulley_shared\lower.isle line 1390.
            return v17;
        }
        &Cond::IfXult32 {
            src1: v18,
            src2: v19,
        } => {
            let v20 = constructor_pulley_xult32(ctx, v18, v19);
            // Rule at src\isa\pulley_shared\lower.isle line 1391.
            return v20;
        }
        &Cond::IfXulteq32 {
            src1: v21,
            src2: v22,
        } => {
            let v23 = constructor_pulley_xulteq32(ctx, v21, v22);
            // Rule at src\isa\pulley_shared\lower.isle line 1392.
            return v23;
        }
        &Cond::IfXeq32I32 {
            src1: v42,
            src2: v43,
        } => {
            let v44 = C::i32_into_i64(ctx, v43);
            let v45 = constructor_imm(ctx, v44);
            let v46 = C::xreg_new(ctx, v45);
            let v47 = constructor_pulley_xeq32(ctx, v42, v46);
            // Rule at src\isa\pulley_shared\lower.isle line 1400.
            return v47;
        }
        &Cond::IfXneq32I32 {
            src1: v48,
            src2: v49,
        } => {
            let v50 = C::i32_into_i64(ctx, v49);
            let v51 = constructor_imm(ctx, v50);
            let v52 = C::xreg_new(ctx, v51);
            let v53 = constructor_pulley_xneq32(ctx, v48, v52);
            // Rule at src\isa\pulley_shared\lower.isle line 1401.
            return v53;
        }
        &Cond::IfXslt32I32 {
            src1: v54,
            src2: v55,
        } => {
            let v56 = C::i32_into_i64(ctx, v55);
            let v57 = constructor_imm(ctx, v56);
            let v58 = C::xreg_new(ctx, v57);
            let v59 = constructor_pulley_xslt32(ctx, v54, v58);
            // Rule at src\isa\pulley_shared\lower.isle line 1402.
            return v59;
        }
        &Cond::IfXslteq32I32 {
            src1: v60,
            src2: v61,
        } => {
            let v62 = C::i32_into_i64(ctx, v61);
            let v63 = constructor_imm(ctx, v62);
            let v64 = C::xreg_new(ctx, v63);
            let v65 = constructor_pulley_xslteq32(ctx, v60, v64);
            // Rule at src\isa\pulley_shared\lower.isle line 1403.
            return v65;
        }
        &Cond::IfXult32I32 {
            src1: v66,
            src2: v67,
        } => {
            let v68 = C::u32_into_i64(ctx, v67);
            let v69 = constructor_imm(ctx, v68);
            let v70 = C::xreg_new(ctx, v69);
            let v71 = constructor_pulley_xult32(ctx, v66, v70);
            // Rule at src\isa\pulley_shared\lower.isle line 1404.
            return v71;
        }
        &Cond::IfXulteq32I32 {
            src1: v72,
            src2: v73,
        } => {
            let v74 = C::u32_into_i64(ctx, v73);
            let v75 = constructor_imm(ctx, v74);
            let v76 = C::xreg_new(ctx, v75);
            let v77 = constructor_pulley_xulteq32(ctx, v72, v76);
            // Rule at src\isa\pulley_shared\lower.isle line 1405.
            return v77;
        }
        &Cond::IfXsgt32I32 {
            src1: v78,
            src2: v79,
        } => {
            let v80 = C::i32_into_i64(ctx, v79);
            let v81 = constructor_imm(ctx, v80);
            let v82 = C::xreg_new(ctx, v81);
            let v83 = constructor_pulley_xslt32(ctx, v82, v78);
            // Rule at src\isa\pulley_shared\lower.isle line 1408.
            return v83;
        }
        &Cond::IfXsgteq32I32 {
            src1: v84,
            src2: v85,
        } => {
            let v86 = C::i32_into_i64(ctx, v85);
            let v87 = constructor_imm(ctx, v86);
            let v88 = C::xreg_new(ctx, v87);
            let v89 = constructor_pulley_xslteq32(ctx, v88, v84);
            // Rule at src\isa\pulley_shared\lower.isle line 1409.
            return v89;
        }
        &Cond::IfXugt32I32 {
            src1: v90,
            src2: v91,
        } => {
            let v92 = C::u32_into_i64(ctx, v91);
            let v93 = constructor_imm(ctx, v92);
            let v94 = C::xreg_new(ctx, v93);
            let v95 = constructor_pulley_xult32(ctx, v94, v90);
            // Rule at src\isa\pulley_shared\lower.isle line 1410.
            return v95;
        }
        &Cond::IfXugteq32I32 {
            src1: v96,
            src2: v97,
        } => {
            let v98 = C::u32_into_i64(ctx, v97);
            let v99 = constructor_imm(ctx, v98);
            let v100 = C::xreg_new(ctx, v99);
            let v101 = constructor_pulley_xulteq32(ctx, v100, v96);
            // Rule at src\isa\pulley_shared\lower.isle line 1411.
            return v101;
        }
        &Cond::IfXeq64 {
            src1: v24,
            src2: v25,
        } => {
            let v26 = constructor_pulley_xeq64(ctx, v24, v25);
            // Rule at src\isa\pulley_shared\lower.isle line 1393.
            return v26;
        }
        &Cond::IfXneq64 {
            src1: v27,
            src2: v28,
        } => {
            let v29 = constructor_pulley_xneq64(ctx, v27, v28);
            // Rule at src\isa\pulley_shared\lower.isle line 1394.
            return v29;
        }
        &Cond::IfXslt64 {
            src1: v30,
            src2: v31,
        } => {
            let v32 = constructor_pulley_xslt64(ctx, v30, v31);
            // Rule at src\isa\pulley_shared\lower.isle line 1395.
            return v32;
        }
        &Cond::IfXslteq64 {
            src1: v33,
            src2: v34,
        } => {
            let v35 = constructor_pulley_xslteq64(ctx, v33, v34);
            // Rule at src\isa\pulley_shared\lower.isle line 1396.
            return v35;
        }
        &Cond::IfXult64 {
            src1: v36,
            src2: v37,
        } => {
            let v38 = constructor_pulley_xult64(ctx, v36, v37);
            // Rule at src\isa\pulley_shared\lower.isle line 1397.
            return v38;
        }
        &Cond::IfXulteq64 {
            src1: v39,
            src2: v40,
        } => {
            let v41 = constructor_pulley_xulteq64(ctx, v39, v40);
            // Rule at src\isa\pulley_shared\lower.isle line 1398.
            return v41;
        }
        &Cond::IfXeq64I32 {
            src1: v102,
            src2: v103,
        } => {
            let v104 = C::i32_into_i64(ctx, v103);
            let v105 = constructor_imm(ctx, v104);
            let v106 = C::xreg_new(ctx, v105);
            let v107 = constructor_pulley_xeq64(ctx, v102, v106);
            // Rule at src\isa\pulley_shared\lower.isle line 1413.
            return v107;
        }
        &Cond::IfXneq64I32 {
            src1: v108,
            src2: v109,
        } => {
            let v110 = C::i32_into_i64(ctx, v109);
            let v111 = constructor_imm(ctx, v110);
            let v112 = C::xreg_new(ctx, v111);
            let v113 = constructor_pulley_xneq64(ctx, v108, v112);
            // Rule at src\isa\pulley_shared\lower.isle line 1414.
            return v113;
        }
        &Cond::IfXslt64I32 {
            src1: v114,
            src2: v115,
        } => {
            let v116 = C::i32_into_i64(ctx, v115);
            let v117 = constructor_imm(ctx, v116);
            let v118 = C::xreg_new(ctx, v117);
            let v119 = constructor_pulley_xslt64(ctx, v114, v118);
            // Rule at src\isa\pulley_shared\lower.isle line 1415.
            return v119;
        }
        &Cond::IfXslteq64I32 {
            src1: v120,
            src2: v121,
        } => {
            let v122 = C::i32_into_i64(ctx, v121);
            let v123 = constructor_imm(ctx, v122);
            let v124 = C::xreg_new(ctx, v123);
            let v125 = constructor_pulley_xslteq64(ctx, v120, v124);
            // Rule at src\isa\pulley_shared\lower.isle line 1416.
            return v125;
        }
        &Cond::IfXult64I32 {
            src1: v126,
            src2: v127,
        } => {
            let v128 = C::u32_into_i64(ctx, v127);
            let v129 = constructor_imm(ctx, v128);
            let v130 = C::xreg_new(ctx, v129);
            let v131 = constructor_pulley_xult64(ctx, v126, v130);
            // Rule at src\isa\pulley_shared\lower.isle line 1417.
            return v131;
        }
        &Cond::IfXulteq64I32 {
            src1: v132,
            src2: v133,
        } => {
            let v134 = C::u32_into_i64(ctx, v133);
            let v135 = constructor_imm(ctx, v134);
            let v136 = C::xreg_new(ctx, v135);
            let v137 = constructor_pulley_xulteq64(ctx, v132, v136);
            // Rule at src\isa\pulley_shared\lower.isle line 1418.
            return v137;
        }
        &Cond::IfXsgt64I32 {
            src1: v138,
            src2: v139,
        } => {
            let v140 = C::i32_into_i64(ctx, v139);
            let v141 = constructor_imm(ctx, v140);
            let v142 = C::xreg_new(ctx, v141);
            let v143 = constructor_pulley_xslt64(ctx, v142, v138);
            // Rule at src\isa\pulley_shared\lower.isle line 1421.
            return v143;
        }
        &Cond::IfXsgteq64I32 {
            src1: v144,
            src2: v145,
        } => {
            let v146 = C::i32_into_i64(ctx, v145);
            let v147 = constructor_imm(ctx, v146);
            let v148 = C::xreg_new(ctx, v147);
            let v149 = constructor_pulley_xslteq64(ctx, v148, v144);
            // Rule at src\isa\pulley_shared\lower.isle line 1422.
            return v149;
        }
        &Cond::IfXugt64I32 {
            src1: v150,
            src2: v151,
        } => {
            let v152 = C::u32_into_i64(ctx, v151);
            let v153 = constructor_imm(ctx, v152);
            let v154 = C::xreg_new(ctx, v153);
            let v155 = constructor_pulley_xult64(ctx, v154, v150);
            // Rule at src\isa\pulley_shared\lower.isle line 1423.
            return v155;
        }
        &Cond::IfXugteq64I32 {
            src1: v156,
            src2: v157,
        } => {
            let v158 = C::u32_into_i64(ctx, v157);
            let v159 = constructor_imm(ctx, v158);
            let v160 = C::xreg_new(ctx, v159);
            let v161 = constructor_pulley_xulteq64(ctx, v160, v156);
            // Rule at src\isa\pulley_shared\lower.isle line 1424.
            return v161;
        }
        _ => {}
    }
    unreachable!("no rule matched for term {} at {}; should it be partial?", "emit_cond", "src\\isa\\pulley_shared\\lower.isle line 1384")
}

// Generated as internal constructor for term pulley_nop.
pub fn constructor_pulley_nop<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::Nop);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 1652.
    return v2;
}

// Generated as internal constructor for term pulley_ret.
pub fn constructor_pulley_ret<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::Ret);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 1654.
    return v2;
}

// Generated as internal constructor for term pulley_xjump.
pub fn constructor_pulley_xjump<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> SideEffectNoResult {
    let v1 = RawInst::XJump {
        reg: arg0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 1656.
    return v3;
}

// Generated as internal constructor for term pulley_xmov.
pub fn constructor_pulley_xmov<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xmov {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1658.
    return v5;
}

// Generated as internal constructor for term pulley_xzero.
pub fn constructor_pulley_xzero<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::Xzero {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1665.
    return v4;
}

// Generated as internal constructor for term pulley_xone.
pub fn constructor_pulley_xone<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::Xone {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1672.
    return v4;
}

// Generated as internal constructor for term pulley_xconst8.
pub fn constructor_pulley_xconst8<C: Context>(
    ctx: &mut C,
    arg0: i8,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst8 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1679.
    return v5;
}

// Generated as internal constructor for term pulley_xconst16.
pub fn constructor_pulley_xconst16<C: Context>(
    ctx: &mut C,
    arg0: i16,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst16 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1686.
    return v5;
}

// Generated as internal constructor for term pulley_xconst32.
pub fn constructor_pulley_xconst32<C: Context>(
    ctx: &mut C,
    arg0: i32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst32 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1693.
    return v5;
}

// Generated as internal constructor for term pulley_xconst64.
pub fn constructor_pulley_xconst64<C: Context>(
    ctx: &mut C,
    arg0: i64,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xconst64 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1700.
    return v5;
}

// Generated as internal constructor for term pulley_xadd32.
pub fn constructor_pulley_xadd32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1707.
    return v6;
}

// Generated as internal constructor for term pulley_xadd32_u8.
pub fn constructor_pulley_xadd32_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd32U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1714.
    return v6;
}

// Generated as internal constructor for term pulley_xadd32_u32.
pub fn constructor_pulley_xadd32_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd32U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1721.
    return v6;
}

// Generated as internal constructor for term pulley_xadd64.
pub fn constructor_pulley_xadd64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1728.
    return v6;
}

// Generated as internal constructor for term pulley_xadd64_u8.
pub fn constructor_pulley_xadd64_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd64U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1735.
    return v6;
}

// Generated as internal constructor for term pulley_xadd64_u32.
pub fn constructor_pulley_xadd64_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xadd64U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1742.
    return v6;
}

// Generated as internal constructor for term pulley_xmadd32.
pub fn constructor_pulley_xmadd32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xmadd32 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        src3: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1749.
    return v7;
}

// Generated as internal constructor for term pulley_xmadd64.
pub fn constructor_pulley_xmadd64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xmadd64 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        src3: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1756.
    return v7;
}

// Generated as internal constructor for term pulley_xsub32.
pub fn constructor_pulley_xsub32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1763.
    return v6;
}

// Generated as internal constructor for term pulley_xsub32_u8.
pub fn constructor_pulley_xsub32_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub32U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1770.
    return v6;
}

// Generated as internal constructor for term pulley_xsub32_u32.
pub fn constructor_pulley_xsub32_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub32U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1777.
    return v6;
}

// Generated as internal constructor for term pulley_xsub64.
pub fn constructor_pulley_xsub64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1784.
    return v6;
}

// Generated as internal constructor for term pulley_xsub64_u8.
pub fn constructor_pulley_xsub64_u8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub64U8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1791.
    return v6;
}

// Generated as internal constructor for term pulley_xsub64_u32.
pub fn constructor_pulley_xsub64_u32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: u32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xsub64U32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1798.
    return v6;
}

// Generated as internal constructor for term pulley_xmul32.
pub fn constructor_pulley_xmul32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMul32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1805.
    return v6;
}

// Generated as internal constructor for term pulley_xmul32_s8.
pub fn constructor_pulley_xmul32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1812.
    return v6;
}

// Generated as internal constructor for term pulley_xmul32_s32.
pub fn constructor_pulley_xmul32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1819.
    return v6;
}

// Generated as internal constructor for term pulley_xmul64.
pub fn constructor_pulley_xmul64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMul64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1826.
    return v6;
}

// Generated as internal constructor for term pulley_xmul64_s8.
pub fn constructor_pulley_xmul64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1833.
    return v6;
}

// Generated as internal constructor for term pulley_xmul64_s32.
pub fn constructor_pulley_xmul64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmul64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1840.
    return v6;
}

// Generated as internal constructor for term pulley_xctz32.
pub fn constructor_pulley_xctz32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xctz32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1847.
    return v5;
}

// Generated as internal constructor for term pulley_xctz64.
pub fn constructor_pulley_xctz64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xctz64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1854.
    return v5;
}

// Generated as internal constructor for term pulley_xclz32.
pub fn constructor_pulley_xclz32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xclz32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1861.
    return v5;
}

// Generated as internal constructor for term pulley_xclz64.
pub fn constructor_pulley_xclz64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xclz64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1868.
    return v5;
}

// Generated as internal constructor for term pulley_xpopcnt32.
pub fn constructor_pulley_xpopcnt32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xpopcnt32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1875.
    return v5;
}

// Generated as internal constructor for term pulley_xpopcnt64.
pub fn constructor_pulley_xpopcnt64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xpopcnt64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1882.
    return v5;
}

// Generated as internal constructor for term pulley_xrotl32.
pub fn constructor_pulley_xrotl32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotl32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1889.
    return v6;
}

// Generated as internal constructor for term pulley_xrotl64.
pub fn constructor_pulley_xrotl64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotl64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1896.
    return v6;
}

// Generated as internal constructor for term pulley_xrotr32.
pub fn constructor_pulley_xrotr32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotr32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1903.
    return v6;
}

// Generated as internal constructor for term pulley_xrotr64.
pub fn constructor_pulley_xrotr64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xrotr64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1910.
    return v6;
}

// Generated as internal constructor for term pulley_xshl32.
pub fn constructor_pulley_xshl32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1917.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_s.
pub fn constructor_pulley_xshr32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1924.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_u.
pub fn constructor_pulley_xshr32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1931.
    return v6;
}

// Generated as internal constructor for term pulley_xshl64.
pub fn constructor_pulley_xshl64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1938.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_s.
pub fn constructor_pulley_xshr64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1945.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_u.
pub fn constructor_pulley_xshr64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1952.
    return v6;
}

// Generated as internal constructor for term pulley_xshl32_u6.
pub fn constructor_pulley_xshl32_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl32U6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1959.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_s_u6.
pub fn constructor_pulley_xshr32_s_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32SU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1966.
    return v6;
}

// Generated as internal constructor for term pulley_xshr32_u_u6.
pub fn constructor_pulley_xshr32_u_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr32UU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1973.
    return v6;
}

// Generated as internal constructor for term pulley_xshl64_u6.
pub fn constructor_pulley_xshl64_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshl64U6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1980.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_s_u6.
pub fn constructor_pulley_xshr64_s_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64SU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1987.
    return v6;
}

// Generated as internal constructor for term pulley_xshr64_u_u6.
pub fn constructor_pulley_xshr64_u_u6<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: U6,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xshr64UU6 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 1994.
    return v6;
}

// Generated as internal constructor for term pulley_xneg32.
pub fn constructor_pulley_xneg32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xneg32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2001.
    return v5;
}

// Generated as internal constructor for term pulley_xneg64.
pub fn constructor_pulley_xneg64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xneg64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2008.
    return v5;
}

// Generated as internal constructor for term pulley_xeq64.
pub fn constructor_pulley_xeq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xeq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2015.
    return v6;
}

// Generated as internal constructor for term pulley_xneq64.
pub fn constructor_pulley_xneq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xneq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2022.
    return v6;
}

// Generated as internal constructor for term pulley_xslt64.
pub fn constructor_pulley_xslt64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslt64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2029.
    return v6;
}

// Generated as internal constructor for term pulley_xslteq64.
pub fn constructor_pulley_xslteq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2036.
    return v6;
}

// Generated as internal constructor for term pulley_xult64.
pub fn constructor_pulley_xult64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xult64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2043.
    return v6;
}

// Generated as internal constructor for term pulley_xulteq64.
pub fn constructor_pulley_xulteq64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xulteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2050.
    return v6;
}

// Generated as internal constructor for term pulley_xeq32.
pub fn constructor_pulley_xeq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xeq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2057.
    return v6;
}

// Generated as internal constructor for term pulley_xneq32.
pub fn constructor_pulley_xneq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xneq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2064.
    return v6;
}

// Generated as internal constructor for term pulley_xslt32.
pub fn constructor_pulley_xslt32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslt32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2071.
    return v6;
}

// Generated as internal constructor for term pulley_xslteq32.
pub fn constructor_pulley_xslteq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xslteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2078.
    return v6;
}

// Generated as internal constructor for term pulley_xult32.
pub fn constructor_pulley_xult32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xult32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2085.
    return v6;
}

// Generated as internal constructor for term pulley_xulteq32.
pub fn constructor_pulley_xulteq32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xulteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2092.
    return v6;
}

// Generated as internal constructor for term pulley_xload8_u32_o32.
pub fn constructor_pulley_xload8_u32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2099.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_o32.
pub fn constructor_pulley_xload8_s32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2106.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_o32.
pub fn constructor_pulley_xload16le_u32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2113.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_o32.
pub fn constructor_pulley_xload16le_s32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2120.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_o32.
pub fn constructor_pulley_xload32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2127.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_o32.
pub fn constructor_pulley_xload64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2134.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_o32.
pub fn constructor_pulley_xstore8_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8O32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2141.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_o32.
pub fn constructor_pulley_xstore16le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2143.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_o32.
pub fn constructor_pulley_xstore32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2145.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_o32.
pub fn constructor_pulley_xstore64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2147.
    return v4;
}

// Generated as internal constructor for term pulley_xload8_u32_z.
pub fn constructor_pulley_xload8_u32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2149.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_z.
pub fn constructor_pulley_xload8_s32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2156.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_z.
pub fn constructor_pulley_xload16le_u32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2163.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_z.
pub fn constructor_pulley_xload16le_s32_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2170.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_z.
pub fn constructor_pulley_xload32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2177.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_z.
pub fn constructor_pulley_xload64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2184.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_z.
pub fn constructor_pulley_xstore8_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8Z {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2191.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_z.
pub fn constructor_pulley_xstore16le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2193.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_z.
pub fn constructor_pulley_xstore32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2195.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_z.
pub fn constructor_pulley_xstore64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2197.
    return v4;
}

// Generated as internal constructor for term pulley_xload8_u32_g32.
pub fn constructor_pulley_xload8_u32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2199.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_g32.
pub fn constructor_pulley_xload8_s32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2206.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_g32.
pub fn constructor_pulley_xload16le_u32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2213.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_g32.
pub fn constructor_pulley_xload16le_s32_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2220.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_g32.
pub fn constructor_pulley_xload32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2227.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_g32.
pub fn constructor_pulley_xload64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2234.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_g32.
pub fn constructor_pulley_xstore8_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8G32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2241.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_g32.
pub fn constructor_pulley_xstore16le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2243.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_g32.
pub fn constructor_pulley_xstore32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2245.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_g32.
pub fn constructor_pulley_xstore64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2247.
    return v4;
}

// Generated as internal constructor for term pulley_xload8_u32_g32bne.
pub fn constructor_pulley_xload8_u32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8U32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2249.
    return v5;
}

// Generated as internal constructor for term pulley_xload8_s32_g32bne.
pub fn constructor_pulley_xload8_s32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad8S32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2256.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_u32_g32bne.
pub fn constructor_pulley_xload16le_u32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeU32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2263.
    return v5;
}

// Generated as internal constructor for term pulley_xload16le_s32_g32bne.
pub fn constructor_pulley_xload16le_s32_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16LeS32G32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2270.
    return v5;
}

// Generated as internal constructor for term pulley_xload32le_g32bne.
pub fn constructor_pulley_xload32le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32LeG32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2277.
    return v5;
}

// Generated as internal constructor for term pulley_xload64le_g32bne.
pub fn constructor_pulley_xload64le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64LeG32Bne {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2284.
    return v5;
}

// Generated as internal constructor for term pulley_xstore8_g32bne.
pub fn constructor_pulley_xstore8_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore8G32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2291.
    return v4;
}

// Generated as internal constructor for term pulley_xstore16le_g32bne.
pub fn constructor_pulley_xstore16le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16LeG32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2293.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32le_g32bne.
pub fn constructor_pulley_xstore32le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32LeG32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2295.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64le_g32bne.
pub fn constructor_pulley_xstore64le_g32bne<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32Bne,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64LeG32Bne {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2297.
    return v4;
}

// Generated as internal constructor for term pulley_push_frame.
pub fn constructor_pulley_push_frame<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::PushFrame);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2299.
    return v2;
}

// Generated as internal constructor for term pulley_pop_frame.
pub fn constructor_pulley_pop_frame<C: Context>(
    ctx: &mut C,
) -> SideEffectNoResult {
    let v1 = &constructor_raw_inst_to_inst(ctx, &RawInst::PopFrame);
    let v2 = SideEffectNoResult::Inst {
        inst: v1.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2301.
    return v2;
}

// Generated as internal constructor for term pulley_push_frame_save.
pub fn constructor_pulley_push_frame_save<C: Context>(
    ctx: &mut C,
    arg0: u16,
    arg1: UpperXRegSet,
) -> SideEffectNoResult {
    let v2 = RawInst::PushFrameSave {
        amt: arg0,
        regs: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2303.
    return v4;
}

// Generated as internal constructor for term pulley_pop_frame_restore.
pub fn constructor_pulley_pop_frame_restore<C: Context>(
    ctx: &mut C,
    arg0: u16,
    arg1: UpperXRegSet,
) -> SideEffectNoResult {
    let v2 = RawInst::PopFrameRestore {
        amt: arg0,
        regs: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2305.
    return v4;
}

// Generated as internal constructor for term pulley_stack_alloc32.
pub fn constructor_pulley_stack_alloc32<C: Context>(
    ctx: &mut C,
    arg0: u32,
) -> SideEffectNoResult {
    let v1 = RawInst::StackAlloc32 {
        amt: arg0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2307.
    return v3;
}

// Generated as internal constructor for term pulley_stack_free32.
pub fn constructor_pulley_stack_free32<C: Context>(
    ctx: &mut C,
    arg0: u32,
) -> SideEffectNoResult {
    let v1 = RawInst::StackFree32 {
        amt: arg0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2309.
    return v3;
}

// Generated as internal constructor for term pulley_zext8.
pub fn constructor_pulley_zext8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Zext8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2311.
    return v5;
}

// Generated as internal constructor for term pulley_zext16.
pub fn constructor_pulley_zext16<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Zext16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2318.
    return v5;
}

// Generated as internal constructor for term pulley_zext32.
pub fn constructor_pulley_zext32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Zext32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2325.
    return v5;
}

// Generated as internal constructor for term pulley_sext8.
pub fn constructor_pulley_sext8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Sext8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2332.
    return v5;
}

// Generated as internal constructor for term pulley_sext16.
pub fn constructor_pulley_sext16<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Sext16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2339.
    return v5;
}

// Generated as internal constructor for term pulley_sext32.
pub fn constructor_pulley_sext32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Sext32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2346.
    return v5;
}

// Generated as internal constructor for term pulley_xabs32.
pub fn constructor_pulley_xabs32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XAbs32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2353.
    return v5;
}

// Generated as internal constructor for term pulley_xabs64.
pub fn constructor_pulley_xabs64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XAbs64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2360.
    return v5;
}

// Generated as internal constructor for term pulley_xdiv32_s.
pub fn constructor_pulley_xdiv32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2367.
    return v6;
}

// Generated as internal constructor for term pulley_xdiv64_s.
pub fn constructor_pulley_xdiv64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2374.
    return v6;
}

// Generated as internal constructor for term pulley_xdiv32_u.
pub fn constructor_pulley_xdiv32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2381.
    return v6;
}

// Generated as internal constructor for term pulley_xdiv64_u.
pub fn constructor_pulley_xdiv64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XDiv64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2388.
    return v6;
}

// Generated as internal constructor for term pulley_xrem32_s.
pub fn constructor_pulley_xrem32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2395.
    return v6;
}

// Generated as internal constructor for term pulley_xrem64_s.
pub fn constructor_pulley_xrem64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2402.
    return v6;
}

// Generated as internal constructor for term pulley_xrem32_u.
pub fn constructor_pulley_xrem32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2409.
    return v6;
}

// Generated as internal constructor for term pulley_xrem64_u.
pub fn constructor_pulley_xrem64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XRem64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2416.
    return v6;
}

// Generated as internal constructor for term pulley_xband32.
pub fn constructor_pulley_xband32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBand32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2423.
    return v6;
}

// Generated as internal constructor for term pulley_xband32_s8.
pub fn constructor_pulley_xband32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2430.
    return v6;
}

// Generated as internal constructor for term pulley_xband32_s32.
pub fn constructor_pulley_xband32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2437.
    return v6;
}

// Generated as internal constructor for term pulley_xband64.
pub fn constructor_pulley_xband64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBand64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2444.
    return v6;
}

// Generated as internal constructor for term pulley_xband64_s8.
pub fn constructor_pulley_xband64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2451.
    return v6;
}

// Generated as internal constructor for term pulley_xband64_s32.
pub fn constructor_pulley_xband64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xband64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2458.
    return v6;
}

// Generated as internal constructor for term pulley_xbor32.
pub fn constructor_pulley_xbor32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBor32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2465.
    return v6;
}

// Generated as internal constructor for term pulley_xbor32_s8.
pub fn constructor_pulley_xbor32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2472.
    return v6;
}

// Generated as internal constructor for term pulley_xbor32_s32.
pub fn constructor_pulley_xbor32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2479.
    return v6;
}

// Generated as internal constructor for term pulley_xbor64.
pub fn constructor_pulley_xbor64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBor64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2486.
    return v6;
}

// Generated as internal constructor for term pulley_xbor64_s8.
pub fn constructor_pulley_xbor64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2493.
    return v6;
}

// Generated as internal constructor for term pulley_xbor64_s32.
pub fn constructor_pulley_xbor64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbor64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2500.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor32.
pub fn constructor_pulley_xbxor32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBxor32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2507.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor32_s8.
pub fn constructor_pulley_xbxor32_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor32S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2514.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor32_s32.
pub fn constructor_pulley_xbxor32_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor32S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2521.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor64.
pub fn constructor_pulley_xbxor64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XBxor64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2528.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor64_s8.
pub fn constructor_pulley_xbxor64_s8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor64S8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2535.
    return v6;
}

// Generated as internal constructor for term pulley_xbxor64_s32.
pub fn constructor_pulley_xbxor64_s32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: i32,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xbxor64S32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2542.
    return v6;
}

// Generated as internal constructor for term pulley_xbnot32.
pub fn constructor_pulley_xbnot32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XBnot32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2549.
    return v5;
}

// Generated as internal constructor for term pulley_xbnot64.
pub fn constructor_pulley_xbnot64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XBnot64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2556.
    return v5;
}

// Generated as internal constructor for term pulley_xmin32_u.
pub fn constructor_pulley_xmin32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2563.
    return v6;
}

// Generated as internal constructor for term pulley_xmin32_s.
pub fn constructor_pulley_xmin32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2570.
    return v6;
}

// Generated as internal constructor for term pulley_xmax32_u.
pub fn constructor_pulley_xmax32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax32U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2577.
    return v6;
}

// Generated as internal constructor for term pulley_xmax32_s.
pub fn constructor_pulley_xmax32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax32S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2584.
    return v6;
}

// Generated as internal constructor for term pulley_xmin64_u.
pub fn constructor_pulley_xmin64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2591.
    return v6;
}

// Generated as internal constructor for term pulley_xmin64_s.
pub fn constructor_pulley_xmin64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmin64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2598.
    return v6;
}

// Generated as internal constructor for term pulley_xmax64_u.
pub fn constructor_pulley_xmax64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2605.
    return v6;
}

// Generated as internal constructor for term pulley_xmax64_s.
pub fn constructor_pulley_xmax64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Xmax64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2612.
    return v6;
}

// Generated as internal constructor for term pulley_xselect32.
pub fn constructor_pulley_xselect32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::XSelect32 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2619.
    return v7;
}

// Generated as internal constructor for term pulley_xselect64.
pub fn constructor_pulley_xselect64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::XSelect64 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2626.
    return v7;
}

// Generated as internal constructor for term pulley_trap.
pub fn constructor_pulley_trap<C: Context>(
    ctx: &mut C,
    arg0: &TrapCode,
) -> SideEffectNoResult {
    let v1 = RawInst::Trap {
        code: arg0.clone(),
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = SideEffectNoResult::Inst {
        inst: v2.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2633.
    return v3;
}

// Generated as internal constructor for term pulley_xpcadd.
pub fn constructor_pulley_xpcadd<C: Context>(
    ctx: &mut C,
    arg0: PcRelOffset,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xpcadd {
        dst: v1,
        offset: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2635.
    return v5;
}

// Generated as internal constructor for term pulley_xmov_fp.
pub fn constructor_pulley_xmov_fp<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::XmovFp {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2642.
    return v4;
}

// Generated as internal constructor for term pulley_xmov_lr.
pub fn constructor_pulley_xmov_lr<C: Context>(
    ctx: &mut C,
) -> XReg {
    let v0 = constructor_temp_writable_xreg(ctx);
    let v1 = RawInst::XmovLr {
        dst: v0,
    };
    let v2 = &constructor_raw_inst_to_inst(ctx, &v1);
    let v3 = C::emit(ctx, v2);
    let v4 = C::writable_xreg_to_xreg(ctx, v0);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2649.
    return v4;
}

// Generated as internal constructor for term pulley_bswap32.
pub fn constructor_pulley_bswap32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Bswap32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2656.
    return v5;
}

// Generated as internal constructor for term pulley_bswap64.
pub fn constructor_pulley_bswap64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Bswap64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2663.
    return v5;
}

// Generated as internal constructor for term pulley_xadd32_uoverflow_trap.
pub fn constructor_pulley_xadd32_uoverflow_trap<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: &TrapCode,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xadd32UoverflowTrap {
        dst: v3,
        src1: arg0,
        src2: arg1,
        code: arg2.clone(),
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2670.
    return v7;
}

// Generated as internal constructor for term pulley_xadd64_uoverflow_trap.
pub fn constructor_pulley_xadd64_uoverflow_trap<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: &TrapCode,
) -> XReg {
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xadd64UoverflowTrap {
        dst: v3,
        src1: arg0,
        src2: arg1,
        code: arg2.clone(),
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_xreg_to_xreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2677.
    return v7;
}

// Generated as internal constructor for term pulley_xmulhi64_s.
pub fn constructor_pulley_xmulhi64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMulHi64S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2684.
    return v6;
}

// Generated as internal constructor for term pulley_xmulhi64_u.
pub fn constructor_pulley_xmulhi64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XMulHi64U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2691.
    return v6;
}

// Generated as internal constructor for term pulley_xbmask32.
pub fn constructor_pulley_xbmask32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xbmask32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2698.
    return v5;
}

// Generated as internal constructor for term pulley_xbmask64.
pub fn constructor_pulley_xbmask64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Xbmask64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2705.
    return v5;
}

// Generated as internal constructor for term pulley_xload16be_u32_o32.
pub fn constructor_pulley_xload16be_u32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16BeU32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2712.
    return v5;
}

// Generated as internal constructor for term pulley_xload16be_s32_o32.
pub fn constructor_pulley_xload16be_s32_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad16BeS32O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2719.
    return v5;
}

// Generated as internal constructor for term pulley_xload32be_o32.
pub fn constructor_pulley_xload32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad32BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2726.
    return v5;
}

// Generated as internal constructor for term pulley_xload64be_o32.
pub fn constructor_pulley_xload64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::XLoad64BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2733.
    return v5;
}

// Generated as internal constructor for term pulley_xstore16be_o32.
pub fn constructor_pulley_xstore16be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore16BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2740.
    return v4;
}

// Generated as internal constructor for term pulley_xstore32be_o32.
pub fn constructor_pulley_xstore32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore32BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2742.
    return v4;
}

// Generated as internal constructor for term pulley_xstore64be_o32.
pub fn constructor_pulley_xstore64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: XReg,
) -> SideEffectNoResult {
    let v2 = RawInst::XStore64BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2744.
    return v4;
}

// Generated as internal constructor for term pulley_fload32be_o32.
pub fn constructor_pulley_fload32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2746.
    return v5;
}

// Generated as internal constructor for term pulley_fload64be_o32.
pub fn constructor_pulley_fload64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64BeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2753.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32be_o32.
pub fn constructor_pulley_fstore32be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2760.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64be_o32.
pub fn constructor_pulley_fstore64be_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64BeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2762.
    return v4;
}

// Generated as internal constructor for term pulley_fload32le_o32.
pub fn constructor_pulley_fload32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2764.
    return v5;
}

// Generated as internal constructor for term pulley_fload64le_o32.
pub fn constructor_pulley_fload64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64LeO32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2771.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32le_o32.
pub fn constructor_pulley_fstore32le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2778.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64le_o32.
pub fn constructor_pulley_fstore64le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2780.
    return v4;
}

// Generated as internal constructor for term pulley_fload32le_z.
pub fn constructor_pulley_fload32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2782.
    return v5;
}

// Generated as internal constructor for term pulley_fload64le_z.
pub fn constructor_pulley_fload64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64LeZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2789.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32le_z.
pub fn constructor_pulley_fstore32le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2796.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64le_z.
pub fn constructor_pulley_fstore64le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2798.
    return v4;
}

// Generated as internal constructor for term pulley_fload32le_g32.
pub fn constructor_pulley_fload32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload32LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2800.
    return v5;
}

// Generated as internal constructor for term pulley_fload64le_g32.
pub fn constructor_pulley_fload64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fload64LeG32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2807.
    return v5;
}

// Generated as internal constructor for term pulley_fstore32le_g32.
pub fn constructor_pulley_fstore32le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore32LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2814.
    return v4;
}

// Generated as internal constructor for term pulley_fstore64le_g32.
pub fn constructor_pulley_fstore64le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: FReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Fstore64LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2816.
    return v4;
}

// Generated as internal constructor for term pulley_vload128le_o32.
pub fn constructor_pulley_vload128le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad128O32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2818.
    return v5;
}

// Generated as internal constructor for term pulley_vstore128le_o32.
pub fn constructor_pulley_vstore128le_o32<C: Context>(
    ctx: &mut C,
    arg0: &AddrO32,
    arg1: VReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Vstore128LeO32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2825.
    return v4;
}

// Generated as internal constructor for term pulley_vload128le_z.
pub fn constructor_pulley_vload128le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad128Z {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2827.
    return v5;
}

// Generated as internal constructor for term pulley_vstore128le_z.
pub fn constructor_pulley_vstore128le_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
    arg1: VReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Vstore128LeZ {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2834.
    return v4;
}

// Generated as internal constructor for term pulley_vload128le_g32.
pub fn constructor_pulley_vload128le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad128G32 {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2836.
    return v5;
}

// Generated as internal constructor for term pulley_vstore128le_g32.
pub fn constructor_pulley_vstore128le_g32<C: Context>(
    ctx: &mut C,
    arg0: &AddrG32,
    arg1: VReg,
) -> SideEffectNoResult {
    let v2 = RawInst::Vstore128LeG32 {
        addr: arg0.clone(),
        src: arg1,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = SideEffectNoResult::Inst {
        inst: v3.clone(),
    };
    // Rule at <OUT_DIR>\pulley_gen.isle line 2843.
    return v4;
}

// Generated as internal constructor for term pulley_fmov.
pub fn constructor_pulley_fmov<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fmov {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2845.
    return v5;
}

// Generated as internal constructor for term pulley_vmov.
pub fn constructor_pulley_vmov<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vmov {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2852.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_int_from_float_32.
pub fn constructor_pulley_bitcast_int_from_float_32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::BitcastIntFromFloat32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2859.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_int_from_float_64.
pub fn constructor_pulley_bitcast_int_from_float_64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::BitcastIntFromFloat64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2866.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_float_from_int_32.
pub fn constructor_pulley_bitcast_float_from_int_32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::BitcastFloatFromInt32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2873.
    return v5;
}

// Generated as internal constructor for term pulley_bitcast_float_from_int_64.
pub fn constructor_pulley_bitcast_float_from_int_64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::BitcastFloatFromInt64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2880.
    return v5;
}

// Generated as internal constructor for term pulley_fconst32.
pub fn constructor_pulley_fconst32<C: Context>(
    ctx: &mut C,
    arg0: u32,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::FConst32 {
        dst: v1,
        bits: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2887.
    return v5;
}

// Generated as internal constructor for term pulley_fconst64.
pub fn constructor_pulley_fconst64<C: Context>(
    ctx: &mut C,
    arg0: u64,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::FConst64 {
        dst: v1,
        bits: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2894.
    return v5;
}

// Generated as internal constructor for term pulley_feq32.
pub fn constructor_pulley_feq32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Feq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2901.
    return v6;
}

// Generated as internal constructor for term pulley_fneq32.
pub fn constructor_pulley_fneq32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Fneq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2908.
    return v6;
}

// Generated as internal constructor for term pulley_flt32.
pub fn constructor_pulley_flt32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flt32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2915.
    return v6;
}

// Generated as internal constructor for term pulley_flteq32.
pub fn constructor_pulley_flteq32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flteq32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2922.
    return v6;
}

// Generated as internal constructor for term pulley_feq64.
pub fn constructor_pulley_feq64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Feq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2929.
    return v6;
}

// Generated as internal constructor for term pulley_fneq64.
pub fn constructor_pulley_fneq64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Fneq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2936.
    return v6;
}

// Generated as internal constructor for term pulley_flt64.
pub fn constructor_pulley_flt64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flt64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2943.
    return v6;
}

// Generated as internal constructor for term pulley_flteq64.
pub fn constructor_pulley_flteq64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::Flteq64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2950.
    return v6;
}

// Generated as internal constructor for term pulley_fselect32.
pub fn constructor_pulley_fselect32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: FReg,
    arg2: FReg,
) -> FReg {
    let v3 = constructor_temp_writable_freg(ctx);
    let v4 = RawInst::FSelect32 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_freg_to_freg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2957.
    return v7;
}

// Generated as internal constructor for term pulley_fselect64.
pub fn constructor_pulley_fselect64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: FReg,
    arg2: FReg,
) -> FReg {
    let v3 = constructor_temp_writable_freg(ctx);
    let v4 = RawInst::FSelect64 {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_freg_to_freg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2964.
    return v7;
}

// Generated as internal constructor for term pulley_f32_from_f64.
pub fn constructor_pulley_f32_from_f64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromF64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2971.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_f32.
pub fn constructor_pulley_f64_from_f32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromF32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2978.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x32_s.
pub fn constructor_pulley_f32_from_x32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2985.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x32_u.
pub fn constructor_pulley_f32_from_x32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2992.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x64_s.
pub fn constructor_pulley_f32_from_x64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 2999.
    return v5;
}

// Generated as internal constructor for term pulley_f32_from_x64_u.
pub fn constructor_pulley_f32_from_x64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F32FromX64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3006.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x32_s.
pub fn constructor_pulley_f64_from_x32_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3013.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x32_u.
pub fn constructor_pulley_f64_from_x32_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3020.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x64_s.
pub fn constructor_pulley_f64_from_x64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3027.
    return v5;
}

// Generated as internal constructor for term pulley_f64_from_x64_u.
pub fn constructor_pulley_f64_from_x64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::F64FromX64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3034.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_s.
pub fn constructor_pulley_x32_from_f32_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3041.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_u.
pub fn constructor_pulley_x32_from_f32_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3048.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_s.
pub fn constructor_pulley_x32_from_f64_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3055.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_u.
pub fn constructor_pulley_x32_from_f64_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3062.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_s.
pub fn constructor_pulley_x64_from_f32_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3069.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_u.
pub fn constructor_pulley_x64_from_f32_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3076.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_s.
pub fn constructor_pulley_x64_from_f64_s<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3083.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_u.
pub fn constructor_pulley_x64_from_f64_u<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3090.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_s_sat.
pub fn constructor_pulley_x32_from_f32_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3097.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f32_u_sat.
pub fn constructor_pulley_x32_from_f32_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF32USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3104.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_s_sat.
pub fn constructor_pulley_x32_from_f64_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3111.
    return v5;
}

// Generated as internal constructor for term pulley_x32_from_f64_u_sat.
pub fn constructor_pulley_x32_from_f64_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X32FromF64USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3118.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_s_sat.
pub fn constructor_pulley_x64_from_f32_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3125.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f32_u_sat.
pub fn constructor_pulley_x64_from_f32_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF32USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3132.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_s_sat.
pub fn constructor_pulley_x64_from_f64_s_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64SSat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3139.
    return v5;
}

// Generated as internal constructor for term pulley_x64_from_f64_u_sat.
pub fn constructor_pulley_x64_from_f64_u_sat<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::X64FromF64USat {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3146.
    return v5;
}

// Generated as internal constructor for term pulley_fcopysign32.
pub fn constructor_pulley_fcopysign32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FCopySign32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3153.
    return v6;
}

// Generated as internal constructor for term pulley_fcopysign64.
pub fn constructor_pulley_fcopysign64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FCopySign64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3160.
    return v6;
}

// Generated as internal constructor for term pulley_fadd32.
pub fn constructor_pulley_fadd32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fadd32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3167.
    return v6;
}

// Generated as internal constructor for term pulley_fsub32.
pub fn constructor_pulley_fsub32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fsub32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3174.
    return v6;
}

// Generated as internal constructor for term pulley_vsubf32x4.
pub fn constructor_pulley_vsubf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vsubf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3181.
    return v6;
}

// Generated as internal constructor for term pulley_fmul32.
pub fn constructor_pulley_fmul32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmul32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3188.
    return v6;
}

// Generated as internal constructor for term pulley_vmulf32x4.
pub fn constructor_pulley_vmulf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmulf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3195.
    return v6;
}

// Generated as internal constructor for term pulley_fdiv32.
pub fn constructor_pulley_fdiv32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fdiv32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3202.
    return v6;
}

// Generated as internal constructor for term pulley_vdivf32x4.
pub fn constructor_pulley_vdivf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vdivf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3209.
    return v6;
}

// Generated as internal constructor for term pulley_fmaximum32.
pub fn constructor_pulley_fmaximum32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmaximum32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3216.
    return v6;
}

// Generated as internal constructor for term pulley_fminimum32.
pub fn constructor_pulley_fminimum32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fminimum32 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3223.
    return v6;
}

// Generated as internal constructor for term pulley_ftrunc32.
pub fn constructor_pulley_ftrunc32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ftrunc32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3230.
    return v5;
}

// Generated as internal constructor for term pulley_vtrunc32x4.
pub fn constructor_pulley_vtrunc32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vtrunc32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3237.
    return v5;
}

// Generated as internal constructor for term pulley_vtrunc64x2.
pub fn constructor_pulley_vtrunc64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vtrunc64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3244.
    return v5;
}

// Generated as internal constructor for term pulley_ffloor32.
pub fn constructor_pulley_ffloor32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ffloor32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3251.
    return v5;
}

// Generated as internal constructor for term pulley_vfloor32x4.
pub fn constructor_pulley_vfloor32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vfloor32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3258.
    return v5;
}

// Generated as internal constructor for term pulley_vfloor64x2.
pub fn constructor_pulley_vfloor64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vfloor64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3265.
    return v5;
}

// Generated as internal constructor for term pulley_fceil32.
pub fn constructor_pulley_fceil32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fceil32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3272.
    return v5;
}

// Generated as internal constructor for term pulley_vceil32x4.
pub fn constructor_pulley_vceil32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vceil32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3279.
    return v5;
}

// Generated as internal constructor for term pulley_vceil64x2.
pub fn constructor_pulley_vceil64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vceil64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3286.
    return v5;
}

// Generated as internal constructor for term pulley_fnearest32.
pub fn constructor_pulley_fnearest32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fnearest32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3293.
    return v5;
}

// Generated as internal constructor for term pulley_fsqrt32.
pub fn constructor_pulley_fsqrt32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fsqrt32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3300.
    return v5;
}

// Generated as internal constructor for term pulley_vsqrt32x4.
pub fn constructor_pulley_vsqrt32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vsqrt32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3307.
    return v5;
}

// Generated as internal constructor for term pulley_vsqrt64x2.
pub fn constructor_pulley_vsqrt64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vsqrt64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3314.
    return v5;
}

// Generated as internal constructor for term pulley_fneg32.
pub fn constructor_pulley_fneg32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fneg32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3321.
    return v5;
}

// Generated as internal constructor for term pulley_vnegf32x4.
pub fn constructor_pulley_vnegf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vnegf32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3328.
    return v5;
}

// Generated as internal constructor for term pulley_fabs32.
pub fn constructor_pulley_fabs32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fabs32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3335.
    return v5;
}

// Generated as internal constructor for term pulley_fadd64.
pub fn constructor_pulley_fadd64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fadd64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3342.
    return v6;
}

// Generated as internal constructor for term pulley_fsub64.
pub fn constructor_pulley_fsub64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fsub64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3349.
    return v6;
}

// Generated as internal constructor for term pulley_fmul64.
pub fn constructor_pulley_fmul64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmul64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3356.
    return v6;
}

// Generated as internal constructor for term pulley_fdiv64.
pub fn constructor_pulley_fdiv64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fdiv64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3363.
    return v6;
}

// Generated as internal constructor for term pulley_vdivf64x2.
pub fn constructor_pulley_vdivf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VDivF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3370.
    return v6;
}

// Generated as internal constructor for term pulley_fmaximum64.
pub fn constructor_pulley_fmaximum64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fmaximum64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3377.
    return v6;
}

// Generated as internal constructor for term pulley_fminimum64.
pub fn constructor_pulley_fminimum64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
    arg1: FReg,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::Fminimum64 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3384.
    return v6;
}

// Generated as internal constructor for term pulley_ftrunc64.
pub fn constructor_pulley_ftrunc64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ftrunc64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3391.
    return v5;
}

// Generated as internal constructor for term pulley_ffloor64.
pub fn constructor_pulley_ffloor64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Ffloor64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3398.
    return v5;
}

// Generated as internal constructor for term pulley_fceil64.
pub fn constructor_pulley_fceil64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fceil64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3405.
    return v5;
}

// Generated as internal constructor for term pulley_fnearest64.
pub fn constructor_pulley_fnearest64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fnearest64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3412.
    return v5;
}

// Generated as internal constructor for term pulley_vnearest32x4.
pub fn constructor_pulley_vnearest32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vnearest32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3419.
    return v5;
}

// Generated as internal constructor for term pulley_vnearest64x2.
pub fn constructor_pulley_vnearest64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vnearest64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3426.
    return v5;
}

// Generated as internal constructor for term pulley_fsqrt64.
pub fn constructor_pulley_fsqrt64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fsqrt64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3433.
    return v5;
}

// Generated as internal constructor for term pulley_fneg64.
pub fn constructor_pulley_fneg64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fneg64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3440.
    return v5;
}

// Generated as internal constructor for term pulley_fabs64.
pub fn constructor_pulley_fabs64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> FReg {
    let v1 = constructor_temp_writable_freg(ctx);
    let v2 = RawInst::Fabs64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_freg_to_freg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3447.
    return v5;
}

// Generated as internal constructor for term pulley_vconst128.
pub fn constructor_pulley_vconst128<C: Context>(
    ctx: &mut C,
    arg0: u128,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vconst128 {
        dst: v1,
        imm: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3454.
    return v5;
}

// Generated as internal constructor for term pulley_vaddi8x16.
pub fn constructor_pulley_vaddi8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3461.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi16x8.
pub fn constructor_pulley_vaddi16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3468.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi32x4.
pub fn constructor_pulley_vaddi32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3475.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi64x2.
pub fn constructor_pulley_vaddi64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3482.
    return v6;
}

// Generated as internal constructor for term pulley_vaddf32x4.
pub fn constructor_pulley_vaddf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3489.
    return v6;
}

// Generated as internal constructor for term pulley_vaddf64x2.
pub fn constructor_pulley_vaddf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3496.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi8x16_sat.
pub fn constructor_pulley_vaddi8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3503.
    return v6;
}

// Generated as internal constructor for term pulley_vaddu8x16_sat.
pub fn constructor_pulley_vaddu8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddU8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3510.
    return v6;
}

// Generated as internal constructor for term pulley_vaddi16x8_sat.
pub fn constructor_pulley_vaddi16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddI16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3517.
    return v6;
}

// Generated as internal constructor for term pulley_vaddu16x8_sat.
pub fn constructor_pulley_vaddu16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddU16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3524.
    return v6;
}

// Generated as internal constructor for term pulley_vaddpairwisei16x8_s.
pub fn constructor_pulley_vaddpairwisei16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddpairwiseI16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3531.
    return v6;
}

// Generated as internal constructor for term pulley_vaddpairwisei32x4_s.
pub fn constructor_pulley_vaddpairwisei32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VAddpairwiseI32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3538.
    return v6;
}

// Generated as internal constructor for term pulley_vshli8x16.
pub fn constructor_pulley_vshli8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3545.
    return v6;
}

// Generated as internal constructor for term pulley_vshli16x8.
pub fn constructor_pulley_vshli16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3552.
    return v6;
}

// Generated as internal constructor for term pulley_vshli32x4.
pub fn constructor_pulley_vshli32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3559.
    return v6;
}

// Generated as internal constructor for term pulley_vshli64x2.
pub fn constructor_pulley_vshli64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShlI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3566.
    return v6;
}

// Generated as internal constructor for term pulley_vshri8x16_s.
pub fn constructor_pulley_vshri8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI8x16S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3573.
    return v6;
}

// Generated as internal constructor for term pulley_vshri16x8_s.
pub fn constructor_pulley_vshri16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3580.
    return v6;
}

// Generated as internal constructor for term pulley_vshri32x4_s.
pub fn constructor_pulley_vshri32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3587.
    return v6;
}

// Generated as internal constructor for term pulley_vshri64x2_s.
pub fn constructor_pulley_vshri64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI64x2S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3594.
    return v6;
}

// Generated as internal constructor for term pulley_vshri8x16_u.
pub fn constructor_pulley_vshri8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI8x16U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3601.
    return v6;
}

// Generated as internal constructor for term pulley_vshri16x8_u.
pub fn constructor_pulley_vshri16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3608.
    return v6;
}

// Generated as internal constructor for term pulley_vshri32x4_u.
pub fn constructor_pulley_vshri32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3615.
    return v6;
}

// Generated as internal constructor for term pulley_vshri64x2_u.
pub fn constructor_pulley_vshri64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VShrI64x2U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3622.
    return v6;
}

// Generated as internal constructor for term pulley_vsplatx8.
pub fn constructor_pulley_vsplatx8<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3629.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatx16.
pub fn constructor_pulley_vsplatx16<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3636.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatx32.
pub fn constructor_pulley_vsplatx32<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3643.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatx64.
pub fn constructor_pulley_vsplatx64<C: Context>(
    ctx: &mut C,
    arg0: XReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatX64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3650.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatf32.
pub fn constructor_pulley_vsplatf32<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatF32 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3657.
    return v5;
}

// Generated as internal constructor for term pulley_vsplatf64.
pub fn constructor_pulley_vsplatf64<C: Context>(
    ctx: &mut C,
    arg0: FReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VSplatF64 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3664.
    return v5;
}

// Generated as internal constructor for term pulley_vload8x8_s_z.
pub fn constructor_pulley_vload8x8_s_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad8x8SZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3671.
    return v5;
}

// Generated as internal constructor for term pulley_vload8x8_u_z.
pub fn constructor_pulley_vload8x8_u_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad8x8UZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3678.
    return v5;
}

// Generated as internal constructor for term pulley_vload16x4le_s_z.
pub fn constructor_pulley_vload16x4le_s_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad16x4LeSZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3685.
    return v5;
}

// Generated as internal constructor for term pulley_vload16x4le_u_z.
pub fn constructor_pulley_vload16x4le_u_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad16x4LeUZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3692.
    return v5;
}

// Generated as internal constructor for term pulley_vload32x2le_s_z.
pub fn constructor_pulley_vload32x2le_s_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad32x2LeSZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3699.
    return v5;
}

// Generated as internal constructor for term pulley_vload32x2le_u_z.
pub fn constructor_pulley_vload32x2le_u_z<C: Context>(
    ctx: &mut C,
    arg0: &AddrZ,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VLoad32x2LeUZ {
        dst: v1,
        addr: arg0.clone(),
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3706.
    return v5;
}

// Generated as internal constructor for term pulley_vband128.
pub fn constructor_pulley_vband128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VBand128 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3713.
    return v6;
}

// Generated as internal constructor for term pulley_vbor128.
pub fn constructor_pulley_vbor128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VBor128 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3720.
    return v6;
}

// Generated as internal constructor for term pulley_vbxor128.
pub fn constructor_pulley_vbxor128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VBxor128 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3727.
    return v6;
}

// Generated as internal constructor for term pulley_vbnot128.
pub fn constructor_pulley_vbnot128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VBnot128 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3734.
    return v5;
}

// Generated as internal constructor for term pulley_vbitselect128.
pub fn constructor_pulley_vbitselect128<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VBitselect128 {
        dst: v3,
        c: arg0,
        x: arg1,
        y: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3741.
    return v7;
}

// Generated as internal constructor for term pulley_vbitmask8x16.
pub fn constructor_pulley_vbitmask8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3748.
    return v5;
}

// Generated as internal constructor for term pulley_vbitmask16x8.
pub fn constructor_pulley_vbitmask16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3755.
    return v5;
}

// Generated as internal constructor for term pulley_vbitmask32x4.
pub fn constructor_pulley_vbitmask32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3762.
    return v5;
}

// Generated as internal constructor for term pulley_vbitmask64x2.
pub fn constructor_pulley_vbitmask64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vbitmask64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3769.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue8x16.
pub fn constructor_pulley_valltrue8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3776.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue16x8.
pub fn constructor_pulley_valltrue16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3783.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue32x4.
pub fn constructor_pulley_valltrue32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3790.
    return v5;
}

// Generated as internal constructor for term pulley_valltrue64x2.
pub fn constructor_pulley_valltrue64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Valltrue64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3797.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue8x16.
pub fn constructor_pulley_vanytrue8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3804.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue16x8.
pub fn constructor_pulley_vanytrue16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3811.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue32x4.
pub fn constructor_pulley_vanytrue32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3818.
    return v5;
}

// Generated as internal constructor for term pulley_vanytrue64x2.
pub fn constructor_pulley_vanytrue64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> XReg {
    let v1 = constructor_temp_writable_xreg(ctx);
    let v2 = RawInst::Vanytrue64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_xreg_to_xreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3825.
    return v5;
}

// Generated as internal constructor for term pulley_vf32x4_from_i32x4_s.
pub fn constructor_pulley_vf32x4_from_i32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF32x4FromI32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3832.
    return v5;
}

// Generated as internal constructor for term pulley_vf32x4_from_i32x4_u.
pub fn constructor_pulley_vf32x4_from_i32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF32x4FromI32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3839.
    return v5;
}

// Generated as internal constructor for term pulley_vf64x2_from_i64x2_s.
pub fn constructor_pulley_vf64x2_from_i64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF64x2FromI64x2S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3846.
    return v5;
}

// Generated as internal constructor for term pulley_vf64x2_from_i64x2_u.
pub fn constructor_pulley_vf64x2_from_i64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VF64x2FromI64x2U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3853.
    return v5;
}

// Generated as internal constructor for term pulley_vi32x4_from_f32x4_s.
pub fn constructor_pulley_vi32x4_from_f32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI32x4FromF32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3860.
    return v5;
}

// Generated as internal constructor for term pulley_vi32x4_from_f32x4_u.
pub fn constructor_pulley_vi32x4_from_f32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI32x4FromF32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3867.
    return v5;
}

// Generated as internal constructor for term pulley_vi64x2_from_f64x2_s.
pub fn constructor_pulley_vi64x2_from_f64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI64x2FromF64x2S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3874.
    return v5;
}

// Generated as internal constructor for term pulley_vi64x2_from_f64x2_u.
pub fn constructor_pulley_vi64x2_from_f64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VI64x2FromF64x2U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3881.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow8x16_s.
pub fn constructor_pulley_vwidenlow8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow8x16S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3888.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow8x16_u.
pub fn constructor_pulley_vwidenlow8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow8x16U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3895.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow16x8_s.
pub fn constructor_pulley_vwidenlow16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow16x8S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3902.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow16x8_u.
pub fn constructor_pulley_vwidenlow16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow16x8U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3909.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow32x4_s.
pub fn constructor_pulley_vwidenlow32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3916.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenlow32x4_u.
pub fn constructor_pulley_vwidenlow32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenLow32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3923.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh8x16_s.
pub fn constructor_pulley_vwidenhigh8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh8x16S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3930.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh8x16_u.
pub fn constructor_pulley_vwidenhigh8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh8x16U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3937.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh16x8_s.
pub fn constructor_pulley_vwidenhigh16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh16x8S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3944.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh16x8_u.
pub fn constructor_pulley_vwidenhigh16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh16x8U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3951.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh32x4_s.
pub fn constructor_pulley_vwidenhigh32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh32x4S {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3958.
    return v5;
}

// Generated as internal constructor for term pulley_vwidenhigh32x4_u.
pub fn constructor_pulley_vwidenhigh32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VWidenHigh32x4U {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3965.
    return v5;
}

// Generated as internal constructor for term pulley_vnarrow16x8_s.
pub fn constructor_pulley_vnarrow16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3972.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow16x8_u.
pub fn constructor_pulley_vnarrow16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3979.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow32x4_s.
pub fn constructor_pulley_vnarrow32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3986.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow32x4_u.
pub fn constructor_pulley_vnarrow32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 3993.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow64x2_s.
pub fn constructor_pulley_vnarrow64x2_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow64x2S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4000.
    return v6;
}

// Generated as internal constructor for term pulley_vnarrow64x2_u.
pub fn constructor_pulley_vnarrow64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vnarrow64x2U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4007.
    return v6;
}

// Generated as internal constructor for term pulley_vunarrow64x2_u.
pub fn constructor_pulley_vunarrow64x2_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vunarrow64x2U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4014.
    return v6;
}

// Generated as internal constructor for term pulley_vfpromotelow.
pub fn constructor_pulley_vfpromotelow<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VFpromoteLow {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4021.
    return v5;
}

// Generated as internal constructor for term pulley_vfdemote.
pub fn constructor_pulley_vfdemote<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VFdemote {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4028.
    return v5;
}

// Generated as internal constructor for term pulley_vsubi8x16.
pub fn constructor_pulley_vsubi8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4035.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi16x8.
pub fn constructor_pulley_vsubi16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4042.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi32x4.
pub fn constructor_pulley_vsubi32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4049.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi64x2.
pub fn constructor_pulley_vsubi64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4056.
    return v6;
}

// Generated as internal constructor for term pulley_vsubf64x2.
pub fn constructor_pulley_vsubf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4063.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi8x16_sat.
pub fn constructor_pulley_vsubi8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4070.
    return v6;
}

// Generated as internal constructor for term pulley_vsubu8x16_sat.
pub fn constructor_pulley_vsubu8x16_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubU8x16Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4077.
    return v6;
}

// Generated as internal constructor for term pulley_vsubi16x8_sat.
pub fn constructor_pulley_vsubi16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubI16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4084.
    return v6;
}

// Generated as internal constructor for term pulley_vsubu16x8_sat.
pub fn constructor_pulley_vsubu16x8_sat<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VSubU16x8Sat {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4091.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli8x16.
pub fn constructor_pulley_vmuli8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4098.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli16x8.
pub fn constructor_pulley_vmuli16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4105.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli32x4.
pub fn constructor_pulley_vmuli32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4112.
    return v6;
}

// Generated as internal constructor for term pulley_vmuli64x2.
pub fn constructor_pulley_vmuli64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulI64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4119.
    return v6;
}

// Generated as internal constructor for term pulley_vmulf64x2.
pub fn constructor_pulley_vmulf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VMulF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4126.
    return v6;
}

// Generated as internal constructor for term pulley_vqmulrsi16x8.
pub fn constructor_pulley_vqmulrsi16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VQmulrsI16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4133.
    return v6;
}

// Generated as internal constructor for term pulley_vpopcnt8x16.
pub fn constructor_pulley_vpopcnt8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VPopcnt8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4140.
    return v5;
}

// Generated as internal constructor for term pulley_xextractv8x16.
pub fn constructor_pulley_xextractv8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV8x16 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4147.
    return v6;
}

// Generated as internal constructor for term pulley_xextractv16x8.
pub fn constructor_pulley_xextractv16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV16x8 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4154.
    return v6;
}

// Generated as internal constructor for term pulley_xextractv32x4.
pub fn constructor_pulley_xextractv32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV32x4 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4161.
    return v6;
}

// Generated as internal constructor for term pulley_xextractv64x2.
pub fn constructor_pulley_xextractv64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> XReg {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = RawInst::XExtractV64x2 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_xreg_to_xreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4168.
    return v6;
}

// Generated as internal constructor for term pulley_fextractv32x4.
pub fn constructor_pulley_fextractv32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FExtractV32x4 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4175.
    return v6;
}

// Generated as internal constructor for term pulley_fextractv64x2.
pub fn constructor_pulley_fextractv64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: u8,
) -> FReg {
    let v2 = constructor_temp_writable_freg(ctx);
    let v3 = RawInst::FExtractV64x2 {
        dst: v2,
        src: arg0,
        lane: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_freg_to_freg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4182.
    return v6;
}

// Generated as internal constructor for term pulley_vinsertx8.
pub fn constructor_pulley_vinsertx8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX8 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4189.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertx16.
pub fn constructor_pulley_vinsertx16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX16 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4196.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertx32.
pub fn constructor_pulley_vinsertx32<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX32 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4203.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertx64.
pub fn constructor_pulley_vinsertx64<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: XReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertX64 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4210.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertf32.
pub fn constructor_pulley_vinsertf32<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: FReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertF32 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4217.
    return v7;
}

// Generated as internal constructor for term pulley_vinsertf64.
pub fn constructor_pulley_vinsertf64<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: FReg,
    arg2: u8,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VInsertF64 {
        dst: v3,
        src1: arg0,
        src2: arg1,
        lane: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4224.
    return v7;
}

// Generated as internal constructor for term pulley_veq8x16.
pub fn constructor_pulley_veq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4231.
    return v6;
}

// Generated as internal constructor for term pulley_vneq8x16.
pub fn constructor_pulley_vneq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4238.
    return v6;
}

// Generated as internal constructor for term pulley_vslt8x16.
pub fn constructor_pulley_vslt8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4245.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq8x16.
pub fn constructor_pulley_vslteq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4252.
    return v6;
}

// Generated as internal constructor for term pulley_vult8x16.
pub fn constructor_pulley_vult8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4259.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq8x16.
pub fn constructor_pulley_vulteq8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4266.
    return v6;
}

// Generated as internal constructor for term pulley_veq16x8.
pub fn constructor_pulley_veq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4273.
    return v6;
}

// Generated as internal constructor for term pulley_vneq16x8.
pub fn constructor_pulley_vneq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4280.
    return v6;
}

// Generated as internal constructor for term pulley_vslt16x8.
pub fn constructor_pulley_vslt16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4287.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq16x8.
pub fn constructor_pulley_vslteq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4294.
    return v6;
}

// Generated as internal constructor for term pulley_vult16x8.
pub fn constructor_pulley_vult16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4301.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq16x8.
pub fn constructor_pulley_vulteq16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4308.
    return v6;
}

// Generated as internal constructor for term pulley_veq32x4.
pub fn constructor_pulley_veq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4315.
    return v6;
}

// Generated as internal constructor for term pulley_vneq32x4.
pub fn constructor_pulley_vneq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4322.
    return v6;
}

// Generated as internal constructor for term pulley_vslt32x4.
pub fn constructor_pulley_vslt32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4329.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq32x4.
pub fn constructor_pulley_vslteq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4336.
    return v6;
}

// Generated as internal constructor for term pulley_vult32x4.
pub fn constructor_pulley_vult32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4343.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq32x4.
pub fn constructor_pulley_vulteq32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4350.
    return v6;
}

// Generated as internal constructor for term pulley_veq64x2.
pub fn constructor_pulley_veq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Veq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4357.
    return v6;
}

// Generated as internal constructor for term pulley_vneq64x2.
pub fn constructor_pulley_vneq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vneq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4364.
    return v6;
}

// Generated as internal constructor for term pulley_vslt64x2.
pub fn constructor_pulley_vslt64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslt64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4371.
    return v6;
}

// Generated as internal constructor for term pulley_vslteq64x2.
pub fn constructor_pulley_vslteq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vslteq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4378.
    return v6;
}

// Generated as internal constructor for term pulley_vult64x2.
pub fn constructor_pulley_vult64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vult64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4385.
    return v6;
}

// Generated as internal constructor for term pulley_vulteq64x2.
pub fn constructor_pulley_vulteq64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vulteq64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4392.
    return v6;
}

// Generated as internal constructor for term pulley_vneg8x16.
pub fn constructor_pulley_vneg8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4399.
    return v5;
}

// Generated as internal constructor for term pulley_vneg16x8.
pub fn constructor_pulley_vneg16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4406.
    return v5;
}

// Generated as internal constructor for term pulley_vneg32x4.
pub fn constructor_pulley_vneg32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4413.
    return v5;
}

// Generated as internal constructor for term pulley_vneg64x2.
pub fn constructor_pulley_vneg64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vneg64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4420.
    return v5;
}

// Generated as internal constructor for term pulley_vnegf64x2.
pub fn constructor_pulley_vnegf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::VnegF64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4427.
    return v5;
}

// Generated as internal constructor for term pulley_vmin8x16_s.
pub fn constructor_pulley_vmin8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin8x16S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4434.
    return v6;
}

// Generated as internal constructor for term pulley_vmin8x16_u.
pub fn constructor_pulley_vmin8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin8x16U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4441.
    return v6;
}

// Generated as internal constructor for term pulley_vmin16x8_s.
pub fn constructor_pulley_vmin16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4448.
    return v6;
}

// Generated as internal constructor for term pulley_vmin16x8_u.
pub fn constructor_pulley_vmin16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4455.
    return v6;
}

// Generated as internal constructor for term pulley_vmax8x16_s.
pub fn constructor_pulley_vmax8x16_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax8x16S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4462.
    return v6;
}

// Generated as internal constructor for term pulley_vmax8x16_u.
pub fn constructor_pulley_vmax8x16_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax8x16U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4469.
    return v6;
}

// Generated as internal constructor for term pulley_vmax16x8_s.
pub fn constructor_pulley_vmax16x8_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax16x8S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4476.
    return v6;
}

// Generated as internal constructor for term pulley_vmax16x8_u.
pub fn constructor_pulley_vmax16x8_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax16x8U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4483.
    return v6;
}

// Generated as internal constructor for term pulley_vmin32x4_s.
pub fn constructor_pulley_vmin32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4490.
    return v6;
}

// Generated as internal constructor for term pulley_vmin32x4_u.
pub fn constructor_pulley_vmin32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmin32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4497.
    return v6;
}

// Generated as internal constructor for term pulley_vmax32x4_s.
pub fn constructor_pulley_vmax32x4_s<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax32x4S {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4504.
    return v6;
}

// Generated as internal constructor for term pulley_vmax32x4_u.
pub fn constructor_pulley_vmax32x4_u<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmax32x4U {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4511.
    return v6;
}

// Generated as internal constructor for term pulley_vabs8x16.
pub fn constructor_pulley_vabs8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs8x16 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4518.
    return v5;
}

// Generated as internal constructor for term pulley_vabs16x8.
pub fn constructor_pulley_vabs16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs16x8 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4525.
    return v5;
}

// Generated as internal constructor for term pulley_vabs32x4.
pub fn constructor_pulley_vabs32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4532.
    return v5;
}

// Generated as internal constructor for term pulley_vabs64x2.
pub fn constructor_pulley_vabs64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabs64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4539.
    return v5;
}

// Generated as internal constructor for term pulley_vabsf32x4.
pub fn constructor_pulley_vabsf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabsf32x4 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4546.
    return v5;
}

// Generated as internal constructor for term pulley_vabsf64x2.
pub fn constructor_pulley_vabsf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
) -> VReg {
    let v1 = constructor_temp_writable_vreg(ctx);
    let v2 = RawInst::Vabsf64x2 {
        dst: v1,
        src: arg0,
    };
    let v3 = &constructor_raw_inst_to_inst(ctx, &v2);
    let v4 = C::emit(ctx, v3);
    let v5 = C::writable_vreg_to_vreg(ctx, v1);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4553.
    return v5;
}

// Generated as internal constructor for term pulley_vmaximumf32x4.
pub fn constructor_pulley_vmaximumf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmaximumf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4560.
    return v6;
}

// Generated as internal constructor for term pulley_vmaximumf64x2.
pub fn constructor_pulley_vmaximumf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vmaximumf64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4567.
    return v6;
}

// Generated as internal constructor for term pulley_vminimumf32x4.
pub fn constructor_pulley_vminimumf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vminimumf32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4574.
    return v6;
}

// Generated as internal constructor for term pulley_vminimumf64x2.
pub fn constructor_pulley_vminimumf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vminimumf64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4581.
    return v6;
}

// Generated as internal constructor for term pulley_vshuffle.
pub fn constructor_pulley_vshuffle<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: u128,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::VShuffle {
        dst: v3,
        src1: arg0,
        src2: arg1,
        mask: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4588.
    return v7;
}

// Generated as internal constructor for term pulley_vswizzlei8x16.
pub fn constructor_pulley_vswizzlei8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vswizzlei8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4595.
    return v6;
}

// Generated as internal constructor for term pulley_vavground8x16.
pub fn constructor_pulley_vavground8x16<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vavground8x16 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4602.
    return v6;
}

// Generated as internal constructor for term pulley_vavground16x8.
pub fn constructor_pulley_vavground16x8<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::Vavground16x8 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4609.
    return v6;
}

// Generated as internal constructor for term pulley_veqf32x4.
pub fn constructor_pulley_veqf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VeqF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4616.
    return v6;
}

// Generated as internal constructor for term pulley_vneqf32x4.
pub fn constructor_pulley_vneqf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VneqF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4623.
    return v6;
}

// Generated as internal constructor for term pulley_vltf32x4.
pub fn constructor_pulley_vltf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VltF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4630.
    return v6;
}

// Generated as internal constructor for term pulley_vlteqf32x4.
pub fn constructor_pulley_vlteqf32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VlteqF32x4 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4637.
    return v6;
}

// Generated as internal constructor for term pulley_veqf64x2.
pub fn constructor_pulley_veqf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VeqF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4644.
    return v6;
}

// Generated as internal constructor for term pulley_vneqf64x2.
pub fn constructor_pulley_vneqf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VneqF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4651.
    return v6;
}

// Generated as internal constructor for term pulley_vltf64x2.
pub fn constructor_pulley_vltf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VltF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4658.
    return v6;
}

// Generated as internal constructor for term pulley_vlteqf64x2.
pub fn constructor_pulley_vlteqf64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
) -> VReg {
    let v2 = constructor_temp_writable_vreg(ctx);
    let v3 = RawInst::VlteqF64x2 {
        dst: v2,
        src1: arg0,
        src2: arg1,
    };
    let v4 = &constructor_raw_inst_to_inst(ctx, &v3);
    let v5 = C::emit(ctx, v4);
    let v6 = C::writable_vreg_to_vreg(ctx, v2);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4665.
    return v6;
}

// Generated as internal constructor for term pulley_vfma32x4.
pub fn constructor_pulley_vfma32x4<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::Vfma32x4 {
        dst: v3,
        a: arg0,
        b: arg1,
        c: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4672.
    return v7;
}

// Generated as internal constructor for term pulley_vfma64x2.
pub fn constructor_pulley_vfma64x2<C: Context>(
    ctx: &mut C,
    arg0: VReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::Vfma64x2 {
        dst: v3,
        a: arg0,
        b: arg1,
        c: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4679.
    return v7;
}

// Generated as internal constructor for term pulley_vselect.
pub fn constructor_pulley_vselect<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: VReg,
    arg2: VReg,
) -> VReg {
    let v3 = constructor_temp_writable_vreg(ctx);
    let v4 = RawInst::Vselect {
        dst: v3,
        cond: arg0,
        if_nonzero: arg1,
        if_zero: arg2,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = C::writable_vreg_to_vreg(ctx, v3);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4686.
    return v7;
}

// Generated as internal constructor for term pulley_xadd128.
pub fn constructor_pulley_xadd128<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
    arg3: XReg,
) -> ValueRegs {
    let v4 = constructor_temp_writable_xreg(ctx);
    let v5 = constructor_temp_writable_xreg(ctx);
    let v6 = RawInst::Xadd128 {
        dst_lo: v4,
        dst_hi: v5,
        lhs_lo: arg0,
        lhs_hi: arg1,
        rhs_lo: arg2,
        rhs_hi: arg3,
    };
    let v7 = &constructor_raw_inst_to_inst(ctx, &v6);
    let v8 = C::emit(ctx, v7);
    let v9 = constructor_writable_xreg_to_reg(ctx, v4);
    let v10 = constructor_writable_xreg_to_reg(ctx, v5);
    let v11 = C::value_regs(ctx, v9, v10);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4693.
    return v11;
}

// Generated as internal constructor for term pulley_xsub128.
pub fn constructor_pulley_xsub128<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
    arg2: XReg,
    arg3: XReg,
) -> ValueRegs {
    let v4 = constructor_temp_writable_xreg(ctx);
    let v5 = constructor_temp_writable_xreg(ctx);
    let v6 = RawInst::Xsub128 {
        dst_lo: v4,
        dst_hi: v5,
        lhs_lo: arg0,
        lhs_hi: arg1,
        rhs_lo: arg2,
        rhs_hi: arg3,
    };
    let v7 = &constructor_raw_inst_to_inst(ctx, &v6);
    let v8 = C::emit(ctx, v7);
    let v9 = constructor_writable_xreg_to_reg(ctx, v4);
    let v10 = constructor_writable_xreg_to_reg(ctx, v5);
    let v11 = C::value_regs(ctx, v9, v10);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4701.
    return v11;
}

// Generated as internal constructor for term pulley_xwidemul64_s.
pub fn constructor_pulley_xwidemul64_s<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> ValueRegs {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xwidemul64S {
        dst_lo: v2,
        dst_hi: v3,
        lhs: arg0,
        rhs: arg1,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = constructor_writable_xreg_to_reg(ctx, v2);
    let v8 = constructor_writable_xreg_to_reg(ctx, v3);
    let v9 = C::value_regs(ctx, v7, v8);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4709.
    return v9;
}

// Generated as internal constructor for term pulley_xwidemul64_u.
pub fn constructor_pulley_xwidemul64_u<C: Context>(
    ctx: &mut C,
    arg0: XReg,
    arg1: XReg,
) -> ValueRegs {
    let v2 = constructor_temp_writable_xreg(ctx);
    let v3 = constructor_temp_writable_xreg(ctx);
    let v4 = RawInst::Xwidemul64U {
        dst_lo: v2,
        dst_hi: v3,
        lhs: arg0,
        rhs: arg1,
    };
    let v5 = &constructor_raw_inst_to_inst(ctx, &v4);
    let v6 = C::emit(ctx, v5);
    let v7 = constructor_writable_xreg_to_reg(ctx, v2);
    let v8 = constructor_writable_xreg_to_reg(ctx, v3);
    let v9 = C::value_regs(ctx, v7, v8);
    // Rule at <OUT_DIR>\pulley_gen.isle line 4717.
    return v9;
}
